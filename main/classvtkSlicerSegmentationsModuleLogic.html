<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer: vtkSlicerSegmentationsModuleLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="3DSlicer-DesktopIcon.png"/></td>
  <td id="projectalign">
   <div id="projectname">Slicer<span id="projectnumber">&#160;5.9</span>
   </div>
   <div id="projectbrief">Slicer is a multi-platform, free and open source software package for visualization and medical image computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classvtkSlicerSegmentationsModuleLogic-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">vtkSlicerSegmentationsModuleLogic Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">Modules/Loadable/Segmentations/Logic/vtkSlicerSegmentationsModuleLogic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vtkSlicerSegmentationsModuleLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerSegmentationsModuleLogic__inherit__graph.png" border="0" usemap="#avtkSlicerSegmentationsModuleLogic_inherit__map" alt="Inheritance graph"/></div>
<map name="avtkSlicerSegmentationsModuleLogic_inherit__map" id="avtkSlicerSegmentationsModuleLogic_inherit__map">
<area shape="rect" title=" " alt="" coords="5,225,231,265"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="37,152,199,177"/>
<area shape="poly" title=" " alt="" coords="121,191,121,225,115,225,115,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="32,79,204,104"/>
<area shape="poly" title=" " alt="" coords="121,118,121,152,115,152,115,118"/>
<area shape="rect" title=" " alt="" coords="75,5,161,31"/>
<area shape="poly" title=" " alt="" coords="121,44,121,79,115,79,115,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vtkSlicerSegmentationsModuleLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerSegmentationsModuleLogic__coll__graph.png" border="0" usemap="#avtkSlicerSegmentationsModuleLogic_coll__map" alt="Collaboration graph"/></div>
<map name="avtkSlicerSegmentationsModuleLogic_coll__map" id="avtkSlicerSegmentationsModuleLogic_coll__map">
<area shape="rect" title=" " alt="" coords="5,225,231,265"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="37,152,199,177"/>
<area shape="poly" title=" " alt="" coords="121,191,121,225,115,225,115,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="32,79,204,104"/>
<area shape="poly" title=" " alt="" coords="121,118,121,152,115,152,115,118"/>
<area shape="rect" title=" " alt="" coords="75,5,161,31"/>
<area shape="poly" title=" " alt="" coords="121,44,121,79,115,79,115,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4a6d97d1f74f8f40848a56762923acf9" id="r_a4a6d97d1f74f8f40848a56762923acf9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9a652b1321323351ef3a3ea6137f058c5f">MODE_REPLACE</a> = 0
, <a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9afaaf58b6b71ee0e869d7014d509e8188">MODE_MERGE_MAX</a>
, <a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9a988354e808b19fa75f6c96509b95bd01">MODE_MERGE_MIN</a>
, <a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9ac0e80d26e4e128b38a4ffb04b77260c1">MODE_MERGE_MASK</a>
 }</td></tr>
<tr class="separator:a4a6d97d1f74f8f40848a56762923acf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab170ee5954320b4f13ad31ac813e71a6" id="r_ab170ee5954320b4f13ad31ac813e71a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">SegmentStatus</a> { <br />
&#160;&#160;<a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a8e0cbf635a519641c3aa87d9c5280c53">NotStarted</a>
, <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a678114ce0567fcc4d6b3c85a66148d91">InProgress</a>
, <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a667946e0eb1f8c38a2e046bf0f7a69ad">Completed</a>
, <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a02406a9706384067af897cfdf3322d4a">Flagged</a>
, <br />
&#160;&#160;<a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a7bd2a188ef7179f9c18ecb213f85e4d2">LastStatus</a>
<br />
 }</td></tr>
<tr class="separator:ab170ee5954320b4f13ad31ac813e71a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a2335ad36a127f119222dbc5faa644" id="r_ad8a2335ad36a127f119222dbc5faa644"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a2335ad36a127f119222dbc5faa644">Superclass</a></td></tr>
<tr class="separator:ad8a2335ad36a127f119222dbc5faa644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic" id="r_a85b117de65a91398ccf70ccfc2edc275"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a85b117de65a91398ccf70ccfc2edc275">Superclass</a></td></tr>
<tr class="separator:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic" id="r_ab2fef06324d2444212855c6ed44e3ead"><td class="memItemLeft" align="right" valign="top">typedef vtkObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab2fef06324d2444212855c6ed44e3ead">Superclass</a></td></tr>
<tr class="separator:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic" id="r_aaa2c5b4f57066c706fd86982299adbde"><td class="memItemLeft" align="right" valign="top">typedef void(vtkMRMLAbstractLogic::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aaa2c5b4f57066c706fd86982299adbde">TaskFunctionPointer</a>) (void *clientdata)</td></tr>
<tr class="separator:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac2d200b23f898eb8d28cdcf69801fdd8" id="r_ac2d200b23f898eb8d28cdcf69801fdd8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d200b23f898eb8d28cdcf69801fdd8">GetClassName</a> ()</td></tr>
<tr class="separator:ac2d200b23f898eb8d28cdcf69801fdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d57c8fee035e33bc6d086ff7e90bf77" id="r_a2d57c8fee035e33bc6d086ff7e90bf77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d57c8fee035e33bc6d086ff7e90bf77">GetDefaultOverwriteMode</a> ()</td></tr>
<tr class="memdesc:a2d57c8fee035e33bc6d086ff7e90bf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get/Set default segmentation overwrite mode for masking options.  <br /></td></tr>
<tr class="separator:a2d57c8fee035e33bc6d086ff7e90bf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c1464d8e10533b4bc360811c1e00d9" id="r_a38c1464d8e10533b4bc360811c1e00d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38c1464d8e10533b4bc360811c1e00d9">GetDefaultSegmentationNode</a> ()</td></tr>
<tr class="memdesc:a38c1464d8e10533b4bc360811c1e00d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default segmentation node. All new segmentation nodes are initialized to the content of this node.  <br /></td></tr>
<tr class="separator:a38c1464d8e10533b4bc360811c1e00d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac621bb77c860d21943a99695cdd0ec7e" id="r_ac621bb77c860d21943a99695cdd0ec7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLSegmentEditorNode.html">vtkMRMLSegmentEditorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac621bb77c860d21943a99695cdd0ec7e">GetDefaultSegmentEditorNode</a> ()</td></tr>
<tr class="memdesc:ac621bb77c860d21943a99695cdd0ec7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node that is used for initializing each new Segment Editor node.  <br /></td></tr>
<tr class="separator:ac621bb77c860d21943a99695cdd0ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ceeaa72e16d822a19b2d4a6bfea341" id="r_ac6ceeaa72e16d822a19b2d4a6bfea341"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ceeaa72e16d822a19b2d4a6bfea341">GetDefaultSurfaceSmoothingEnabled</a> ()</td></tr>
<tr class="memdesc:ac6ceeaa72e16d822a19b2d4a6bfea341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get/Set default closed surface smoothing enabled flag for new segmentation nodes.  <br /></td></tr>
<tr class="separator:ac6ceeaa72e16d822a19b2d4a6bfea341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9309513d633a096fe9f9299b14faf0c9" id="r_a9309513d633a096fe9f9299b14faf0c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9309513d633a096fe9f9299b14faf0c9">ImportLabelmapToSegmentationNodeWithTerminology</a> (<a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string terminologyContextName, std::string insertBeforeSegmentId=&quot;&quot;, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:a9309513d633a096fe9f9299b14faf0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4528a1936927b8dc6dcce4ecba1170" id="r_a6a4528a1936927b8dc6dcce4ecba1170"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a4528a1936927b8dc6dcce4ecba1170">IsA</a> (const char *type)</td></tr>
<tr class="separator:a6a4528a1936927b8dc6dcce4ecba1170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b85e29f429607907d1f9a3d94460e8" id="r_a61b85e29f429607907d1f9a3d94460e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61b85e29f429607907d1f9a3d94460e8">LoadSegmentationFromFile</a> (const char *filename, bool autoOpacities=true, const char *nodeName=nullptr, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:a61b85e29f429607907d1f9a3d94460e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace432e6b1baf02d1b594c5e925318dc5" id="r_ace432e6b1baf02d1b594c5e925318dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace432e6b1baf02d1b594c5e925318dc5">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:ace432e6b1baf02d1b594c5e925318dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75765e3d51cd66ba921d315803a6768" id="r_ac75765e3d51cd66ba921d315803a6768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac75765e3d51cd66ba921d315803a6768">SetDefaultOverwriteMode</a> (int mode)</td></tr>
<tr class="separator:ac75765e3d51cd66ba921d315803a6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b484043245ad8ada5ee2f96b9d4b1dd" id="r_a0b484043245ad8ada5ee2f96b9d4b1dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b484043245ad8ada5ee2f96b9d4b1dd">SetDefaultSurfaceSmoothingEnabled</a> (bool enabled)</td></tr>
<tr class="separator:a0b484043245ad8ada5ee2f96b9d4b1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5c4726cfd134518285aee4f701a965" id="r_adb5c4726cfd134518285aee4f701a965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb5c4726cfd134518285aee4f701a965">SetTerminologyToSegmentationFromLabelmapNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, std::string terminologyContextName)</td></tr>
<tr class="separator:adb5c4726cfd134518285aee4f701a965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a8931a0176e046fa530d68105ceecef66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkSlicerApplicationLogic.html">vtkSlicerApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a8931a0176e046fa530d68105ceecef66">GetApplicationLogic</a> ()</td></tr>
<tr class="memdesc:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0da4557f1f4335d1e4b5f08be2d282e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0da4557f1f4335d1e4b5f08be2d282e7">GetModuleLogic</a> (const char *moduleName)</td></tr>
<tr class="memdesc:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for getting another module's logic from the application logic.  <br /></td></tr>
<tr class="separator:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic" id="r_aef42603c86610d6a6e93f3d48323f7ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#aef42603c86610d6a6e93f3d48323f7ef">GetModuleShareDirectory</a> () const</td></tr>
<tr class="separator:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0e3bbf7759001cc13890f41d1a79c598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0e3bbf7759001cc13890f41d1a79c598">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a2918ff2ca1a047594ab5f21d7fa93997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a2918ff2ca1a047594ab5f21d7fa93997">SetModuleShareDirectory</a> (const std::string &amp;shareDirectory)</td></tr>
<tr class="separator:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a530bc426ed6f5725f82b67bc7383ef51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a530bc426ed6f5725f82b67bc7383ef51">GetMRMLApplicationLogic</a> () const</td></tr>
<tr class="memdesc:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a147f82b5aaaf465ccdb5cabbfef8e6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a147f82b5aaaf465ccdb5cabbfef8e6e8">GetMRMLScene</a> () const</td></tr>
<tr class="memdesc:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the current MRML scene.  <br /></td></tr>
<tr class="separator:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a30dc8aa28d58ca3f9a52ee9923fb13a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a30dc8aa28d58ca3f9a52ee9923fb13a9">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a95af27a03775e432e2e9a4ffa0681a8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a95af27a03775e432e2e9a4ffa0681a8c">SetMRMLApplicationLogic</a> (<a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *logic)</td></tr>
<tr class="separator:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a51f4149e574bb15f5d082dc93c07543e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51f4149e574bb15f5d082dc93c07543e">SetMRMLScene</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene)</td></tr>
<tr class="memdesc:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and observe the MRMLScene.  <br /></td></tr>
<tr class="separator:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9769ef5a254100f95de963d4ee58df44" id="r_a9769ef5a254100f95de963d4ee58df44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9769ef5a254100f95de963d4ee58df44">AddColorTableNodeForSegmentation</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode)</td></tr>
<tr class="separator:a9769ef5a254100f95de963d4ee58df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bf9a75cb8bfa1b2bf15f0765df9262" id="r_ad2bf9a75cb8bfa1b2bf15f0765df9262"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2bf9a75cb8bfa1b2bf15f0765df9262">ApplyParentTransformToOrientedImageData</a> (<a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *transformableNode, <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *orientedImageData, bool linearInterpolation=false, double backgroundColor[4]=nullptr)</td></tr>
<tr class="separator:ad2bf9a75cb8bfa1b2bf15f0765df9262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae427f532e81b9f2d1feb901c0eb93311" id="r_ae427f532e81b9f2d1feb901c0eb93311"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae427f532e81b9f2d1feb901c0eb93311">ApplyParentTransformToPolyData</a> (<a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *transformableNode, vtkPolyData *polyData)</td></tr>
<tr class="separator:ae427f532e81b9f2d1feb901c0eb93311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cd04545ba3476fcf92bb9d22a0f8cd" id="r_ad1cd04545ba3476fcf92bb9d22a0f8cd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1cd04545ba3476fcf92bb9d22a0f8cd">ClearSegment</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string segmentID)</td></tr>
<tr class="memdesc:ad1cd04545ba3476fcf92bb9d22a0f8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the contents of a single segment.  <br /></td></tr>
<tr class="separator:ad1cd04545ba3476fcf92bb9d22a0f8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b461b7d591fc8f2c45d25caf00f88a9" id="r_a3b461b7d591fc8f2c45d25caf00f88a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b461b7d591fc8f2c45d25caf00f88a9">CollapseBinaryLabelmaps</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, bool forceToSingleLayer)</td></tr>
<tr class="separator:a3b461b7d591fc8f2c45d25caf00f88a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af646c7a49b75de5799f2c51fcce47ed2" id="r_af646c7a49b75de5799f2c51fcce47ed2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af646c7a49b75de5799f2c51fcce47ed2">CopyOrientedImageDataToVolumeNode</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *orientedImageData, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *volumeNode, bool shallowCopy=true, bool shiftImageDataExtentToZeroStart=true)</td></tr>
<tr class="separator:af646c7a49b75de5799f2c51fcce47ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3b0625100907ebdfcef9772c58027" id="r_ad2c3b0625100907ebdfcef9772c58027"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c3b0625100907ebdfcef9772c58027">CreateLabelmapVolumeFromOrientedImageData</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *orientedImageData, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapVolumeNode)</td></tr>
<tr class="separator:ad2c3b0625100907ebdfcef9772c58027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c86aa65690d40eb9a5e68f26d0a57f5" id="r_a9c86aa65690d40eb9a5e68f26d0a57f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c86aa65690d40eb9a5e68f26d0a57f5">CreateOrientedImageDataFromVolumeNode</a> (<a class="el" href="classvtkMRMLScalarVolumeNode.html">vtkMRMLScalarVolumeNode</a> *volumeNode, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *outputParentTransformNode=nullptr)</td></tr>
<tr class="separator:a9c86aa65690d40eb9a5e68f26d0a57f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ee716666d5fb431c476c73b1fb411f" id="r_ae1ee716666d5fb431c476c73b1fb411f"><td class="memItemLeft" align="right" valign="top">static vtkDataObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1ee716666d5fb431c476c73b1fb411f">CreateRepresentationForOneSegment</a> (<a class="el" href="classvtkSegmentation.html">vtkSegmentation</a> *segmentation, std::string segmentID, std::string representationName)</td></tr>
<tr class="separator:ae1ee716666d5fb431c476c73b1fb411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe51d7aecf7e3b80f74fecf8415b72b" id="r_a6fe51d7aecf7e3b80f74fecf8415b72b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSegment.html">vtkSegment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fe51d7aecf7e3b80f74fecf8415b72b">CreateSegmentFromLabelmapVolumeNode</a> (<a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapVolumeNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode=nullptr)</td></tr>
<tr class="separator:a6fe51d7aecf7e3b80f74fecf8415b72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260c005b56f66b43170a1cb154a40b2a" id="r_a260c005b56f66b43170a1cb154a40b2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSegment.html">vtkSegment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a260c005b56f66b43170a1cb154a40b2a">CreateSegmentFromModelNode</a> (<a class="el" href="classvtkMRMLModelNode.html">vtkMRMLModelNode</a> *modelNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode=nullptr)</td></tr>
<tr class="separator:a260c005b56f66b43170a1cb154a40b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9f8bb09df0af4e21a260a32bec1e37" id="r_a1b9f8bb09df0af4e21a260a32bec1e37"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b9f8bb09df0af4e21a260a32bec1e37">DoesLabelmapContainSingleLabel</a> (<a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapVolumeNode)</td></tr>
<tr class="separator:a1b9f8bb09df0af4e21a260a32bec1e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4cd964c6b4c616a3c79968440b0f0d" id="r_a1e4cd964c6b4c616a3c79968440b0f0d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e4cd964c6b4c616a3c79968440b0f0d">ExportAllSegmentsToLabelmapNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, int extentComputationMode=<a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a>)</td></tr>
<tr class="separator:a1e4cd964c6b4c616a3c79968440b0f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491da0b8bf0839f2117b280d64e767a" id="r_a1491da0b8bf0839f2117b280d64e767a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1491da0b8bf0839f2117b280d64e767a">ExportAllSegmentsToModels</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkIdType folderItemId)</td></tr>
<tr class="separator:a1491da0b8bf0839f2117b280d64e767a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace576efb43c16ee0478bf077b3324cff" id="r_ace576efb43c16ee0478bf077b3324cff"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace576efb43c16ee0478bf077b3324cff">ExportSegmentsBinaryLabelmapRepresentationToFiles</a> (std::string destinationFolder, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *segmentIds=nullptr, std::string extension=&quot;nrrd&quot;, bool useCompression=false, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=nullptr, int extentComputationMode=<a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a>, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode=nullptr)</td></tr>
<tr class="separator:ace576efb43c16ee0478bf077b3324cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5328985b2d98cbbc93a5b2ae7fde6b" id="r_a4b5328985b2d98cbbc93a5b2ae7fde6b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5328985b2d98cbbc93a5b2ae7fde6b">ExportSegmentsClosedSurfaceRepresentationToFiles</a> (std::string destinationFolder, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *segmentIds=nullptr, std::string fileFormat=&quot;STL&quot;, bool lps=true, double sizeScale=1.0, bool merge=false)</td></tr>
<tr class="separator:a4b5328985b2d98cbbc93a5b2ae7fde6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc8e08efd442129efefdbc5d323bcd" id="r_a42bc8e08efd442129efefdbc5d323bcd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42bc8e08efd442129efefdbc5d323bcd">ExportSegmentsToColorTableNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentID, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode, vtkIntArray *labelValues=nullptr)</td></tr>
<tr class="separator:a42bc8e08efd442129efefdbc5d323bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64462e2860272421747c3064e8e6ae88" id="r_a64462e2860272421747c3064e8e6ae88"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64462e2860272421747c3064e8e6ae88">ExportSegmentsToLabelmapNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentIDs, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=nullptr, int extentComputationMode=<a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a>, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode=nullptr)</td></tr>
<tr class="separator:a64462e2860272421747c3064e8e6ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed81025c6b9d2606576639919c41e7a" id="r_a2ed81025c6b9d2606576639919c41e7a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed81025c6b9d2606576639919c41e7a">ExportSegmentsToLabelmapNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *segmentIDs, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=nullptr, int extentComputationMode=<a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a>, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode=nullptr)</td></tr>
<tr class="separator:a2ed81025c6b9d2606576639919c41e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5484d7efda9c77f6d5664180660cc7" id="r_a6b5484d7efda9c77f6d5664180660cc7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b5484d7efda9c77f6d5664180660cc7">ExportSegmentsToModels</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentIDs, vtkIdType folderItemId)</td></tr>
<tr class="separator:a6b5484d7efda9c77f6d5664180660cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefebd46381fb8fcbea556ae1a0503f57" id="r_aefebd46381fb8fcbea556ae1a0503f57"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefebd46381fb8fcbea556ae1a0503f57">ExportSegmentsToModels</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *segmentIds, vtkIdType folderItemId)</td></tr>
<tr class="separator:aefebd46381fb8fcbea556ae1a0503f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee8fb7834b01b8f06b41ccc7938570c" id="r_a4ee8fb7834b01b8f06b41ccc7938570c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee8fb7834b01b8f06b41ccc7938570c">ExportSegmentToRepresentationNode</a> (<a class="el" href="classvtkSegment.html">vtkSegment</a> *segment, <a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *representationNode)</td></tr>
<tr class="separator:a4ee8fb7834b01b8f06b41ccc7938570c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7133c63fe3eac034ec4a682b63df5d4" id="r_aa7133c63fe3eac034ec4a682b63df5d4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7133c63fe3eac034ec4a682b63df5d4">ExportVisibleSegmentsToLabelmapNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, <a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=nullptr, int extentComputationMode=<a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a>)</td></tr>
<tr class="separator:aa7133c63fe3eac034ec4a682b63df5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8a67557a69a6a7be6cf36bc3ec3e4" id="r_adde8a67557a69a6a7be6cf36bc3ec3e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adde8a67557a69a6a7be6cf36bc3ec3e4">ExportVisibleSegmentsToModels</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkIdType folderItemId)</td></tr>
<tr class="separator:adde8a67557a69a6a7be6cf36bc3ec3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a7eb1977857535c97b11a361c96b9f" id="r_a46a7eb1977857535c97b11a361c96b9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46a7eb1977857535c97b11a361c96b9f">GenerateMergedLabelmapInReferenceGeometry</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode, vtkStringArray *segmentIDs, int extentComputationMode, <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *mergedLabelmap_Reference, vtkIntArray *labelValues=nullptr)</td></tr>
<tr class="separator:a46a7eb1977857535c97b11a361c96b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8353f9857067f31ed99739a847a5a4" id="r_aac8353f9857067f31ed99739a847a5a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac8353f9857067f31ed99739a847a5a4">GetAllLabelValues</a> (vtkIntArray *labels, vtkImageData *labelmap)</td></tr>
<tr class="memdesc:aac8353f9857067f31ed99739a847a5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns all non-empty label values in a labelmap.  <br /></td></tr>
<tr class="separator:aac8353f9857067f31ed99739a847a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43bc45ec0ec3cb430af84a26f1d276" id="r_a2a43bc45ec0ec3cb430af84a26f1d276"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a43bc45ec0ec3cb430af84a26f1d276">GetLabelValuesFromColorNode</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *colorTableNode, vtkStringArray *segmentIds, vtkIntArray *labelValues)</td></tr>
<tr class="separator:a2a43bc45ec0ec3cb430af84a26f1d276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41df5ae4322bfe95e24b3d5d682fdff6" id="r_a41df5ae4322bfe95e24b3d5d682fdff6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41df5ae4322bfe95e24b3d5d682fdff6">GetSegmentationNodeForSegment</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene, <a class="el" href="classvtkSegment.html">vtkSegment</a> *segment, std::string &amp;segmentId)</td></tr>
<tr class="separator:a41df5ae4322bfe95e24b3d5d682fdff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281663475f6370305751f2787322c050" id="r_a281663475f6370305751f2787322c050"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a281663475f6370305751f2787322c050">GetSegmentationNodeForSegmentation</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene, <a class="el" href="classvtkSegmentation.html">vtkSegmentation</a> *segmentation)</td></tr>
<tr class="separator:a281663475f6370305751f2787322c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197cc297854186f70ed348471f854118" id="r_a197cc297854186f70ed348471f854118"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a197cc297854186f70ed348471f854118">GetSegmentationNodeForSegmentSubjectHierarchyItem</a> (vtkIdType segmentShItemID, <a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene)</td></tr>
<tr class="memdesc:a197cc297854186f70ed348471f854118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for getting the segmentation node for a segmentation or segment subject hierarchy item.  <br /></td></tr>
<tr class="separator:a197cc297854186f70ed348471f854118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b403112f56975d2d494cca405fbc334" id="r_a9b403112f56975d2d494cca405fbc334"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b403112f56975d2d494cca405fbc334">GetSegmentBinaryLabelmapRepresentation</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string segmentID, <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *imageData, bool applyParentTransform=true)</td></tr>
<tr class="separator:a9b403112f56975d2d494cca405fbc334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4f599dbf71ab7789da67046cb9f459" id="r_a6d4f599dbf71ab7789da67046cb9f459"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d4f599dbf71ab7789da67046cb9f459">GetSegmentClosedSurfaceRepresentation</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string segmentID, vtkPolyData *polyData, bool applyParentTransform=true)</td></tr>
<tr class="separator:a6d4f599dbf71ab7789da67046cb9f459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdc6c029b9f1c277afcb7c4adc6188" id="r_aadbdc6c029b9f1c277afcb7c4adc6188"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSegment.html">vtkSegment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadbdc6c029b9f1c277afcb7c4adc6188">GetSegmentForSegmentSubjectHierarchyItem</a> (vtkIdType segmentShItemID, <a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene)</td></tr>
<tr class="memdesc:aadbdc6c029b9f1c277afcb7c4adc6188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for getting the segment object for a segment subject hierarchy item.  <br /></td></tr>
<tr class="separator:aadbdc6c029b9f1c277afcb7c4adc6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45f860010db76cc436be6ef5c8b1527" id="r_ae45f860010db76cc436be6ef5c8b1527"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae45f860010db76cc436be6ef5c8b1527">GetSegmentRepresentation</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string segmentID, std::string representationName, vtkDataObject *segmentRepresentation, bool applyParentTransform=true)</td></tr>
<tr class="separator:ae45f860010db76cc436be6ef5c8b1527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56abc67c0630d96994a6b8b2c3d052be" id="r_a56abc67c0630d96994a6b8b2c3d052be"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56abc67c0630d96994a6b8b2c3d052be">GetSegmentStatus</a> (<a class="el" href="classvtkSegment.html">vtkSegment</a> *segment)</td></tr>
<tr class="separator:a56abc67c0630d96994a6b8b2c3d052be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace721393493a6e01b1289fdb5786700f" id="r_ace721393493a6e01b1289fdb5786700f"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace721393493a6e01b1289fdb5786700f">GetSegmentStatusAsHumanReadableString</a> (int segmentStatus)</td></tr>
<tr class="memdesc:ace721393493a6e01b1289fdb5786700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the human readable segment status from the <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">SegmentStatus</a> enum value.  <br /></td></tr>
<tr class="separator:ace721393493a6e01b1289fdb5786700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f8f107b6061e0ecea3ca70d05ed4d" id="r_a230f8f107b6061e0ecea3ca70d05ed4d"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a230f8f107b6061e0ecea3ca70d05ed4d">GetSegmentStatusAsMachineReadableString</a> (int segmentStatus)</td></tr>
<tr class="memdesc:a230f8f107b6061e0ecea3ca70d05ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the machine readable segment status from the <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">SegmentStatus</a> enum value.  <br /></td></tr>
<tr class="separator:a230f8f107b6061e0ecea3ca70d05ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5883f4bc27f67edb65a39e8a4cdb374" id="r_ae5883f4bc27f67edb65a39e8a4cdb374"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5883f4bc27f67edb65a39e8a4cdb374">GetSegmentStatusFromMachineReadableString</a> (std::string statusString)</td></tr>
<tr class="memdesc:ae5883f4bc27f67edb65a39e8a4cdb374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enum segment status from a machine string.  <br /></td></tr>
<tr class="separator:ae5883f4bc27f67edb65a39e8a4cdb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f3e7c72cc8201ee0f3ca0837c58ab8" id="r_a15f3e7c72cc8201ee0f3ca0837c58ab8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15f3e7c72cc8201ee0f3ca0837c58ab8">GetSharedSegmentIDsInMask</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string sharedSegmentID, <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *mask, const int extent[6], std::vector&lt; std::string &gt; &amp;segmentIDs, int maskThreshold=0.0, bool includeInputSharedSegmentID=false)</td></tr>
<tr class="separator:a15f3e7c72cc8201ee0f3ca0837c58ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887b4afac0c36e7f65a78b5eb88eeafb" id="r_a887b4afac0c36e7f65a78b5eb88eeafb"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887b4afac0c36e7f65a78b5eb88eeafb">GetStatusTagName</a> ()</td></tr>
<tr class="memdesc:a887b4afac0c36e7f65a78b5eb88eeafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the status tag.  <br /></td></tr>
<tr class="separator:a887b4afac0c36e7f65a78b5eb88eeafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e382158e92e9ab04b21f55a61071b" id="r_a668e382158e92e9ab04b21f55a61071b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668e382158e92e9ab04b21f55a61071b">GetTransformBetweenRepresentationAndSegmentation</a> (<a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *representationNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkGeneralTransform *representationToSegmentationTransform)</td></tr>
<tr class="separator:a668e382158e92e9ab04b21f55a61071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785b3305ed119d1ed2c17d7be8c1f9b" id="r_af785b3305ed119d1ed2c17d7be8c1f9b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af785b3305ed119d1ed2c17d7be8c1f9b">ImportLabelmapToSegmentationNode</a> (<a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string insertBeforeSegmentId=&quot;&quot;, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:af785b3305ed119d1ed2c17d7be8c1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57db8ba2b0672308fd75957257355d" id="r_a0a57db8ba2b0672308fd75957257355d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a57db8ba2b0672308fd75957257355d">ImportLabelmapToSegmentationNode</a> (<a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *labelmapNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *updatedSegmentIDs, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:a0a57db8ba2b0672308fd75957257355d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426fde2361d358f998bb953240bad066" id="r_a426fde2361d358f998bb953240bad066"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426fde2361d358f998bb953240bad066">ImportLabelmapToSegmentationNode</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *labelmapImage, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string baseSegmentName=&quot;&quot;, std::string insertBeforeSegmentId=&quot;&quot;, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:a426fde2361d358f998bb953240bad066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec3598820d81839a76734e433dd0930" id="r_aaec3598820d81839a76734e433dd0930"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec3598820d81839a76734e433dd0930">ImportLabelmapToSegmentationNode</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *labelmapImage, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *updatedSegmentIDs, vtkGeneralTransform *labelmapToSegmentationTransform=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:aaec3598820d81839a76734e433dd0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48481bca9faff2e5022cf60104404f74" id="r_a48481bca9faff2e5022cf60104404f74"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48481bca9faff2e5022cf60104404f74">ImportModelsToSegmentationNode</a> (vtkIdType folderItemId, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string insertBeforeSegmentId=&quot;&quot;)</td></tr>
<tr class="memdesc:a48481bca9faff2e5022cf60104404f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import models in a folder into the segmentation as segments.  <br /></td></tr>
<tr class="separator:a48481bca9faff2e5022cf60104404f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cdf27aa9e1068d6b39221600086f35" id="r_a19cdf27aa9e1068d6b39221600086f35"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19cdf27aa9e1068d6b39221600086f35">ImportModelToSegmentationNode</a> (<a class="el" href="classvtkMRMLModelNode.html">vtkMRMLModelNode</a> *modelNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string insertBeforeSegmentId=&quot;&quot;)</td></tr>
<tr class="memdesc:a19cdf27aa9e1068d6b39221600086f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import model into the segmentation as a segment.  <br /></td></tr>
<tr class="separator:a19cdf27aa9e1068d6b39221600086f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f83aa527f396e58951f9fadcab16b6" id="r_a22f83aa527f396e58951f9fadcab16b6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f83aa527f396e58951f9fadcab16b6">IsEffectiveExentOutsideReferenceVolume</a> (<a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, vtkStringArray *segmentIDs=nullptr)</td></tr>
<tr class="separator:a22f83aa527f396e58951f9fadcab16b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f22298c7ccf452d7bfd569facee7059" id="r_a1f22298c7ccf452d7bfd569facee7059"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f22298c7ccf452d7bfd569facee7059">IsSegmentationExentOutsideReferenceGeometry</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *referenceGeometry, <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *segmentationGeometry)</td></tr>
<tr class="separator:a1f22298c7ccf452d7bfd569facee7059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af148fbe0cf235d162b7f19b1fbcf399e" id="r_af148fbe0cf235d162b7f19b1fbcf399e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af148fbe0cf235d162b7f19b1fbcf399e">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:af148fbe0cf235d162b7f19b1fbcf399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9401bc29c910bdc168658393a86220f" id="r_ae9401bc29c910bdc168658393a86220f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerSegmentationsModuleLogic.html">vtkSlicerSegmentationsModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9401bc29c910bdc168658393a86220f">New</a> ()</td></tr>
<tr class="separator:ae9401bc29c910bdc168658393a86220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f49ebc4b9738a932155bbc26cc9a582" id="r_a5f49ebc4b9738a932155bbc26cc9a582"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f49ebc4b9738a932155bbc26cc9a582">ReconvertAllRepresentations</a> (<a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentIDs={})</td></tr>
<tr class="separator:a5f49ebc4b9738a932155bbc26cc9a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3fd49a52c1ffac0687b6bbb90f855c" id="r_aee3fd49a52c1ffac0687b6bbb90f855c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerSegmentationsModuleLogic.html">vtkSlicerSegmentationsModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3fd49a52c1ffac0687b6bbb90f855c">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:aee3fd49a52c1ffac0687b6bbb90f855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac364fe85305b74605a7a33906783cfe4" id="r_ac364fe85305b74605a7a33906783cfe4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac364fe85305b74605a7a33906783cfe4">SetBinaryLabelmapToSegment</a> (<a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *labelmap, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, std::string segmentID, int mergeMode=<a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9a652b1321323351ef3a3ea6137f058c5f">MODE_REPLACE</a>, const int extent[6]=nullptr, bool minimumOfAllSegments=false, const std::vector&lt; std::string &gt; &amp;segmentIdsToOverwrite={})</td></tr>
<tr class="separator:ac364fe85305b74605a7a33906783cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2698bbb8503ef9dc6e281da67e670218" id="r_a2698bbb8503ef9dc6e281da67e670218"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2698bbb8503ef9dc6e281da67e670218">SetSegmentStatus</a> (<a class="el" href="classvtkSegment.html">vtkSegment</a> *segment, int status)</td></tr>
<tr class="separator:a2698bbb8503ef9dc6e281da67e670218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ae51eba75b9c5e714584ad139110613ad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ae51eba75b9c5e714584ad139110613ad">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ac55ca7008a3d25c56ef115d346c1f228"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ac55ca7008a3d25c56ef115d346c1f228">New</a> ()</td></tr>
<tr class="memdesc:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Usual vtk class functions.  <br /></td></tr>
<tr class="separator:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_a4f7462e217013233873c2f10176a58ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a4f7462e217013233873c2f10176a58ff">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a466db0b62e33aa0f80d0fe720c1a6213"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a466db0b62e33aa0f80d0fe720c1a6213">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a2d46c696959ebbe53b83ce0df02add8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2d46c696959ebbe53b83ce0df02add8b">New</a> ()</td></tr>
<tr class="separator:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a4f99d44049ff8e4c008ffed1ee7519ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4f99d44049ff8e4c008ffed1ee7519ba">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf1060c91fdad2b5a221532019e951ad" id="r_adf1060c91fdad2b5a221532019e951ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf1060c91fdad2b5a221532019e951ad">OnMRMLSceneNodeAdded</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node) override</td></tr>
<tr class="memdesc:adf1060c91fdad2b5a221532019e951ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle MRML node added events.  <br /></td></tr>
<tr class="separator:adf1060c91fdad2b5a221532019e951ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7d496f1db5e3ec61040cb6fcf6aa98" id="r_aad7d496f1db5e3ec61040cb6fcf6aa98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7d496f1db5e3ec61040cb6fcf6aa98">RegisterNodes</a> () override</td></tr>
<tr class="memdesc:aad7d496f1db5e3ec61040cb6fcf6aa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this logic class.  <br /></td></tr>
<tr class="separator:aad7d496f1db5e3ec61040cb6fcf6aa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12277242bd91283ce476938f6fa5dc" id="r_a9c12277242bd91283ce476938f6fa5dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c12277242bd91283ce476938f6fa5dc">SetMRMLSceneInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene) override</td></tr>
<tr class="separator:a9c12277242bd91283ce476938f6fa5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d4958c80b08760b5c26175cbf5c4d" id="r_aef5d4958c80b08760b5c26175cbf5c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5d4958c80b08760b5c26175cbf5c4d">vtkSlicerSegmentationsModuleLogic</a> ()</td></tr>
<tr class="separator:aef5d4958c80b08760b5c26175cbf5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6518f53aa750c19e4553e445bc357912" id="r_a6518f53aa750c19e4553e445bc357912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6518f53aa750c19e4553e445bc357912">~vtkSlicerSegmentationsModuleLogic</a> () override</td></tr>
<tr class="separator:a6518f53aa750c19e4553e445bc357912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic" id="r_a43ba2967e63f5194eba13570e79c8b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a43ba2967e63f5194eba13570e79c8b4e">vtkSlicerModuleLogic</a> ()</td></tr>
<tr class="separator:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic" id="r_a06a744b1d43e4370a99462f0b9b3f30f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a06a744b1d43e4370a99462f0b9b3f30f">~vtkSlicerModuleLogic</a> () override</td></tr>
<tr class="separator:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ab5b1ee240252dfd245fc01f8eb53e8e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab5b1ee240252dfd245fc01f8eb53e8e9">EndModify</a> (bool wasModifying)</td></tr>
<tr class="separator:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a471bd7df7caef325291e5e683e42796c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a471bd7df7caef325291e5e683e42796c">EnterMRMLLogicsCallback</a> () const</td></tr>
<tr class="separator:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aeb78c60e083bcbb907f81f136e53364e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aeb78c60e083bcbb907f81f136e53364e">EnterMRMLNodesCallback</a> () const</td></tr>
<tr class="separator:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a57c1538abccd8fc920b20d7f277f9ad3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a57c1538abccd8fc920b20d7f277f9ad3">EnterMRMLSceneCallback</a> () const</td></tr>
<tr class="separator:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5d7c3aabe26766856b040937db55141d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5d7c3aabe26766856b040937db55141d">GetDisableModifiedEvent</a> () const</td></tr>
<tr class="separator:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic" id="r_add020efdf3ea303c860c06218e7bd0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#add020efdf3ea303c860c06218e7bd0ce">GetInMRMLLogicsCallbackFlag</a> () const</td></tr>
<tr class="separator:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ad43b978b6997abd9211e873107fbb99b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ad43b978b6997abd9211e873107fbb99b">GetInMRMLNodesCallbackFlag</a> () const</td></tr>
<tr class="separator:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2c912757bd1e2fb9ed18531772d9b7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2c912757bd1e2fb9ed18531772d9b7c2">GetInMRMLSceneCallbackFlag</a> () const</td></tr>
<tr class="separator:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2024ab8d24c8b78ca68aa76ee2df6d1b"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2024ab8d24c8b78ca68aa76ee2df6d1b">GetMRMLLogicsCallbackCommand</a> ()</td></tr>
<tr class="separator:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5cd3b9222aa0f9399a0d04daa857af41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5cd3b9222aa0f9399a0d04daa857af41">GetMRMLLogicsObserverManager</a> () const</td></tr>
<tr class="separator:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a31c1e7f33880b6ad9683548fbc4ccaca"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a31c1e7f33880b6ad9683548fbc4ccaca">GetMRMLNodesCallbackCommand</a> ()</td></tr>
<tr class="separator:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a858c37b78d41171d298b797d03494411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a858c37b78d41171d298b797d03494411">GetMRMLNodesObserverManager</a> () const</td></tr>
<tr class="separator:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4d9c5b9885a2d46790cb5e31a7e013dd"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4d9c5b9885a2d46790cb5e31a7e013dd">GetMRMLSceneCallbackCommand</a> ()</td></tr>
<tr class="separator:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aefad89326706f2999ff8e6e97e221061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aefad89326706f2999ff8e6e97e221061">GetMRMLSceneObserverManager</a> () const</td></tr>
<tr class="separator:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_abcbd9db7caad7038b170c95a3398d237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abcbd9db7caad7038b170c95a3398d237">GetPendingModifiedEventCount</a> () const</td></tr>
<tr class="separator:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a040a2e3a82ac8a72ea06450c78001db1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a040a2e3a82ac8a72ea06450c78001db1">GetProcessingMRMLSceneEvent</a> () const</td></tr>
<tr class="memdesc:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the event id currently processed or 0 if any.  <br /></td></tr>
<tr class="separator:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adbdafafc00fbfca72832bf573b4e53fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adbdafafc00fbfca72832bf573b4e53fd">InvokePendingModifiedEvent</a> ()</td></tr>
<tr class="separator:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a47880d57d0f4b54a2ace71ab4b071bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a47880d57d0f4b54a2ace71ab4b071bc7">Modified</a> () override</td></tr>
<tr class="separator:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_abeec5de56ddcf3ed8206ed1fa388c364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abeec5de56ddcf3ed8206ed1fa388c364">ObserveMRMLScene</a> ()</td></tr>
<tr class="separator:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a124e968e51a99e4dc16d022b3fd37e2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a124e968e51a99e4dc16d022b3fd37e2e">OnMRMLNodeModified</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac1a782799e284bd04ea5182b1e41dc93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac1a782799e284bd04ea5182b1e41dc93">OnMRMLSceneEndBatchProcess</a> ()</td></tr>
<tr class="separator:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5f8a69a47eacec0cd95857beceb8eb34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5f8a69a47eacec0cd95857beceb8eb34">OnMRMLSceneEndClose</a> ()</td></tr>
<tr class="separator:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ae826dc18ec31156f0eae3456608eb1c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ae826dc18ec31156f0eae3456608eb1c4">OnMRMLSceneEndImport</a> ()</td></tr>
<tr class="separator:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3e1d4144d47f125c71a36c88c4289e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3e1d4144d47f125c71a36c88c4289e1">OnMRMLSceneEndRestore</a> ()</td></tr>
<tr class="separator:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac9c4356c3ad53f529f948214d5ce30f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac9c4356c3ad53f529f948214d5ce30f1">OnMRMLSceneNew</a> ()</td></tr>
<tr class="separator:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a92b1149d08ec5099a9ec61c0636f37c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a92b1149d08ec5099a9ec61c0636f37c4">OnMRMLSceneNodeRemoved</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic" id="r_afc31c1f6a54e4dabf14f1ae3fe3c47df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#afc31c1f6a54e4dabf14f1ae3fe3c47df">OnMRMLSceneStartBatchProcess</a> ()</td></tr>
<tr class="separator:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a063cceb9c914333b8fd076ff5c0f6a30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a063cceb9c914333b8fd076ff5c0f6a30">OnMRMLSceneStartClose</a> ()</td></tr>
<tr class="separator:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a048ce8ed9409c07be134bcd03ae27184"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a048ce8ed9409c07be134bcd03ae27184">OnMRMLSceneStartImport</a> ()</td></tr>
<tr class="separator:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aebe17bd4344f7c85c653d10631d6aa30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aebe17bd4344f7c85c653d10631d6aa30">OnMRMLSceneStartRestore</a> ()</td></tr>
<tr class="separator:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adac3d2b2ec84f30d78d3a6c8d8aeb828"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adac3d2b2ec84f30d78d3a6c8d8aeb828">ProcessMRMLLogicsEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a43a759874ce32846c6dffc52e5941744"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a43a759874ce32846c6dffc52e5941744">ProcessMRMLNodesEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a51fdf00ecfc18c1a1465d4bccb789ef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac028eafed3ee93b9b3741f57139132d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac028eafed3ee93b9b3741f57139132d3">SetAndObserveMRMLSceneEventsInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene, vtkIntArray *events, vtkFloatArray *priorities=nullptr)</td></tr>
<tr class="separator:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3eb7d963472fa9fd4eb83d8a6ee33ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3eb7d963472fa9fd4eb83d8a6ee33ccd">SetDisableModifiedEvent</a> (bool onOff)</td></tr>
<tr class="separator:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac4b6e57c0562f3e41a92372cca661e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac4b6e57c0562f3e41a92372cca661e65">SetInMRMLLogicsCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4836d6eb665c483236232345eccb9833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4836d6eb665c483236232345eccb9833">SetInMRMLNodesCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_acf80dc501f04df6b0d0db5095d63e042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acf80dc501f04df6b0d0db5095d63e042">SetInMRMLSceneCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3b03cb0ee8830fc953868266b62df44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3b03cb0ee8830fc953868266b62df44">SetProcessingMRMLSceneEvent</a> (int event)</td></tr>
<tr class="separator:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aca82fcc8ec42d9976a29b0acf9ba27a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aca82fcc8ec42d9976a29b0acf9ba27a4">StartModify</a> ()</td></tr>
<tr class="separator:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a966747ac1626e911a08ce8bb9ba909eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a> ()</td></tr>
<tr class="separator:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a50caeb3a373ccd53635ae2c08bc2e63e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene</a> ()</td></tr>
<tr class="separator:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3440792dbe0d54de16de57eac139bb34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3440792dbe0d54de16de57eac139bb34">vtkMRMLAbstractLogic</a> ()</td></tr>
<tr class="separator:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a417c9d98b17e68087d1263b95d4003d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a417c9d98b17e68087d1263b95d4003d8">~vtkMRMLAbstractLogic</a> () override</td></tr>
<tr class="separator:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:adbb591d894d9a96439fdbca86449f00c" id="r_adbb591d894d9a96439fdbca86449f00c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb591d894d9a96439fdbca86449f00c">ExportSegmentsClosedSurfaceRepresentationToObjFile</a> (std::string destinationFolder, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentIDs, bool lps, double sizeScale)</td></tr>
<tr class="separator:adbb591d894d9a96439fdbca86449f00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b961dac4ca5cb239a24b32e058172c8" id="r_a5b961dac4ca5cb239a24b32e058172c8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b961dac4ca5cb239a24b32e058172c8">ExportSegmentsClosedSurfaceRepresentationToStlFiles</a> (std::string destinationFolder, <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *segmentationNode, const std::vector&lt; std::string &gt; &amp;segmentIDs, bool lps, double sizeScale, bool merge)</td></tr>
<tr class="separator:a5b961dac4ca5cb239a24b32e058172c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb6959bb00eb3d58f9524bad5bb37a3" id="r_acbb6959bb00eb3d58f9524bad5bb37a3"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbb6959bb00eb3d58f9524bad5bb37a3">GetSafeFileName</a> (std::string originalName)</td></tr>
<tr class="separator:acbb6959bb00eb3d58f9524bad5bb37a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e31197d7372a940104a2a5a9a2855e" id="r_aa6e31197d7372a940104a2a5a9a2855e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e31197d7372a940104a2a5a9a2855e">OnSubjectHierarchyUIDAdded</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="separator:aa6e31197d7372a940104a2a5a9a2855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5af15efe0f8421ef6de4f3168830e3f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5af15efe0f8421ef6de4f3168830e3f7">MRMLLogicsCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLLogicCallback is a static function to relay modified events from the logics.  <br /></td></tr>
<tr class="separator:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5b796a7ccecd251cdb83874b390c4e43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5b796a7ccecd251cdb83874b390c4e43">MRMLNodesCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLNodesCallback is a static function to relay modified events from the nodes.  <br /></td></tr>
<tr class="separator:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_af4a68e64a0ca65a9efb92d717f3a7896"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af4a68e64a0ca65a9efb92d717f3a7896">MRMLSceneCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="separator:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae7247c8d5624df84b34e7f764ae9d184" id="r_ae7247c8d5624df84b34e7f764ae9d184"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7247c8d5624df84b34e7f764ae9d184">SubjectHierarchyUIDCallbackCommand</a></td></tr>
<tr class="memdesc:ae7247c8d5624df84b34e7f764ae9d184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command handling subject hierarchy UID added events.  <br /></td></tr>
<tr class="separator:ae7247c8d5624df84b34e7f764ae9d184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html#l00050">50</a> of file <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad8a2335ad36a127f119222dbc5faa644" name="ad8a2335ad36a127f119222dbc5faa644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a2335ad36a127f119222dbc5faa644">&#9670;&#160;</a></span>Superclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> <a class="el" href="#ad8a2335ad36a127f119222dbc5faa644">vtkSlicerSegmentationsModuleLogic::Superclass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html#l00055">55</a> of file <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4a6d97d1f74f8f40848a56762923acf9" name="a4a6d97d1f74f8f40848a56762923acf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6d97d1f74f8f40848a56762923acf9">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a labelmap image as binary labelmap representation into the segment defined by the segmentation node and segment ID. Source representation must be binary labelmap! Source representation changed event is disabled to prevent deletion of all other representation in all segments. The other representations in the given segment are re-converted. The extent of the segment binary labelmap is shrunk to the effective extent. Display update is triggered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mergeMode</td><td>Determines if the labelmap should replace the segment, combined with a maximum or minimum operation, or set under the mask. </td></tr>
    <tr><td class="paramname">extent</td><td>If extent is specified then only that extent of the labelmap is used. </td></tr>
  </table>
  </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a6d97d1f74f8f40848a56762923acf9a652b1321323351ef3a3ea6137f058c5f" name="a4a6d97d1f74f8f40848a56762923acf9a652b1321323351ef3a3ea6137f058c5f"></a>MODE_REPLACE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4a6d97d1f74f8f40848a56762923acf9afaaf58b6b71ee0e869d7014d509e8188" name="a4a6d97d1f74f8f40848a56762923acf9afaaf58b6b71ee0e869d7014d509e8188"></a>MODE_MERGE_MAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4a6d97d1f74f8f40848a56762923acf9a988354e808b19fa75f6c96509b95bd01" name="a4a6d97d1f74f8f40848a56762923acf9a988354e808b19fa75f6c96509b95bd01"></a>MODE_MERGE_MIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4a6d97d1f74f8f40848a56762923acf9ac0e80d26e4e128b38a4ffb04b77260c1" name="a4a6d97d1f74f8f40848a56762923acf9ac0e80d26e4e128b38a4ffb04b77260c1"></a>MODE_MERGE_MASK&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html#l00388">388</a> of file <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a>.</p>

</div>
</div>
<a id="ab170ee5954320b4f13ad31ac813e71a6" name="ab170ee5954320b4f13ad31ac813e71a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab170ee5954320b4f13ad31ac813e71a6">&#9670;&#160;</a></span>SegmentStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">vtkSlicerSegmentationsModuleLogic::SegmentStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab170ee5954320b4f13ad31ac813e71a6a8e0cbf635a519641c3aa87d9c5280c53" name="ab170ee5954320b4f13ad31ac813e71a6a8e0cbf635a519641c3aa87d9c5280c53"></a>NotStarted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab170ee5954320b4f13ad31ac813e71a6a678114ce0567fcc4d6b3c85a66148d91" name="ab170ee5954320b4f13ad31ac813e71a6a678114ce0567fcc4d6b3c85a66148d91"></a>InProgress&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab170ee5954320b4f13ad31ac813e71a6a667946e0eb1f8c38a2e046bf0f7a69ad" name="ab170ee5954320b4f13ad31ac813e71a6a667946e0eb1f8c38a2e046bf0f7a69ad"></a>Completed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab170ee5954320b4f13ad31ac813e71a6a02406a9706384067af897cfdf3322d4a" name="ab170ee5954320b4f13ad31ac813e71a6a02406a9706384067af897cfdf3322d4a"></a>Flagged&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab170ee5954320b4f13ad31ac813e71a6a7bd2a188ef7179f9c18ecb213f85e4d2" name="ab170ee5954320b4f13ad31ac813e71a6a7bd2a188ef7179f9c18ecb213f85e4d2"></a>LastStatus&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html#l00418">418</a> of file <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef5d4958c80b08760b5c26175cbf5c4d" name="aef5d4958c80b08760b5c26175cbf5c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d4958c80b08760b5c26175cbf5c4d">&#9670;&#160;</a></span>vtkSlicerSegmentationsModuleLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerSegmentationsModuleLogic::vtkSlicerSegmentationsModuleLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6518f53aa750c19e4553e445bc357912" name="a6518f53aa750c19e4553e445bc357912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6518f53aa750c19e4553e445bc357912">&#9670;&#160;</a></span>~vtkSlicerSegmentationsModuleLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerSegmentationsModuleLogic::~vtkSlicerSegmentationsModuleLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9769ef5a254100f95de963d4ee58df44" name="a9769ef5a254100f95de963d4ee58df44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9769ef5a254100f95de963d4ee58df44">&#9670;&#160;</a></span>AddColorTableNodeForSegmentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> * vtkSlicerSegmentationsModuleLogic::AddColorTableNodeForSegmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new empty color table node to the scene that can be used to store segment color and terminology information in each color entry. <a class="el" href="#a42bc8e08efd442129efefdbc5d323bcd">ExportSegmentsToColorTableNode()</a> can be used to fill the table with colors from a segmentation node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the color table node is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly created color table node (). </dd></dl>

</div>
</div>
<a id="ad2bf9a75cb8bfa1b2bf15f0765df9262" name="ad2bf9a75cb8bfa1b2bf15f0765df9262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bf9a75cb8bfa1b2bf15f0765df9262">&#9670;&#160;</a></span>ApplyParentTransformToOrientedImageData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ApplyParentTransformToOrientedImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>transformableNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>orientedImageData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>linearInterpolation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>backgroundColor</em></span>[4]<span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the parent transform of a node to an oriented image data. Useful if we want to get a labelmap representation of a segmentation in the proper geometry for processing. </p><dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ae427f532e81b9f2d1feb901c0eb93311" name="ae427f532e81b9f2d1feb901c0eb93311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae427f532e81b9f2d1feb901c0eb93311">&#9670;&#160;</a></span>ApplyParentTransformToPolyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ApplyParentTransformToPolyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>transformableNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *</td>          <td class="paramname"><span class="paramname"><em>polyData</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the parent transform of a node to a poly data. Useful if we want to get a surface or contours representation of a segmentation in the proper geometry for processing. </p><dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ad1cd04545ba3476fcf92bb9d22a0f8cd" name="ad1cd04545ba3476fcf92bb9d22a0f8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cd04545ba3476fcf92bb9d22a0f8cd">&#9670;&#160;</a></span>ClearSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ClearSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the contents of a single segment. </p>

</div>
</div>
<a id="a3b461b7d591fc8f2c45d25caf00f88a9" name="a3b461b7d591fc8f2c45d25caf00f88a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b461b7d591fc8f2c45d25caf00f88a9">&#9670;&#160;</a></span>CollapseBinaryLabelmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::CollapseBinaryLabelmaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>forceToSingleLayer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collapse all segments into fewer shared labelmap layers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Node containing the segmentation </td></tr>
    <tr><td class="paramname">forceToSingleLayer</td><td>If false, then the layers will not be overwritten by each other, if true then the layers can overwrite each other, but the result is guaranteed to have one layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the representation was created, False otherwise </dd></dl>

</div>
</div>
<a id="af646c7a49b75de5799f2c51fcce47ed2" name="af646c7a49b75de5799f2c51fcce47ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af646c7a49b75de5799f2c51fcce47ed2">&#9670;&#160;</a></span>CopyOrientedImageDataToVolumeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::CopyOrientedImageDataToVolumeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>orientedImageData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>volumeNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shallowCopy</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shiftImageDataExtentToZeroStart</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create volume MRML node from oriented image data. Display node is not created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientedImageData</td><td>Oriented image data to create volume node from </td></tr>
    <tr><td class="paramname">scalarVolumeNode</td><td>Volume to be populated with the oriented image data. </td></tr>
    <tr><td class="paramname">shallowCopy</td><td>If true then voxel array is not duplicated. </td></tr>
    <tr><td class="paramname">shiftImageDataExtentToZeroStart</td><td>Adjust image origin to make image extents start from zero. May be necessary for compatibility with some algorithms that assumes image extent start from 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ad2c3b0625100907ebdfcef9772c58027" name="ad2c3b0625100907ebdfcef9772c58027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c3b0625100907ebdfcef9772c58027">&#9670;&#160;</a></span>CreateLabelmapVolumeFromOrientedImageData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::CreateLabelmapVolumeFromOrientedImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>orientedImageData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapVolumeNode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create labelmap volume MRML node from oriented image data. Creates a display node if a display node does not exist. Shifts image extent to start from zero. Image is shallow-copied (voxel array is not duplicated). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientedImageData</td><td>Oriented image data to create labelmap from </td></tr>
    <tr><td class="paramname">labelmapVolumeNode</td><td>Labelmap volume to be populated with the oriented image data. The volume node must exist and be added to the MRML scene. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a9c86aa65690d40eb9a5e68f26d0a57f5" name="a9c86aa65690d40eb9a5e68f26d0a57f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c86aa65690d40eb9a5e68f26d0a57f5">&#9670;&#160;</a></span>CreateOrientedImageDataFromVolumeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> * vtkSlicerSegmentationsModuleLogic::CreateOrientedImageDataFromVolumeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScalarVolumeNode.html">vtkMRMLScalarVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>volumeNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *</td>          <td class="paramname"><span class="paramname"><em>outputParentTransformNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create oriented image data from a volume node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputParentTransformNode</td><td>Specifies the parent transform node where the created image data can be placed. NOTE: Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkOrientedImageData&gt;::Take </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ee716666d5fb431c476c73b1fb411f" name="ae1ee716666d5fb431c476c73b1fb411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ee716666d5fb431c476c73b1fb411f">&#9670;&#160;</a></span>CreateRepresentationForOneSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vtkDataObject * vtkSlicerSegmentationsModuleLogic::CreateRepresentationForOneSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSegmentation.html">vtkSegmentation</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>representationName</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create representation of only one segment in a segmentation. Useful if only one segment is processed, and we do not want to convert all segments to a certain segmentation to save time. NOTE: Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkDataObject&gt;::Take </p><dl class="section return"><dt>Returns</dt><dd>Representation of the specified segment if found or can be created, nullptr otherwise </dd></dl>

</div>
</div>
<a id="a6fe51d7aecf7e3b80f74fecf8415b72b" name="a6fe51d7aecf7e3b80f74fecf8415b72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe51d7aecf7e3b80f74fecf8415b72b">&#9670;&#160;</a></span>CreateSegmentFromLabelmapVolumeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSegment.html">vtkSegment</a> * vtkSlicerSegmentationsModuleLogic::CreateSegmentFromLabelmapVolumeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapVolumeNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create segment from labelmap volume MRML node. The contents are set as binary labelmap representation in the segment. Returns nullptr if labelmap contains more than one label. In that case </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#af785b3305ed119d1ed2c17d7be8c1f9b">ImportLabelmapToSegmentationNode</a> needs to be used. NOTE: Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkSegment&gt;::Take </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelmapVolumeNode</td><td>Model node containing image data that will be the binary labelmap representation in the created segment </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that will be the container of the segment. It is used to get parent transform to make sure the created segment will be located the same place the image was, considering all transforms involved. nullptr value means that this consideration is not needed. Default value is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created segment that then can be added to the segmentation if needed. Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkSegment&gt;::Take </dd></dl>

</div>
</div>
<a id="a260c005b56f66b43170a1cb154a40b2a" name="a260c005b56f66b43170a1cb154a40b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260c005b56f66b43170a1cb154a40b2a">&#9670;&#160;</a></span>CreateSegmentFromModelNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSegment.html">vtkSegment</a> * vtkSlicerSegmentationsModuleLogic::CreateSegmentFromModelNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLModelNode.html">vtkMRMLModelNode</a> *</td>          <td class="paramname"><span class="paramname"><em>modelNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create segment from model MRML node. The contents are set as closed surface model representation in the segment. NOTE: Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkSegment&gt;::Take </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modelNode</td><td>Model node containing poly data that will be the closed surface representation in the created segment </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that will be the container of the segment. It is used to get parent transform to make sure the created segment will be located the same place the model was, considering all transforms involved. nullptr value means that this consideration is not needed. Default value is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created segment that then can be added to the segmentation if needed. Need to take ownership of the created object! For example using vtkSmartPointer&lt;vtkSegment&gt;::Take </dd></dl>

</div>
</div>
<a id="a1b9f8bb09df0af4e21a260a32bec1e37" name="a1b9f8bb09df0af4e21a260a32bec1e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9f8bb09df0af4e21a260a32bec1e37">&#9670;&#160;</a></span>DoesLabelmapContainSingleLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerSegmentationsModuleLogic::DoesLabelmapContainSingleLabel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapVolumeNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function to determine if a labelmap contains a single label </p><dl class="section return"><dt>Returns</dt><dd>0 if contains no label or multiple labels, the label if it contains a single one </dd></dl>

</div>
</div>
<a id="a1e4cd964c6b4c616a3c79968440b0f0d" name="a1e4cd964c6b4c616a3c79968440b0f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4cd964c6b4c616a3c79968440b0f0d">&#9670;&#160;</a></span>ExportAllSegmentsToLabelmapNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportAllSegmentsToLabelmapNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export all segments into a multi-label labelmap volume node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">labelmapNode</td><td>Labelmap node to export the segments to </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>Labelmap extents will be determined based on this value. By default, the minimum necessary size is used. Set value to <a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d" title="Extent of common geometry is used as extent.">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a> to use reference geometry extent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1491da0b8bf0839f2117b280d64e767a" name="a1491da0b8bf0839f2117b280d64e767a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491da0b8bf0839f2117b280d64e767a">&#9670;&#160;</a></span>ExportAllSegmentsToModels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportAllSegmentsToModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>folderItemId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export all segments into a folder, a model node from each segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">folderItemId</td><td>Subject hierarchy folder item ID to export the segments to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace576efb43c16ee0478bf077b3324cff" name="ace576efb43c16ee0478bf077b3324cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace576efb43c16ee0478bf077b3324cff">&#9670;&#160;</a></span>ExportSegmentsBinaryLabelmapRepresentationToFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsBinaryLabelmapRepresentationToFiles </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>destinationFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIds</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>extension</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;nrrd&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useCompression</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export binary surface representation of multiple segments to a single output volume. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationFolder</td><td>Folder name where segments will be exported to </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that has the export color node reference. </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment ids to get values for. The order of segmentIds dictates the order of the returned label values. </td></tr>
    <tr><td class="paramname">extension</td><td>The file extension used for the output file. "nrrd" by default. </td></tr>
    <tr><td class="paramname">useCompression</td><td>If compression should be applied to the output file. </td></tr>
    <tr><td class="paramname">referenceVolumeNode</td><td>If specified, then the saved segmentation will match the geometry of referenceVolumeNode </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>If referenceVolumeNode is not specified then the saved segmentation extents will be determined based on this value. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Optional color table node used to set the exported label values for the segments. Segment names are matched based on terminology and if there is no match based on terminology then based on segment name. If a segment name is not found in the color node, then the first label value outside of the input color table range will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b5328985b2d98cbbc93a5b2ae7fde6b" name="a4b5328985b2d98cbbc93a5b2ae7fde6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5328985b2d98cbbc93a5b2ae7fde6b">&#9670;&#160;</a></span>ExportSegmentsClosedSurfaceRepresentationToFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsClosedSurfaceRepresentationToFiles </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>destinationFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIds</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>fileFormat</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;STL&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>sizeScale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>merge</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export closed surface representation of multiple segments to files. Typically used for writing 3D printable model files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">destinationFolder</td><td>Folder name where segments will be exported to </td></tr>
    <tr><td class="paramname">fileFormat</td><td>Output file format (STL or OBJ). </td></tr>
    <tr><td class="paramname">merge</td><td>Merge all models into a single mesh. Only applicable to STL format. </td></tr>
    <tr><td class="paramname">lps</td><td>Save files in LPS coordinate system. If set to false then RAS coordinate system is used. </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb591d894d9a96439fdbca86449f00c" name="adbb591d894d9a96439fdbca86449f00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb591d894d9a96439fdbca86449f00c">&#9670;&#160;</a></span>ExportSegmentsClosedSurfaceRepresentationToObjFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsClosedSurfaceRepresentationToObjFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>destinationFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>sizeScale</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b961dac4ca5cb239a24b32e058172c8" name="a5b961dac4ca5cb239a24b32e058172c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b961dac4ca5cb239a24b32e058172c8">&#9670;&#160;</a></span>ExportSegmentsClosedSurfaceRepresentationToStlFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsClosedSurfaceRepresentationToStlFiles </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>destinationFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>sizeScale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>merge</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42bc8e08efd442129efefdbc5d323bcd" name="a42bc8e08efd442129efefdbc5d323bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bc8e08efd442129efefdbc5d323bcd">&#9670;&#160;</a></span>ExportSegmentsToColorTableNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsToColorTableNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>labelValues</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export segment information into a color table node. The color table node can be created with <a class="el" href="#a9769ef5a254100f95de963d4ee58df44">AddColorTableNodeForSegmentation()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported. </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Output color table node that will store segment name, color, and terminology information. </td></tr>
    <tr><td class="paramname">labelValues</td><td>Mapping of segments to label values. Length must match the number of segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. </dd></dl>

</div>
</div>
<a id="a64462e2860272421747c3064e8e6ae88" name="a64462e2860272421747c3064e8e6ae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64462e2860272421747c3064e8e6ae88">&#9670;&#160;</a></span>ExportSegmentsToLabelmapNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsToLabelmapNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export multiple segments into a multi-label labelmap volume node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export </td></tr>
    <tr><td class="paramname">labelmapNode</td><td>Labelmap node to export the segments to </td></tr>
    <tr><td class="paramname">referenceVolumeNode</td><td>If specified, then the merged labelmap node will match the geometry of referenceVolumeNode </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>If referenceVolumeNode is not specified then labelmap extents will be determined based on this value. By default, the minimum necessary size is used. Set value to <a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d" title="Extent of common geometry is used as extent.">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a> to use reference geometry extent. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Optional color table node used to set the exported label values for the segments. Segment names are matched based on terminology and if there is no match based on terminology then based on segment name. If a segment name is not found in the color node, then the first label value outside of the input color table range will be used. Segment color, name, and terminology stored in the color table of the exported labelmap are set from the segmentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ed81025c6b9d2606576639919c41e7a" name="a2ed81025c6b9d2606576639919c41e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed81025c6b9d2606576639919c41e7a">&#9670;&#160;</a></span>ExportSegmentsToLabelmapNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsToLabelmapNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export multiple segments into a multi-label labelmap volume node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export </td></tr>
    <tr><td class="paramname">labelmapNode</td><td>Labelmap node to export the segments to </td></tr>
    <tr><td class="paramname">referenceVolumeNode</td><td>If specified, then the merged labelmap node will match the geometry of referenceVolumeNode </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>If referenceVolumeNode is not specified then labelmap extents will be determined based on this value. By default, the minimum necessary size is used. Set value to <a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d" title="Extent of common geometry is used as extent.">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a> to use reference geometry extent. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Optional color table node used to set the exported label values for the segments. Segment names are matched based on terminology and if there is no match based on terminology then based on segment name. If a segment name is not found in the color node, then the first label value outside of the input color table range will be used. Segment color, name, and terminology stored in the color table of the exported labelmap are set from the segmentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b5484d7efda9c77f6d5664180660cc7" name="a6b5484d7efda9c77f6d5664180660cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5484d7efda9c77f6d5664180660cc7">&#9670;&#160;</a></span>ExportSegmentsToModels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsToModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>folderItemId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export multiple segments into a folder, a model node from each segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export </td></tr>
    <tr><td class="paramname">folderItemId</td><td>Subject hierarchy folder item ID to export the segments to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefebd46381fb8fcbea556ae1a0503f57" name="aefebd46381fb8fcbea556ae1a0503f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefebd46381fb8fcbea556ae1a0503f57">&#9670;&#160;</a></span>ExportSegmentsToModels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentsToModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>folderItemId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export multiple segments into a folder, a model node from each segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment IDs to export </td></tr>
    <tr><td class="paramname">folderItemId</td><td>Subject hierarchy folder item ID to export the segments to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ee8fb7834b01b8f06b41ccc7938570c" name="a4ee8fb7834b01b8f06b41ccc7938570c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee8fb7834b01b8f06b41ccc7938570c">&#9670;&#160;</a></span>ExportSegmentToRepresentationNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportSegmentToRepresentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>representationNode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export segment to representation MRML node.</p><ol type="1">
<li>If representation node is a labelmap node, then the binary labelmap representation of the segment is copied</li>
<li>If representation node is a model node, then the closed surface representation is copied Otherwise return with failure. </li>
</ol>

</div>
</div>
<a id="aa7133c63fe3eac034ec4a682b63df5d4" name="aa7133c63fe3eac034ec4a682b63df5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7133c63fe3eac034ec4a682b63df5d4">&#9670;&#160;</a></span>ExportVisibleSegmentsToLabelmapNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportVisibleSegmentsToLabelmapNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a2066d78282d44f7a665e8ccb871e2808">vtkSegmentation::EXTENT_UNION_OF_EFFECTIVE_SEGMENTS</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export visible segments into a multi-label labelmap volume node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the visible segments are exported </td></tr>
    <tr><td class="paramname">labelmapNode</td><td>Labelmap node to export the segments to </td></tr>
    <tr><td class="paramname">referenceVolumeNode</td><td>If specified, then the merged labelmap node will match the geometry of referenceVolumeNode </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>If referenceVolumeNode is not specified then labelmap extents will be determined based on this value. By default, the minimum necessary size is used. Set value to <a class="el" href="classvtkSegmentation.html#ac99685783e318c659a901ef082942534a96c8583a27f940451b2e6fced89d674d" title="Extent of common geometry is used as extent.">vtkSegmentation::EXTENT_REFERENCE_GEOMETRY</a> to use reference geometry extent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adde8a67557a69a6a7be6cf36bc3ec3e4" name="adde8a67557a69a6a7be6cf36bc3ec3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde8a67557a69a6a7be6cf36bc3ec3e4">&#9670;&#160;</a></span>ExportVisibleSegmentsToModels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ExportVisibleSegmentsToModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>folderItemId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export visible segments into a folder, a model node from each segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node from which the the segments are exported </td></tr>
    <tr><td class="paramname">folderItemId</td><td>Subject hierarchy folder item ID to export the segments to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46a7eb1977857535c97b11a361c96b9f" name="a46a7eb1977857535c97b11a361c96b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a7eb1977857535c97b11a361c96b9f">&#9670;&#160;</a></span>GenerateMergedLabelmapInReferenceGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::GenerateMergedLabelmapInReferenceGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>extentComputationMode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>mergedLabelmap_Reference</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>labelValues</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a merged labelmap from the binary labelmap representations of the specified segments </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Node containing the segmentation </td></tr>
    <tr><td class="paramname">referenceVolumeNode</td><td>Determines geometry of merged labelmap if not nullptr, automatically determined otherwise </td></tr>
    <tr><td class="paramname">segmentIDs</td><td>Segment IDs to be converted. If empty, all segments will be converted. </td></tr>
    <tr><td class="paramname">extentComputationMode</td><td>If referenceVolumeNode is not specified then the saved segmentation extents will be determined based on this value. </td></tr>
    <tr><td class="paramname">mergedLabelmap_Reference</td><td>Output merged labelmap in the reference volume coordinate system </td></tr>
    <tr><td class="paramname">labelValues</td><td>Output label values from the color node. Length of the array must be the same as the number of segmentIds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac8353f9857067f31ed99739a847a5a4" name="aac8353f9857067f31ed99739a847a5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8353f9857067f31ed99739a847a5a4">&#9670;&#160;</a></span>GetAllLabelValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::GetAllLabelValues </td>
          <td>(</td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkImageData *</td>          <td class="paramname"><span class="paramname"><em>labelmap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns all non-empty label values in a labelmap. </p>

</div>
</div>
<a id="ac2d200b23f898eb8d28cdcf69801fdd8" name="ac2d200b23f898eb8d28cdcf69801fdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d200b23f898eb8d28cdcf69801fdd8">&#9670;&#160;</a></span>GetClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * vtkSlicerSegmentationsModuleLogic::GetClassName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#a39fa467c794d06e4194f8f72814b96bd">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="a2d57c8fee035e33bc6d086ff7e90bf77" name="a2d57c8fee035e33bc6d086ff7e90bf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d57c8fee035e33bc6d086ff7e90bf77">&#9670;&#160;</a></span>GetDefaultOverwriteMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerSegmentationsModuleLogic::GetDefaultOverwriteMode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get/Set default segmentation overwrite mode for masking options. </p>

</div>
</div>
<a id="a38c1464d8e10533b4bc360811c1e00d9" name="a38c1464d8e10533b4bc360811c1e00d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c1464d8e10533b4bc360811c1e00d9">&#9670;&#160;</a></span>GetDefaultSegmentationNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> * vtkSlicerSegmentationsModuleLogic::GetDefaultSegmentationNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default segmentation node. All new segmentation nodes are initialized to the content of this node. </p>

</div>
</div>
<a id="ac621bb77c860d21943a99695cdd0ec7e" name="ac621bb77c860d21943a99695cdd0ec7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac621bb77c860d21943a99695cdd0ec7e">&#9670;&#160;</a></span>GetDefaultSegmentEditorNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLSegmentEditorNode.html">vtkMRMLSegmentEditorNode</a> * vtkSlicerSegmentationsModuleLogic::GetDefaultSegmentEditorNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node that is used for initializing each new Segment Editor node. </p>

</div>
</div>
<a id="ac6ceeaa72e16d822a19b2d4a6bfea341" name="ac6ceeaa72e16d822a19b2d4a6bfea341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ceeaa72e16d822a19b2d4a6bfea341">&#9670;&#160;</a></span>GetDefaultSurfaceSmoothingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerSegmentationsModuleLogic::GetDefaultSurfaceSmoothingEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get/Set default closed surface smoothing enabled flag for new segmentation nodes. </p>

</div>
</div>
<a id="a2a43bc45ec0ec3cb430af84a26f1d276" name="a2a43bc45ec0ec3cb430af84a26f1d276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a43bc45ec0ec3cb430af84a26f1d276">&#9670;&#160;</a></span>GetLabelValuesFromColorNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::GetLabelValuesFromColorNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>labelValues</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the label values for the current segment from the color node reference. Label values found by matching terminology code. If there is no match based on terminology then matching of the segment name to a color name will be attempted. If there is still no match then a new label value generated for the segment. The label values are all outside of the range of the input color table to avoid any ambiguities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that has the export color node reference. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Input color table used to get the label values for the segments. </td></tr>
    <tr><td class="paramname">segmentIds</td><td>List of segment ids to get values for. The order of segmentIds dictates the order of the returned label values. </td></tr>
    <tr><td class="paramname">labelValues</td><td>Output label values from the color node. Length of the array will be the same as the number of segmentIds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbb6959bb00eb3d58f9524bad5bb37a3" name="acbb6959bb00eb3d58f9524bad5bb37a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb6959bb00eb3d58f9524bad5bb37a3">&#9670;&#160;</a></span>GetSafeFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerSegmentationsModuleLogic::GetSafeFileName </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>originalName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a safe file name from a given string. The method is in this logic so that it does not cause confusion throughout Slicer (there is an implementation already in qSlicerSaveDataDialogPrivate::nodeFileInfo and it would be good to keep a central one) </p>

</div>
</div>
<a id="a41df5ae4322bfe95e24b3d5d682fdff6" name="a41df5ae4322bfe95e24b3d5d682fdff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41df5ae4322bfe95e24b3d5d682fdff6">&#9670;&#160;</a></span>GetSegmentationNodeForSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> * vtkSlicerSegmentationsModuleLogic::GetSegmentationNodeForSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentId</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get segmentation node containing a given segment. As segments are out-of-MRML VTK objects, there is no direct link from it to its parent node, so must be found from the MRML scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene</td><td>MRML scene </td></tr>
    <tr><td class="paramname">segment</td><td>Segment to find </td></tr>
    <tr><td class="paramname">segmentId</td><td>Output argument for the ID of the found segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Segmentation node containing the given segment if any, nullptr otherwise </dd></dl>

</div>
</div>
<a id="a281663475f6370305751f2787322c050" name="a281663475f6370305751f2787322c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281663475f6370305751f2787322c050">&#9670;&#160;</a></span>GetSegmentationNodeForSegmentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> * vtkSlicerSegmentationsModuleLogic::GetSegmentationNodeForSegmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSegmentation.html">vtkSegmentation</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get segmentation node containing a segmentation object. As segmentation objects are out-of-MRML VTK objects, there is no direct link from it to its parent node, so must be found from the MRML scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene</td><td>MRML scene </td></tr>
    <tr><td class="paramname">segmentation</td><td>Segmentation to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Segmentation node containing the given segmentation if any, nullptr otherwise </dd></dl>

</div>
</div>
<a id="a197cc297854186f70ed348471f854118" name="a197cc297854186f70ed348471f854118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197cc297854186f70ed348471f854118">&#9670;&#160;</a></span>GetSegmentationNodeForSegmentSubjectHierarchyItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> * vtkSlicerSegmentationsModuleLogic::GetSegmentationNodeForSegmentSubjectHierarchyItem </td>
          <td>(</td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>segmentShItemID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for getting the segmentation node for a segmentation or segment subject hierarchy item. </p>

</div>
</div>
<a id="a9b403112f56975d2d494cca405fbc334" name="a9b403112f56975d2d494cca405fbc334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b403112f56975d2d494cca405fbc334">&#9670;&#160;</a></span>GetSegmentBinaryLabelmapRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::GetSegmentBinaryLabelmapRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>imageData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>applyParentTransform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to get binary labelmap representation of a segment in a segmentation. Uses </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae45f860010db76cc436be6ef5c8b1527">GetSegmentRepresentation</a> A duplicate of the oriented image data is copied into the argument image data, with the segmentation's parent transform applied if requested (on by default). The oriented image data can be used directly for processing, or to create a labelmap volume using </dd>
<dd>
<a class="el" href="#ad2c3b0625100907ebdfcef9772c58027">CreateLabelmapVolumeFromOrientedImageData</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Input segmentation node containing the segment to extract </td></tr>
    <tr><td class="paramname">segmentID</td><td>Segment identifier of the segment to extract </td></tr>
    <tr><td class="paramname">imageData</td><td>Output oriented image data into which the segment binary labelmap is copied </td></tr>
    <tr><td class="paramname">applyParentTransform</td><td>Flag determining whether to apply parent transform of the segmentation node. If on, then the oriented image data is in RAS, otherwise in the segmentation node's coordinate frame. On by default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a6d4f599dbf71ab7789da67046cb9f459" name="a6d4f599dbf71ab7789da67046cb9f459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4f599dbf71ab7789da67046cb9f459">&#9670;&#160;</a></span>GetSegmentClosedSurfaceRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::GetSegmentClosedSurfaceRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *</td>          <td class="paramname"><span class="paramname"><em>polyData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>applyParentTransform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to get closed surface representation of a segment in a segmentation. Uses </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae45f860010db76cc436be6ef5c8b1527">GetSegmentRepresentation</a> A duplicate of the closed surface data is copied into the argument image data, with the segmentation's parent transform applied if requested (on by default). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Input segmentation node containing the segment to extract </td></tr>
    <tr><td class="paramname">segmentID</td><td>Segment identifier of the segment to extract </td></tr>
    <tr><td class="paramname">polyData</td><td>Output polydata into which the segment polydata is copied </td></tr>
    <tr><td class="paramname">applyParentTransform</td><td>Flag determining whether to apply parent transform of the segmentation node. If on, then the oriented image data is in RAS, otherwise in the segmentation node's coordinate frame. On by default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="aadbdc6c029b9f1c277afcb7c4adc6188" name="aadbdc6c029b9f1c277afcb7c4adc6188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbdc6c029b9f1c277afcb7c4adc6188">&#9670;&#160;</a></span>GetSegmentForSegmentSubjectHierarchyItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSegment.html">vtkSegment</a> * vtkSlicerSegmentationsModuleLogic::GetSegmentForSegmentSubjectHierarchyItem </td>
          <td>(</td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>segmentShItemID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for getting the segment object for a segment subject hierarchy item. </p>

</div>
</div>
<a id="ae45f860010db76cc436be6ef5c8b1527" name="ae45f860010db76cc436be6ef5c8b1527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45f860010db76cc436be6ef5c8b1527">&#9670;&#160;</a></span>GetSegmentRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::GetSegmentRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>representationName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkDataObject *</td>          <td class="paramname"><span class="paramname"><em>segmentRepresentation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>applyParentTransform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to get a specified representation of a segment in a segmentation. A duplicate of the representation data object is copied into the argument output object, with the segmentation's parent transform applied if requested (on by default). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Input segmentation node containing the segment to extract </td></tr>
    <tr><td class="paramname">segmentID</td><td>Segment identifier of the segment to extract </td></tr>
    <tr><td class="paramname">representationName</td><td>Name of the requested representation </td></tr>
    <tr><td class="paramname">segmentRepresentation</td><td>Output representation data object into which the given representation in the segment is copied </td></tr>
    <tr><td class="paramname">applyParentTransform</td><td>Flag determining whether to apply parent transform of the segmentation node. On by default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a56abc67c0630d96994a6b8b2c3d052be" name="a56abc67c0630d96994a6b8b2c3d052be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56abc67c0630d96994a6b8b2c3d052be">&#9670;&#160;</a></span>GetSegmentStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerSegmentationsModuleLogic::GetSegmentStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the status tag for the given segment. If status tag is not specified then <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a8e0cbf635a519641c3aa87d9c5280c53">vtkSlicerSegmentationsModuleLogic::NotStarted</a> is returned. </p>

</div>
</div>
<a id="ace721393493a6e01b1289fdb5786700f" name="ace721393493a6e01b1289fdb5786700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace721393493a6e01b1289fdb5786700f">&#9670;&#160;</a></span>GetSegmentStatusAsHumanReadableString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerSegmentationsModuleLogic::GetSegmentStatusAsHumanReadableString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segmentStatus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the human readable segment status from the <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">SegmentStatus</a> enum value. </p>

</div>
</div>
<a id="a230f8f107b6061e0ecea3ca70d05ed4d" name="a230f8f107b6061e0ecea3ca70d05ed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230f8f107b6061e0ecea3ca70d05ed4d">&#9670;&#160;</a></span>GetSegmentStatusAsMachineReadableString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerSegmentationsModuleLogic::GetSegmentStatusAsMachineReadableString </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>segmentStatus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the machine readable segment status from the <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6">SegmentStatus</a> enum value. </p>

</div>
</div>
<a id="ae5883f4bc27f67edb65a39e8a4cdb374" name="ae5883f4bc27f67edb65a39e8a4cdb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5883f4bc27f67edb65a39e8a4cdb374">&#9670;&#160;</a></span>GetSegmentStatusFromMachineReadableString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerSegmentationsModuleLogic::GetSegmentStatusFromMachineReadableString </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>statusString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the enum segment status from a machine string. </p>

</div>
</div>
<a id="a15f3e7c72cc8201ee0f3ca0837c58ab8" name="a15f3e7c72cc8201ee0f3ca0837c58ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f3e7c72cc8201ee0f3ca0837c58ab8">&#9670;&#160;</a></span>GetSharedSegmentIDsInMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::GetSharedSegmentIDsInMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>sharedSegmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maskThreshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeInputSharedSegmentID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the list of segment IDs in the same shared labelmap that are contained within the mask </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Node containing the segmentation </td></tr>
    <tr><td class="paramname">sharedSegmentID</td><td>Segment ID of the segment that contains the shared labelmap to be checked </td></tr>
    <tr><td class="paramname">mask</td><td>Mask labelmap </td></tr>
    <tr><td class="paramname">segmentIDs</td><td>Output list of segment IDs under the mask </td></tr>
    <tr><td class="paramname">includeInputSharedSegmentID</td><td>If false, sharedSegmentID will not be added to the list of output segment IDs even if it is within the mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a887b4afac0c36e7f65a78b5eb88eeafb" name="a887b4afac0c36e7f65a78b5eb88eeafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887b4afac0c36e7f65a78b5eb88eeafb">&#9670;&#160;</a></span>GetStatusTagName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerSegmentationsModuleLogic::GetStatusTagName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the status tag. </p>

</div>
</div>
<a id="a668e382158e92e9ab04b21f55a61071b" name="a668e382158e92e9ab04b21f55a61071b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e382158e92e9ab04b21f55a61071b">&#9670;&#160;</a></span>GetTransformBetweenRepresentationAndSegmentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::GetTransformBetweenRepresentationAndSegmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>representationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkGeneralTransform *</td>          <td class="paramname"><span class="paramname"><em>representationToSegmentationTransform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get transform between a representation node (e.g. labelmap or model) and a segmentation node. Useful if we want to add a representation to a segment, and we want to make sure that the segment will be located the same place the representation node was. The output transform is the representation node's parent transform concatenated with the inverse of the segmentation's parent transform. It needs to be applied on the representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">representationNode</td><td>Transformable node which contains the representation we want to add to the segment </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that will contain the segment to which the representation is added. It is the representation node's parent transform concatenated with the inverse of the segmentation's parent transform. </td></tr>
    <tr><td class="paramname">representationToSegmentationTransform</td><td>General transform between the representation node and the segmentation node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="af785b3305ed119d1ed2c17d7be8c1f9b" name="af785b3305ed119d1ed2c17d7be8c1f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af785b3305ed119d1ed2c17d7be8c1f9b">&#9670;&#160;</a></span>ImportLabelmapToSegmentationNode() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportLabelmapToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>insertBeforeSegmentId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all labels from a labelmap node to a segmentation node, each label to a separate segment. The colors of the new segments are set from the color table corresponding to the labelmap volume. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertBeforeSegmentId</td><td>New segments will be inserted before this segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a57db8ba2b0672308fd75957257355d" name="a0a57db8ba2b0672308fd75957257355d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a57db8ba2b0672308fd75957257355d">&#9670;&#160;</a></span>ImportLabelmapToSegmentationNode() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportLabelmapToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>updatedSegmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update segmentation from segments in a labelmap node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updatedSegmentIDs</td><td>Defines how label values 1..N are mapped to segment IDs (0..N-1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426fde2361d358f998bb953240bad066" name="a426fde2361d358f998bb953240bad066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426fde2361d358f998bb953240bad066">&#9670;&#160;</a></span>ImportLabelmapToSegmentationNode() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportLabelmapToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>baseSegmentName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>insertBeforeSegmentId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all labels from a labelmap image to a segmentation node, each label to a separate segment The colors of the new segments are randomly generated, unless terminology context is specified, in which case the terminology entries are attempted to be mapped to the imported labels LabelmapImage is defined in the segmentation node's coordinate system (parent transform of the segmentation node is not used during import). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseSegmentName</td><td>Prefix for the names of the new segments. Empty by default, in which case the prefix will be "Label" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaec3598820d81839a76734e433dd0930" name="aaec3598820d81839a76734e433dd0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec3598820d81839a76734e433dd0930">&#9670;&#160;</a></span>ImportLabelmapToSegmentationNode() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportLabelmapToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>updatedSegmentIDs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkGeneralTransform *</td>          <td class="paramname"><span class="paramname"><em>labelmapToSegmentationTransform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update segmentation from segments in a labelmap node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updatedSegmentIDs</td><td>Defines how label values 1..N are mapped to segment IDs (0..N-1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9309513d633a096fe9f9299b14faf0c9" name="a9309513d633a096fe9f9299b14faf0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9309513d633a096fe9f9299b14faf0c9">&#9670;&#160;</a></span>ImportLabelmapToSegmentationNodeWithTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerSegmentationsModuleLogic::ImportLabelmapToSegmentationNodeWithTerminology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>insertBeforeSegmentId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import all labels from a labelmap node to a segmentation node, each label to a separate segment. Terminology and color is set to the segments based on the color table corresponding to the labelmap volume node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminologyContextName</td><td>Terminology context the entries of which are mapped to the labels imported from the labelmap node </td></tr>
    <tr><td class="paramname">insertBeforeSegmentId</td><td>New segments will be inserted before this segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48481bca9faff2e5022cf60104404f74" name="a48481bca9faff2e5022cf60104404f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48481bca9faff2e5022cf60104404f74">&#9670;&#160;</a></span>ImportModelsToSegmentationNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportModelsToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>folderItemId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>insertBeforeSegmentId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import models in a folder into the segmentation as segments. </p>

</div>
</div>
<a id="a19cdf27aa9e1068d6b39221600086f35" name="a19cdf27aa9e1068d6b39221600086f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cdf27aa9e1068d6b39221600086f35">&#9670;&#160;</a></span>ImportModelToSegmentationNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ImportModelToSegmentationNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLModelNode.html">vtkMRMLModelNode</a> *</td>          <td class="paramname"><span class="paramname"><em>modelNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>insertBeforeSegmentId</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Import model into the segmentation as a segment. </p>

</div>
</div>
<a id="a6a4528a1936927b8dc6dcce4ecba1170" name="a6a4528a1936927b8dc6dcce4ecba1170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4528a1936927b8dc6dcce4ecba1170">&#9670;&#160;</a></span>IsA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vtkSlicerSegmentationsModuleLogic::IsA </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#afe98b30ad85954605c2b4079d5823003">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="a22f83aa527f396e58951f9fadcab16b6" name="a22f83aa527f396e58951f9fadcab16b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f83aa527f396e58951f9fadcab16b6">&#9670;&#160;</a></span>IsEffectiveExentOutsideReferenceVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::IsEffectiveExentOutsideReferenceVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceVolumeNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine if any part of the effective extent is outside of the reference volume geometry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceVolumeNode</td><td>Volume node that contains the reference geometry. </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Segmentation node that contains the effective extent to be checked. </td></tr>
    <tr><td class="paramname">segmentIDs</td><td>List of segment IDs that will be used to calculate the effective extent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the effective segmentation extent is outside of the reference volume, False otherwise. </dd></dl>

</div>
</div>
<a id="a1f22298c7ccf452d7bfd569facee7059" name="a1f22298c7ccf452d7bfd569facee7059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f22298c7ccf452d7bfd569facee7059">&#9670;&#160;</a></span>IsSegmentationExentOutsideReferenceGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::IsSegmentationExentOutsideReferenceGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>referenceGeometry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationGeometry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine if any part of the segmentation extent is outside of the reference geometry </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceVolumeNode</td><td>Image that contains the reference geometry. </td></tr>
    <tr><td class="paramname">segmentationNode</td><td>Image that contains the segmentation geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the segmentation extent is outside of the reference volume, False otherwise. </dd></dl>

</div>
</div>
<a id="af148fbe0cf235d162b7f19b1fbcf399e" name="af148fbe0cf235d162b7f19b1fbcf399e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af148fbe0cf235d162b7f19b1fbcf399e">&#9670;&#160;</a></span>IsTypeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerSegmentationsModuleLogic::IsTypeOf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61b85e29f429607907d1f9a3d94460e8" name="a61b85e29f429607907d1f9a3d94460e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b85e29f429607907d1f9a3d94460e8">&#9670;&#160;</a></span>LoadSegmentationFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> * vtkSlicerSegmentationsModuleLogic::LoadSegmentationFromFile </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>autoOpacities</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nodeName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorTableNode.html">vtkMRMLColorTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorTableNode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load segmentation from file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path and name of file containing segmentation (nrrd, vtm, etc.) </td></tr>
    <tr><td class="paramname">autoOpacities</td><td>Optional flag determining whether segment opacities are calculated automatically based on containment. True by default. </td></tr>
    <tr><td class="paramname">nodeName</td><td>Optional string to use for the segmentation node name. </td></tr>
    <tr><td class="paramname">colorTableNode</td><td>Optional color node to set name, color, and terminology for segments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Loaded segmentation node </dd></dl>

</div>
</div>
<a id="ae9401bc29c910bdc168658393a86220f" name="ae9401bc29c910bdc168658393a86220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9401bc29c910bdc168658393a86220f">&#9670;&#160;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerSegmentationsModuleLogic.html">vtkSlicerSegmentationsModuleLogic</a> * vtkSlicerSegmentationsModuleLogic::New </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf1060c91fdad2b5a221532019e951ad" name="adf1060c91fdad2b5a221532019e951ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1060c91fdad2b5a221532019e951ad">&#9670;&#160;</a></span>OnMRMLSceneNodeAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::OnMRMLSceneNodeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle MRML node added events. </p>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#ac0102310f18a3880f00e93b8e37210c9">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="aa6e31197d7372a940104a2a5a9a2855e" name="aa6e31197d7372a940104a2a5a9a2855e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e31197d7372a940104a2a5a9a2855e">&#9670;&#160;</a></span>OnSubjectHierarchyUIDAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::OnSubjectHierarchyUIDAdded </td>
          <td>(</td>
          <td class="paramtype">vtkObject *</td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>eid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>clientData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callData</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function observing UID added events for subject hierarchy nodes. In case the newly added UID is a volume node referenced from a segmentation, its geometry will be set as image geometry conversion parameter. The "other order", i.e. when the volume is loaded first and the segmentation second, should be handled at loading time of the segmentation (because then we already know about the volume) </p>

</div>
</div>
<a id="ace432e6b1baf02d1b594c5e925318dc5" name="ace432e6b1baf02d1b594c5e925318dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace432e6b1baf02d1b594c5e925318dc5">&#9670;&#160;</a></span>PrintSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::PrintSelf </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIndent</td>          <td class="paramname"><span class="paramname"><em>indent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f49ebc4b9738a932155bbc26cc9a582" name="a5f49ebc4b9738a932155bbc26cc9a582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f49ebc4b9738a932155bbc26cc9a582">&#9670;&#160;</a></span>ReconvertAllRepresentations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::ReconvertAllRepresentations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIDs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reconvert all representations in the segmentation from the source representation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentationNode</td><td>Node containing the segmentation </td></tr>
    <tr><td class="paramname">sharedSegmentID</td><td>Segment IDs to be converted. If empty, all segments will be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the representation was created, False otherwise </dd></dl>

</div>
</div>
<a id="aad7d496f1db5e3ec61040cb6fcf6aa98" name="aad7d496f1db5e3ec61040cb6fcf6aa98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7d496f1db5e3ec61040cb6fcf6aa98">&#9670;&#160;</a></span>RegisterNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::RegisterNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this logic class. </p>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#acfa7f65f53d5fbe6d056e7cf32a23058">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="aee3fd49a52c1ffac0687b6bbb90f855c" name="aee3fd49a52c1ffac0687b6bbb90f855c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3fd49a52c1ffac0687b6bbb90f855c">&#9670;&#160;</a></span>SafeDownCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerSegmentationsModuleLogic.html">vtkSlicerSegmentationsModuleLogic</a> * vtkSlicerSegmentationsModuleLogic::SafeDownCast </td>
          <td>(</td>
          <td class="paramtype">vtkObject *</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac364fe85305b74605a7a33906783cfe4" name="ac364fe85305b74605a7a33906783cfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac364fe85305b74605a7a33906783cfe4">&#9670;&#160;</a></span>SetBinaryLabelmapToSegment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerSegmentationsModuleLogic::SetBinaryLabelmapToSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkOrientedImageData.html">vtkOrientedImageData</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>segmentID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mergeMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a4a6d97d1f74f8f40848a56762923acf9a652b1321323351ef3a3ea6137f058c5f">MODE_REPLACE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>[6]<span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>minimumOfAllSegments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segmentIdsToOverwrite</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac75765e3d51cd66ba921d315803a6768" name="ac75765e3d51cd66ba921d315803a6768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75765e3d51cd66ba921d315803a6768">&#9670;&#160;</a></span>SetDefaultOverwriteMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::SetDefaultOverwriteMode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b484043245ad8ada5ee2f96b9d4b1dd" name="a0b484043245ad8ada5ee2f96b9d4b1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b484043245ad8ada5ee2f96b9d4b1dd">&#9670;&#160;</a></span>SetDefaultSurfaceSmoothingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::SetDefaultSurfaceSmoothingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c12277242bd91283ce476938f6fa5dc" name="a9c12277242bd91283ce476938f6fa5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12277242bd91283ce476938f6fa5dc">&#9670;&#160;</a></span>SetMRMLSceneInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerSegmentationsModuleLogic::SetMRMLSceneInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>newScene</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called each time a new scene is set. Can be reimplemented in derived classes. Doesn't observe the scene by default, that means that <a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene()</a> won't be called by default when a scene is imported, closed or restored, only when a new scene is set. </p><dl class="section see"><dt>See also</dt><dd>SetAndObserveMRMLSceneInternal() <a class="el" href="classvtkMRMLAbstractLogic.html#ac028eafed3ee93b9b3741f57139132d3">SetAndObserveMRMLSceneEventsInternal()</a> </dd>
<dd>
<a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a8a1dc1c9192488743cbb0289d3f03600">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a2698bbb8503ef9dc6e281da67e670218" name="a2698bbb8503ef9dc6e281da67e670218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2698bbb8503ef9dc6e281da67e670218">&#9670;&#160;</a></span>SetSegmentStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerSegmentationsModuleLogic::SetSegmentStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the status tag for the given segment. If setting of <a class="el" href="#ab170ee5954320b4f13ad31ac813e71a6a8e0cbf635a519641c3aa87d9c5280c53">vtkSlicerSegmentationsModuleLogic::NotStarted</a> is requested and the status tag does not exist or it is empty then the status tag is not modified. </p>

</div>
</div>
<a id="adb5c4726cfd134518285aee4f701a965" name="adb5c4726cfd134518285aee4f701a965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5c4726cfd134518285aee4f701a965">&#9670;&#160;</a></span>SetTerminologyToSegmentationFromLabelmapNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerSegmentationsModuleLogic::SetTerminologyToSegmentationFromLabelmapNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSegmentationNode.html">vtkMRMLSegmentationNode</a> *</td>          <td class="paramname"><span class="paramname"><em>segmentationNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLLabelMapVolumeNode.html">vtkMRMLLabelMapVolumeNode</a> *</td>          <td class="paramname"><span class="paramname"><em>labelmapNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyContextName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign terminology to segments in a segmentation node based on the labels of a labelmap node. Match is made based on the 3dSlicerLabel terminology type attribute. If the terminology context does not contain that attribute, match cannot be made. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminologyContextName</td><td>Terminology context the entries of which are mapped to the labels imported from the labelmap node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae7247c8d5624df84b34e7f764ae9d184" name="ae7247c8d5624df84b34e7f764ae9d184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7247c8d5624df84b34e7f764ae9d184">&#9670;&#160;</a></span>SubjectHierarchyUIDCallbackCommand</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkCallbackCommand* vtkSlicerSegmentationsModuleLogic::SubjectHierarchyUIDCallbackCommand</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Command handling subject hierarchy UID added events. </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html#l00523">523</a> of file <a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Modules/Loadable/Segmentations/Logic/<a class="el" href="vtkSlicerSegmentationsModuleLogic_8h_source.html">vtkSlicerSegmentationsModuleLogic.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 26 2025 14:15:49 for Slicer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
