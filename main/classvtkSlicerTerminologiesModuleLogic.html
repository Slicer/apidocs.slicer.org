<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer: vtkSlicerTerminologiesModuleLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="3DSlicer-DesktopIcon.png"/></td>
  <td id="projectalign">
   <div id="projectname">Slicer<span id="projectnumber">&#160;5.9</span>
   </div>
   <div id="projectbrief">Slicer is a multi-platform, free and open source software package for visualization and medical image computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classvtkSlicerTerminologiesModuleLogic-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">vtkSlicerTerminologiesModuleLogic Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">Modules/Loadable/Terminologies/Logic/vtkSlicerTerminologiesModuleLogic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vtkSlicerTerminologiesModuleLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerTerminologiesModuleLogic__inherit__graph.png" border="0" usemap="#avtkSlicerTerminologiesModuleLogic_inherit__map" alt="Inheritance graph"/></div>
<map name="avtkSlicerTerminologiesModuleLogic_inherit__map" id="avtkSlicerTerminologiesModuleLogic_inherit__map">
<area shape="rect" title=" " alt="" coords="5,225,224,265"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="34,152,195,177"/>
<area shape="poly" title=" " alt="" coords="117,191,117,225,112,225,112,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="29,79,201,104"/>
<area shape="poly" title=" " alt="" coords="117,118,117,152,112,152,112,118"/>
<area shape="rect" title=" " alt="" coords="72,5,157,31"/>
<area shape="poly" title=" " alt="" coords="117,44,117,79,112,79,112,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vtkSlicerTerminologiesModuleLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerTerminologiesModuleLogic__coll__graph.png" border="0" usemap="#avtkSlicerTerminologiesModuleLogic_coll__map" alt="Collaboration graph"/></div>
<map name="avtkSlicerTerminologiesModuleLogic_coll__map" id="avtkSlicerTerminologiesModuleLogic_coll__map">
<area shape="rect" title=" " alt="" coords="5,225,224,265"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="34,152,195,177"/>
<area shape="poly" title=" " alt="" coords="117,191,117,225,112,225,112,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="29,79,201,104"/>
<area shape="poly" title=" " alt="" coords="117,118,117,152,112,152,112,118"/>
<area shape="rect" title=" " alt="" coords="72,5,157,31"/>
<area shape="poly" title=" " alt="" coords="117,44,117,79,112,79,112,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information needed to uniquely identify a terminology code.  <a href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84a7563192cb1c13763cfbfb0dd12904" id="r_a84a7563192cb1c13763cfbfb0dd12904"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a7563192cb1c13763cfbfb0dd12904">Superclass</a></td></tr>
<tr class="separator:a84a7563192cb1c13763cfbfb0dd12904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic" id="r_a85b117de65a91398ccf70ccfc2edc275"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a85b117de65a91398ccf70ccfc2edc275">Superclass</a></td></tr>
<tr class="separator:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic" id="r_ab2fef06324d2444212855c6ed44e3ead"><td class="memItemLeft" align="right" valign="top">typedef vtkObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab2fef06324d2444212855c6ed44e3ead">Superclass</a></td></tr>
<tr class="separator:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic" id="r_aaa2c5b4f57066c706fd86982299adbde"><td class="memItemLeft" align="right" valign="top">typedef void(vtkMRMLAbstractLogic::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aaa2c5b4f57066c706fd86982299adbde">TaskFunctionPointer</a>) (void *clientdata)</td></tr>
<tr class="separator:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a598fd8b2e83f32d6fe67904a0769beb7" id="r_a598fd8b2e83f32d6fe67904a0769beb7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a598fd8b2e83f32d6fe67904a0769beb7">FindAnatomicContextNames</a> (std::string anatomicRegionCodingSchemeDesignator, std::string anatomicRegionCodeValue, std::string anatomicRegionModifierCodingSchemeDesignator, std::string anatomicRegionModifierCodeValue, std::vector&lt; std::string &gt; preferredAnatomicContextNames, vtkCollection *foundEntries=nullptr)</td></tr>
<tr class="separator:a598fd8b2e83f32d6fe67904a0769beb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f679f779b105c41b8226d0d1d83545" id="r_a73f679f779b105c41b8226d0d1d83545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73f679f779b105c41b8226d0d1d83545">FindCategoriesInTerminology</a> (std::string terminologyName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;categories, std::string search)</td></tr>
<tr class="separator:a73f679f779b105c41b8226d0d1d83545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bfb2bb0da06445cb0ef0a207e8805f" id="r_ae2bfb2bb0da06445cb0ef0a207e8805f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2bfb2bb0da06445cb0ef0a207e8805f">FindColorNodes</a> (std::string categoryCodingSchemeDesignator, std::string categoryCodeValue, std::string typeCodingSchemeDesignator, std::string typeCodeValue, std::string typeModifierCodingSchemeDesignator, std::string typeModifierCodeValue, std::string regionCodingSchemeDesignator, std::string regionCodeValue, std::string regionModifierCodingSchemeDesignator, std::string regionModifierCodeValue, std::vector&lt; std::string &gt; preferredColorNodeNames, vtkIntArray *foundColorIndices=nullptr, vtkIntArray *foundPreferredColorNodeIndices=nullptr)</td></tr>
<tr class="separator:ae2bfb2bb0da06445cb0ef0a207e8805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37252c3a55f7220be2a55d8cd7363ad5" id="r_a37252c3a55f7220be2a55d8cd7363ad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37252c3a55f7220be2a55d8cd7363ad5">FindFirstColorNodeOrTerminology</a> (std::string categoryCodingSchemeDesignator, std::string categoryCodeValue, std::string typeCodingSchemeDesignator, std::string typeCodeValue, std::string typeModifierCodingSchemeDesignator, std::string typeModifierCodeValue, std::string regionCodingSchemeDesignator, std::string regionCodeValue, std::string regionModifierCodingSchemeDesignator, std::string regionModifierCodeValue, std::vector&lt; std::string &gt; preferredTerminologyNames, std::string &amp;foundTerminologyName, std::string &amp;foundColorNodeID, int &amp;foundColorIndex)</td></tr>
<tr class="separator:a37252c3a55f7220be2a55d8cd7363ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a486267a08a5ca37a60b37897fa236b" id="r_a2a486267a08a5ca37a60b37897fa236b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a486267a08a5ca37a60b37897fa236b">FindFirstColorNodeOrTerminology</a> (<a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry, std::vector&lt; std::string &gt; preferredTerminologyNames, std::string &amp;foundTerminologyName, std::string &amp;foundColorNodeID, int &amp;foundColorIndex)</td></tr>
<tr class="separator:a2a486267a08a5ca37a60b37897fa236b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d1028fd8cefb80e3864592efdb80a2" id="r_a26d1028fd8cefb80e3864592efdb80a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26d1028fd8cefb80e3864592efdb80a2">FindRegionContextNames</a> (std::string regionCodingSchemeDesignator, std::string regionCodeValue, std::string regionModifierCodingSchemeDesignator, std::string regionModifierCodeValue, std::vector&lt; std::string &gt; preferredRegionContextNames, vtkCollection *foundEntries=nullptr)</td></tr>
<tr class="separator:a26d1028fd8cefb80e3864592efdb80a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44750d7a3b231ca0fa876187c986cc35" id="r_a44750d7a3b231ca0fa876187c986cc35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44750d7a3b231ca0fa876187c986cc35">FindRegionsInAnatomicContext</a> (std::string anatomicContextName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regions, std::string search)</td></tr>
<tr class="separator:a44750d7a3b231ca0fa876187c986cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60522bb76d93a25ac937c71eb1eb4c3" id="r_aa60522bb76d93a25ac937c71eb1eb4c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa60522bb76d93a25ac937c71eb1eb4c3">FindRegionsInRegionContext</a> (std::string regionContextName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regions, std::string search)</td></tr>
<tr class="separator:aa60522bb76d93a25ac937c71eb1eb4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234af6231ede69fe765479f8eadd7b9" id="r_a8234af6231ede69fe765479f8eadd7b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8234af6231ede69fe765479f8eadd7b9">FindTerminologyNames</a> (std::string categoryCodingSchemeDesignator, std::string categoryCodeValue, std::string typeCodingSchemeDesignator, std::string typeCodeValue, std::string typeModifierCodingSchemeDesignator, std::string typeModifierCodeValue, std::vector&lt; std::string &gt; preferredTerminologyNames, vtkCollection *foundEntries=nullptr, vtkIntArray *foundPreferredTerminologyNameIndices=nullptr)</td></tr>
<tr class="separator:a8234af6231ede69fe765479f8eadd7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f522842a6adf01152bd3591182fa0ca" id="r_a8f522842a6adf01152bd3591182fa0ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f522842a6adf01152bd3591182fa0ca">FindTypeInTerminologyBy3dSlicerLabel</a> (std::string terminologyName, std::string slicerLabel, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:a8f522842a6adf01152bd3591182fa0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbcb18e32c694b29e26d7b0e6da8453" id="r_a5bbcb18e32c694b29e26d7b0e6da8453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bbcb18e32c694b29e26d7b0e6da8453">FindTypesInTerminologyCategory</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;types, std::string search, std::vector&lt; vtkSmartPointer&lt; <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> &gt; &gt; *typeObjects=nullptr)</td></tr>
<tr class="separator:a5bbcb18e32c694b29e26d7b0e6da8453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddfd395ddcd0dfd132cb34d0008e52d" id="r_a4ddfd395ddcd0dfd132cb34d0008e52d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ddfd395ddcd0dfd132cb34d0008e52d">GetCategoriesInTerminology</a> (std::string terminologyName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;categories)</td></tr>
<tr class="separator:a4ddfd395ddcd0dfd132cb34d0008e52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d92564a5ee57c511ed04eae33d7073" id="r_a11d92564a5ee57c511ed04eae33d7073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d92564a5ee57c511ed04eae33d7073">GetCategoryInTerminology</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *categoryObject)</td></tr>
<tr class="separator:a11d92564a5ee57c511ed04eae33d7073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd46d44110fc2801e743bd144fc93a3" id="r_a6bd46d44110fc2801e743bd144fc93a3"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd46d44110fc2801e743bd144fc93a3">GetClassName</a> ()</td></tr>
<tr class="separator:a6bd46d44110fc2801e743bd144fc93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa11d022f52943360e959338945a6df4" id="r_afa11d022f52943360e959338945a6df4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa11d022f52943360e959338945a6df4">GetCompatibleColorNodeIDs</a> ()</td></tr>
<tr class="memdesc:afa11d022f52943360e959338945a6df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of color node IDs that contain terminology information.  <br /></td></tr>
<tr class="separator:afa11d022f52943360e959338945a6df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ad1c978768e90971549b435c67969a" id="r_a48ad1c978768e90971549b435c67969a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLColorNode.html">vtkMRMLColorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ad1c978768e90971549b435c67969a">GetFirstCompatibleColorNodeByName</a> (std::string name)</td></tr>
<tr class="memdesc:a48ad1c978768e90971549b435c67969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first compatible color node that has a matching name.  <br /></td></tr>
<tr class="separator:a48ad1c978768e90971549b435c67969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe677004299d40c3c325d34df7a9d8" id="r_a04fe677004299d40c3c325d34df7a9d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04fe677004299d40c3c325d34df7a9d8">GetLoadedAnatomicContextNames</a> (std::vector&lt; std::string &gt; &amp;anatomicContextNames)</td></tr>
<tr class="separator:a04fe677004299d40c3c325d34df7a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943d252da67eeb49d6ebb4fccaaa7e40" id="r_a943d252da67eeb49d6ebb4fccaaa7e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a943d252da67eeb49d6ebb4fccaaa7e40">GetLoadedAnatomicContextNames</a> (vtkStringArray *anatomicContextNames)</td></tr>
<tr class="separator:a943d252da67eeb49d6ebb4fccaaa7e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf454873396ff82e2bf27fb25f5f4ce1" id="r_abf454873396ff82e2bf27fb25f5f4ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf454873396ff82e2bf27fb25f5f4ce1">GetLoadedRegionContextNames</a> (std::vector&lt; std::string &gt; &amp;regionContextNames)</td></tr>
<tr class="memdesc:abf454873396ff82e2bf27fb25f5f4ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get context names of loaded region contexts.  <br /></td></tr>
<tr class="separator:abf454873396ff82e2bf27fb25f5f4ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5988e452f67a0ce1b71253966fe99da8" id="r_a5988e452f67a0ce1b71253966fe99da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5988e452f67a0ce1b71253966fe99da8">GetLoadedRegionContextNames</a> (vtkStringArray *regionContextNames)</td></tr>
<tr class="memdesc:a5988e452f67a0ce1b71253966fe99da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python accessor variant of.  <br /></td></tr>
<tr class="separator:a5988e452f67a0ce1b71253966fe99da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5cb0e013f5de696e19957d42baddc5" id="r_a9a5cb0e013f5de696e19957d42baddc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a5cb0e013f5de696e19957d42baddc5">GetLoadedTerminologyNames</a> (std::vector&lt; std::string &gt; &amp;terminologyNames)</td></tr>
<tr class="memdesc:a9a5cb0e013f5de696e19957d42baddc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get context names of loaded terminologies.  <br /></td></tr>
<tr class="separator:a9a5cb0e013f5de696e19957d42baddc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164c6462a46a449459e6bdb37f553271" id="r_a164c6462a46a449459e6bdb37f553271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164c6462a46a449459e6bdb37f553271">GetLoadedTerminologyNames</a> (vtkStringArray *terminologyNames)</td></tr>
<tr class="memdesc:a164c6462a46a449459e6bdb37f553271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python accessor variant of.  <br /></td></tr>
<tr class="separator:a164c6462a46a449459e6bdb37f553271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08babae24673d55d906d8bed9374690" id="r_ab08babae24673d55d906d8bed9374690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab08babae24673d55d906d8bed9374690">GetNthCategoryInTerminology</a> (std::string terminologyName, int categoryIndex, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category)</td></tr>
<tr class="separator:ab08babae24673d55d906d8bed9374690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592ec8b896b65d55fbc378f33dbb1c09" id="r_a592ec8b896b65d55fbc378f33dbb1c09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a592ec8b896b65d55fbc378f33dbb1c09">GetNthRegionInAnatomicContext</a> (std::string anatomicContextName, int regionIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:a592ec8b896b65d55fbc378f33dbb1c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a4f71cc9a2cf56874703176346e55e" id="r_aa7a4f71cc9a2cf56874703176346e55e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a4f71cc9a2cf56874703176346e55e">GetNthRegionInRegionContext</a> (std::string regionContextName, int regionIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:aa7a4f71cc9a2cf56874703176346e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cfccf0af4e27c9f3366a62ad148914" id="r_af9cfccf0af4e27c9f3366a62ad148914"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9cfccf0af4e27c9f3366a62ad148914">GetNthRegionModifierInAnatomicRegion</a> (std::string anatomicContextName, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject, int regionModifierIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionModifier)</td></tr>
<tr class="separator:af9cfccf0af4e27c9f3366a62ad148914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa386ade72c8705acafda31a566f92ae2" id="r_aa386ade72c8705acafda31a566f92ae2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa386ade72c8705acafda31a566f92ae2">GetNthRegionModifierInRegion</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject, int regionModifierIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionModifier)</td></tr>
<tr class="separator:aa386ade72c8705acafda31a566f92ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451c840f29203d2be96204e800ae01f9" id="r_a451c840f29203d2be96204e800ae01f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451c840f29203d2be96204e800ae01f9">GetNthTypeInTerminologyCategory</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category, int typeIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *type)</td></tr>
<tr class="separator:a451c840f29203d2be96204e800ae01f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03a320e5d6ee935c564c4cb76239e1b" id="r_ac03a320e5d6ee935c564c4cb76239e1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac03a320e5d6ee935c564c4cb76239e1b">GetNthTypeModifierInTerminologyType</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *type, int typeModifierIndex, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *typeModifier)</td></tr>
<tr class="separator:ac03a320e5d6ee935c564c4cb76239e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edda2b98f56c5f106286e3cc73815ac" id="r_a5edda2b98f56c5f106286e3cc73815ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5edda2b98f56c5f106286e3cc73815ac">GetNumberOfCategoriesInTerminology</a> (std::string terminologyName)</td></tr>
<tr class="memdesc:a5edda2b98f56c5f106286e3cc73815ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of categories in a terminology.  <br /></td></tr>
<tr class="separator:a5edda2b98f56c5f106286e3cc73815ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1bea88f1323ee71bce3e46176859e" id="r_ae4b1bea88f1323ee71bce3e46176859e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4b1bea88f1323ee71bce3e46176859e">GetNumberOfRegionModifierInAnatomicRegion</a> (std::string anatomicContextName, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:ae4b1bea88f1323ee71bce3e46176859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d4bf31e93aac8dc58759a3aff5ffb3" id="r_ad1d4bf31e93aac8dc58759a3aff5ffb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d4bf31e93aac8dc58759a3aff5ffb3">GetNumberOfRegionModifierInRegion</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:ad1d4bf31e93aac8dc58759a3aff5ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba91e26e9b4c014fb551965e81b961ce" id="r_aba91e26e9b4c014fb551965e81b961ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba91e26e9b4c014fb551965e81b961ce">GetNumberOfRegionsInAnatomicContext</a> (std::string anatomicContextName)</td></tr>
<tr class="separator:aba91e26e9b4c014fb551965e81b961ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a36ffb370fb64ad5a53cd539d84b6" id="r_a2e0a36ffb370fb64ad5a53cd539d84b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e0a36ffb370fb64ad5a53cd539d84b6">GetNumberOfRegionsInRegionContext</a> (std::string regionContextName)</td></tr>
<tr class="separator:a2e0a36ffb370fb64ad5a53cd539d84b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e66bf00351236b335596210069bd4a" id="r_a31e66bf00351236b335596210069bd4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31e66bf00351236b335596210069bd4a">GetNumberOfTypeModifiersInTerminologyType</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *type)</td></tr>
<tr class="memdesc:a31e66bf00351236b335596210069bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of type modifiers for the chosen category and type in a terminology.  <br /></td></tr>
<tr class="separator:a31e66bf00351236b335596210069bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff1f1391f26ecac197a6ffa42057eba" id="r_a6ff1f1391f26ecac197a6ffa42057eba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ff1f1391f26ecac197a6ffa42057eba">GetNumberOfTypesInTerminologyCategory</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category)</td></tr>
<tr class="memdesc:a6ff1f1391f26ecac197a6ffa42057eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of types in the chosen category in a terminology.  <br /></td></tr>
<tr class="separator:a6ff1f1391f26ecac197a6ffa42057eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc5c3d7bd133592e82960867457a6b" id="r_a1bbc5c3d7bd133592e82960867457a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bbc5c3d7bd133592e82960867457a6b">GetRegionInAnatomicContext</a> (std::string anatomicContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:a1bbc5c3d7bd133592e82960867457a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3c18a9821f276b4c839e3663293b71" id="r_a9a3c18a9821f276b4c839e3663293b71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a3c18a9821f276b4c839e3663293b71">GetRegionInRegionContext</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionObject)</td></tr>
<tr class="separator:a9a3c18a9821f276b4c839e3663293b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8db2e17abbe7fbd02295268e813f037" id="r_ae8db2e17abbe7fbd02295268e813f037"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8db2e17abbe7fbd02295268e813f037">GetRegionModifierInAnatomicRegion</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> modifierId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionModifier)</td></tr>
<tr class="separator:ae8db2e17abbe7fbd02295268e813f037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab086138f036e99a2daf1fecdeabc1dbc" id="r_ab086138f036e99a2daf1fecdeabc1dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab086138f036e99a2daf1fecdeabc1dbc">GetRegionModifierInRegion</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> modifierId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *regionModifier)</td></tr>
<tr class="separator:ab086138f036e99a2daf1fecdeabc1dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598f5632730cca80c61c8cd8938b072b" id="r_a598f5632730cca80c61c8cd8938b072b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a598f5632730cca80c61c8cd8938b072b">GetRegionModifiersInAnatomicRegion</a> (std::string anatomicContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regionModifiers)</td></tr>
<tr class="separator:a598f5632730cca80c61c8cd8938b072b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fcd011ac31ac14c8197a0d860d4886" id="r_a84fcd011ac31ac14c8197a0d860d4886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84fcd011ac31ac14c8197a0d860d4886">GetRegionModifiersInRegion</a> (std::string regionContextName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> regionId, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regionModifiers)</td></tr>
<tr class="separator:a84fcd011ac31ac14c8197a0d860d4886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98307e137f32dfa83859b5cbcc1054c" id="r_ae98307e137f32dfa83859b5cbcc1054c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae98307e137f32dfa83859b5cbcc1054c">GetRegionsInAnatomicContext</a> (std::string anatomicContextName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regions)</td></tr>
<tr class="separator:ae98307e137f32dfa83859b5cbcc1054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57e37404012bab1eabfbbb89c20c17c" id="r_af57e37404012bab1eabfbbb89c20c17c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af57e37404012bab1eabfbbb89c20c17c">GetRegionsInRegionContext</a> (std::string regionContextName, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;regions)</td></tr>
<tr class="separator:af57e37404012bab1eabfbbb89c20c17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe4bc7086a87335a55f2ed6b0dfea56" id="r_acfe4bc7086a87335a55f2ed6b0dfea56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe4bc7086a87335a55f2ed6b0dfea56">GetTypeInTerminologyCategory</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> typeId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *typeObject)</td></tr>
<tr class="separator:acfe4bc7086a87335a55f2ed6b0dfea56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87ff28a1ba22c1247084c65d85a8cf2" id="r_ab87ff28a1ba22c1247084c65d85a8cf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87ff28a1ba22c1247084c65d85a8cf2">GetTypeModifierInTerminologyType</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> typeId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> modifierId, <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *typeModifier)</td></tr>
<tr class="separator:ab87ff28a1ba22c1247084c65d85a8cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9ea08bd5edba94e9675b7b0068bae0" id="r_a0c9ea08bd5edba94e9675b7b0068bae0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c9ea08bd5edba94e9675b7b0068bae0">GetTypeModifiersInTerminologyType</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> typeId, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;typeModifiers)</td></tr>
<tr class="separator:a0c9ea08bd5edba94e9675b7b0068bae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6becba475d2442aa415498ec437a1a" id="r_a6c6becba475d2442aa415498ec437a1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6becba475d2442aa415498ec437a1a">GetTypesInTerminologyCategory</a> (std::string terminologyName, <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> categoryId, std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;types)</td></tr>
<tr class="separator:a6c6becba475d2442aa415498ec437a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad780abe97d96cba95725f36ef01664d1" id="r_ad780abe97d96cba95725f36ef01664d1"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad780abe97d96cba95725f36ef01664d1">GetUserContextsPath</a> ()</td></tr>
<tr class="separator:ad780abe97d96cba95725f36ef01664d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e615ba933505f73ac0c736640da223b" id="r_a7e615ba933505f73ac0c736640da223b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e615ba933505f73ac0c736640da223b">IsA</a> (const char *type)</td></tr>
<tr class="separator:a7e615ba933505f73ac0c736640da223b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d51674705f2c3f5c637cf49f4dce43" id="r_a58d51674705f2c3f5c637cf49f4dce43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d51674705f2c3f5c637cf49f4dce43">IsTerminologyContextLoaded</a> (std::string terminologyName)</td></tr>
<tr class="memdesc:a58d51674705f2c3f5c637cf49f4dce43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the terminology name is loaded.  <br /></td></tr>
<tr class="separator:a58d51674705f2c3f5c637cf49f4dce43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81a7989e6c19ed1b65049611904ace7" id="r_ac81a7989e6c19ed1b65049611904ace7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81a7989e6c19ed1b65049611904ace7">LoadAnatomicContextFromFile</a> (std::string filePath)</td></tr>
<tr class="separator:ac81a7989e6c19ed1b65049611904ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17605b143864e1d4f7586c056594f97a" id="r_a17605b143864e1d4f7586c056594f97a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17605b143864e1d4f7586c056594f97a">LoadAnatomicContextFromSegmentDescriptorFile</a> (std::string contextName, std::string filePath)</td></tr>
<tr class="separator:a17605b143864e1d4f7586c056594f97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad176de652c343476b647f88f7dceac69" id="r_ad176de652c343476b647f88f7dceac69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad176de652c343476b647f88f7dceac69">LoadContextFromFile</a> (std::string filePath)</td></tr>
<tr class="separator:ad176de652c343476b647f88f7dceac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0ac96db93c3249b626ed679f2451e" id="r_ab3a0ac96db93c3249b626ed679f2451e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a0ac96db93c3249b626ed679f2451e">LoadRegionContextFromFile</a> (std::string filePath)</td></tr>
<tr class="separator:ab3a0ac96db93c3249b626ed679f2451e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5db67c52718f85f7def095cdbbecc4" id="r_abc5db67c52718f85f7def095cdbbecc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5db67c52718f85f7def095cdbbecc4">LoadRegionContextFromSegmentDescriptorFile</a> (std::string contextName, std::string filePath)</td></tr>
<tr class="separator:abc5db67c52718f85f7def095cdbbecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a3fb7d3022cc6a95f24767b3c1f737" id="r_a82a3fb7d3022cc6a95f24767b3c1f737"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a3fb7d3022cc6a95f24767b3c1f737">LoadTerminologyFromFile</a> (std::string filePath)</td></tr>
<tr class="separator:a82a3fb7d3022cc6a95f24767b3c1f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b4c23a5b4ac7591bcd8bfe96828f0" id="r_aea6b4c23a5b4ac7591bcd8bfe96828f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6b4c23a5b4ac7591bcd8bfe96828f0">LoadTerminologyFromSegmentDescriptorFile</a> (std::string contextName, std::string filePath)</td></tr>
<tr class="separator:aea6b4c23a5b4ac7591bcd8bfe96828f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a36ad0b1856262205283334c898b4d1" id="r_a1a36ad0b1856262205283334c898b4d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a36ad0b1856262205283334c898b4d1">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a1a36ad0b1856262205283334c898b4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2699af889f09d0b0df7201f3504570" id="r_a8c2699af889f09d0b0df7201f3504570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c2699af889f09d0b0df7201f3504570">SetUserContextsPath</a> (const char *)</td></tr>
<tr class="separator:a8c2699af889f09d0b0df7201f3504570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2614ac5f7a27934259ddc09bf7d7373b" id="r_a2614ac5f7a27934259ddc09bf7d7373b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2614ac5f7a27934259ddc09bf7d7373b">UpdateEntryFromLoadedTerminologies</a> (<a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry, std::vector&lt; std::string &gt; preferredTerminologyNames, std::vector&lt; std::string &gt; preferredRegionContextNames)</td></tr>
<tr class="separator:a2614ac5f7a27934259ddc09bf7d7373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a03f23ec1414adbec6d7c91b2a98fbdb0" id="r_a03f23ec1414adbec6d7c91b2a98fbdb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f23ec1414adbec6d7c91b2a98fbdb0">AreSegmentTerminologyEntriesEqual</a> (<a class="el" href="classvtkSegment.html">vtkSegment</a> *segment1, <a class="el" href="classvtkSegment.html">vtkSegment</a> *segment2)</td></tr>
<tr class="separator:a03f23ec1414adbec6d7c91b2a98fbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a152547360d2f56b20b4ba6a76190b" id="r_a79a152547360d2f56b20b4ba6a76190b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79a152547360d2f56b20b4ba6a76190b">AreTerminologyEntriesEqual</a> (<a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry1, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry2)</td></tr>
<tr class="separator:a79a152547360d2f56b20b4ba6a76190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d14137b778beac7b04c54aa21a3939d" id="r_a1d14137b778beac7b04c54aa21a3939d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d14137b778beac7b04c54aa21a3939d">AreTerminologyEntriesEqual</a> (std::string terminologyEntry1, std::string terminologyEntry2)</td></tr>
<tr class="separator:a1d14137b778beac7b04c54aa21a3939d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69cdc62542ddf31719779cd11e23430" id="r_ae69cdc62542ddf31719779cd11e23430"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae69cdc62542ddf31719779cd11e23430">AreCodedEntriesEqual</a> (<a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *codedEntry1, <a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *codedEntry2)</td></tr>
<tr class="separator:ae69cdc62542ddf31719779cd11e23430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a8931a0176e046fa530d68105ceecef66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkSlicerApplicationLogic.html">vtkSlicerApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a8931a0176e046fa530d68105ceecef66">GetApplicationLogic</a> ()</td></tr>
<tr class="memdesc:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0da4557f1f4335d1e4b5f08be2d282e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0da4557f1f4335d1e4b5f08be2d282e7">GetModuleLogic</a> (const char *moduleName)</td></tr>
<tr class="memdesc:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for getting another module's logic from the application logic.  <br /></td></tr>
<tr class="separator:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic" id="r_aef42603c86610d6a6e93f3d48323f7ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#aef42603c86610d6a6e93f3d48323f7ef">GetModuleShareDirectory</a> () const</td></tr>
<tr class="separator:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0e3bbf7759001cc13890f41d1a79c598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0e3bbf7759001cc13890f41d1a79c598">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a2918ff2ca1a047594ab5f21d7fa93997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a2918ff2ca1a047594ab5f21d7fa93997">SetModuleShareDirectory</a> (const std::string &amp;shareDirectory)</td></tr>
<tr class="separator:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a530bc426ed6f5725f82b67bc7383ef51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a530bc426ed6f5725f82b67bc7383ef51">GetMRMLApplicationLogic</a> () const</td></tr>
<tr class="memdesc:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a147f82b5aaaf465ccdb5cabbfef8e6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a147f82b5aaaf465ccdb5cabbfef8e6e8">GetMRMLScene</a> () const</td></tr>
<tr class="memdesc:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the current MRML scene.  <br /></td></tr>
<tr class="separator:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a30dc8aa28d58ca3f9a52ee9923fb13a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a30dc8aa28d58ca3f9a52ee9923fb13a9">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a95af27a03775e432e2e9a4ffa0681a8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a95af27a03775e432e2e9a4ffa0681a8c">SetMRMLApplicationLogic</a> (<a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *logic)</td></tr>
<tr class="separator:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a51f4149e574bb15f5d082dc93c07543e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51f4149e574bb15f5d082dc93c07543e">SetMRMLScene</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene)</td></tr>
<tr class="memdesc:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and observe the MRMLScene.  <br /></td></tr>
<tr class="separator:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a21216db07aab06ccb83594dd784e58b1" id="r_a21216db07aab06ccb83594dd784e58b1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21216db07aab06ccb83594dd784e58b1">AreCodedEntriesExactMatch</a> (<a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *codedEntry1, <a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *codedEntry2)</td></tr>
<tr class="separator:a21216db07aab06ccb83594dd784e58b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716a18dd64b068827e7fcc93c8780560" id="r_a716a18dd64b068827e7fcc93c8780560"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716a18dd64b068827e7fcc93c8780560">CodeIdentifierFromTerminologyCategory</a> (<a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *category)</td></tr>
<tr class="separator:a716a18dd64b068827e7fcc93c8780560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012007ad64d8de7c45e9139752d90338" id="r_a012007ad64d8de7c45e9139752d90338"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a012007ad64d8de7c45e9139752d90338">CodeIdentifierFromTerminologyType</a> (<a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *type)</td></tr>
<tr class="separator:a012007ad64d8de7c45e9139752d90338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad678d3f12c69432452730bdd83fb4a7b" id="r_ad678d3f12c69432452730bdd83fb4a7b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad678d3f12c69432452730bdd83fb4a7b">DeserializeTerminologyEntry</a> (std::string serializedEntry, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:ad678d3f12c69432452730bdd83fb4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e710df3207bba085c3091c4a480d9a" id="r_ab2e710df3207bba085c3091c4a480d9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e710df3207bba085c3091c4a480d9a">GetCodeIdentifierFromCodedEntry</a> (<a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *entry)</td></tr>
<tr class="memdesc:ab2e710df3207bba085c3091c4a480d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert terminology category, type, etc. object to code identifier.  <br /></td></tr>
<tr class="separator:ab2e710df3207bba085c3091c4a480d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c20aefb4e6d80697be28e3c57c3960" id="r_a46c20aefb4e6d80697be28e3c57c3960"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46c20aefb4e6d80697be28e3c57c3960">GetColorAutoGeneratedAttributeName</a> ()</td></tr>
<tr class="memdesc:a46c20aefb4e6d80697be28e3c57c3960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node attribute name for color auto generated.  <br /></td></tr>
<tr class="separator:a46c20aefb4e6d80697be28e3c57c3960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c5f6004c18e96b4ae6c4ab4c9db178" id="r_a44c5f6004c18e96b4ae6c4ab4c9db178"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c5f6004c18e96b4ae6c4ab4c9db178">GetColorIndexByTerminology</a> (<a class="el" href="classvtkMRMLColorNode.html">vtkMRMLColorNode</a> *colorNode, const std::string &amp;terminologyStr, bool ignoreContextName=true)</td></tr>
<tr class="separator:a44c5f6004c18e96b4ae6c4ab4c9db178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06e45ba1fa4ba0f4f9002116d1d1982" id="r_ab06e45ba1fa4ba0f4f9002116d1d1982"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab06e45ba1fa4ba0f4f9002116d1d1982">GetDefaultTerminologyEntry</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:ab06e45ba1fa4ba0f4f9002116d1d1982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab39a19658f2476764762d2a92a6b6cc" id="r_aab39a19658f2476764762d2a92a6b6cc"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab39a19658f2476764762d2a92a6b6cc">GetDefaultTerminologyEntryAsString</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node)</td></tr>
<tr class="separator:aab39a19658f2476764762d2a92a6b6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4777a88db15a5784129bf7c3e7bf953" id="r_aa4777a88db15a5784129bf7c3e7bf953"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4777a88db15a5784129bf7c3e7bf953">GetDefaultTerminologyEntryAttributeName</a> ()</td></tr>
<tr class="separator:aa4777a88db15a5784129bf7c3e7bf953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33d9dfdd0a9be541e4d86d48d014d02" id="r_ab33d9dfdd0a9be541e4d86d48d014d02"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33d9dfdd0a9be541e4d86d48d014d02">GetInfoStringFromTerminologyEntry</a> (<a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="memdesc:ab33d9dfdd0a9be541e4d86d48d014d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble human readable info string from a terminology entry, for example for tooltips.  <br /></td></tr>
<tr class="separator:ab33d9dfdd0a9be541e4d86d48d014d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738b407a83bad73bbef08c533b7a5fb" id="r_ac738b407a83bad73bbef08c533b7a5fb"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac738b407a83bad73bbef08c533b7a5fb">GetNameAutoGeneratedAttributeName</a> ()</td></tr>
<tr class="memdesc:ac738b407a83bad73bbef08c533b7a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node attribute name for name auto generated.  <br /></td></tr>
<tr class="separator:ac738b407a83bad73bbef08c533b7a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00947f9ec77765be49437fb820a7a8b5" id="r_a00947f9ec77765be49437fb820a7a8b5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00947f9ec77765be49437fb820a7a8b5">GetTerminologyEntry</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:a00947f9ec77765be49437fb820a7a8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2145fec35c22d34906f48a3836419e2" id="r_ab2145fec35c22d34906f48a3836419e2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2145fec35c22d34906f48a3836419e2">GetTerminologyEntryAsString</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node)</td></tr>
<tr class="separator:ab2145fec35c22d34906f48a3836419e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435612f3023a5071bf3029ee71501ab" id="r_af435612f3023a5071bf3029ee71501ab"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af435612f3023a5071bf3029ee71501ab">GetTerminologyEntryAttributeName</a> ()</td></tr>
<tr class="memdesc:af435612f3023a5071bf3029ee71501ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminology entry (serialized to string)  <br /></td></tr>
<tr class="separator:af435612f3023a5071bf3029ee71501ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb30ec39eaee5263e2c2bdb1c9ee91" id="r_aedcb30ec39eaee5263e2c2bdb1c9ee91"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedcb30ec39eaee5263e2c2bdb1c9ee91">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:aedcb30ec39eaee5263e2c2bdb1c9ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0433a4b9b5c8ce73ddd3796f6a57bb" id="r_a1d0433a4b9b5c8ce73ddd3796f6a57bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic.html">vtkSlicerTerminologiesModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d0433a4b9b5c8ce73ddd3796f6a57bb">New</a> ()</td></tr>
<tr class="separator:a1d0433a4b9b5c8ce73ddd3796f6a57bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa811066fc06ce9b8f720f3bc56767e85" id="r_aa811066fc06ce9b8f720f3bc56767e85"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic.html">vtkSlicerTerminologiesModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa811066fc06ce9b8f720f3bc56767e85">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:aa811066fc06ce9b8f720f3bc56767e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220071f0dbfb814492c46df4ab63ba8e" id="r_a220071f0dbfb814492c46df4ab63ba8e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a220071f0dbfb814492c46df4ab63ba8e">SerializeTerminologyEntry</a> (std::string terminologyContextName, std::string categoryValue, std::string categorySchemeDesignator, std::string categoryMeaning, std::string typeValue, std::string typeSchemeDesignator, std::string typeMeaning, std::string modifierValue, std::string modifierSchemeDesignator, std::string modifierMeaning, std::string regionContextName, std::string regionValue, std::string regionSchemeDesignator, std::string regionMeaning, std::string regionModifierValue, std::string regionModifierSchemeDesignator, std::string regionModifierMeaning)</td></tr>
<tr class="separator:a220071f0dbfb814492c46df4ab63ba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174464662bc5b962174617f2eb572068" id="r_a174464662bc5b962174617f2eb572068"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174464662bc5b962174617f2eb572068">SerializeTerminologyEntry</a> (<a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:a174464662bc5b962174617f2eb572068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36573f2662248ab00e2a08c71c796c6f" id="r_a36573f2662248ab00e2a08c71c796c6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36573f2662248ab00e2a08c71c796c6f">SetDefaultTerminologyEntry</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:a36573f2662248ab00e2a08c71c796c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4df44051d575e239445883a0439bafe" id="r_ad4df44051d575e239445883a0439bafe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4df44051d575e239445883a0439bafe">SetDefaultTerminologyEntryAsString</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, std::string entryStr)</td></tr>
<tr class="separator:ad4df44051d575e239445883a0439bafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7777a50a1673123d0b492c378f998d" id="r_a1f7777a50a1673123d0b492c378f998d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7777a50a1673123d0b492c378f998d">SetTerminologyEntry</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, <a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *entry)</td></tr>
<tr class="separator:a1f7777a50a1673123d0b492c378f998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee486e8d5331ec0904f873ce5bd1ce0" id="r_acee486e8d5331ec0904f873ce5bd1ce0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acee486e8d5331ec0904f873ce5bd1ce0">SetTerminologyEntryAsString</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node, std::string entryStr)</td></tr>
<tr class="separator:acee486e8d5331ec0904f873ce5bd1ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ae51eba75b9c5e714584ad139110613ad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ae51eba75b9c5e714584ad139110613ad">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ac55ca7008a3d25c56ef115d346c1f228"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ac55ca7008a3d25c56ef115d346c1f228">New</a> ()</td></tr>
<tr class="memdesc:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Usual vtk class functions.  <br /></td></tr>
<tr class="separator:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_a4f7462e217013233873c2f10176a58ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a4f7462e217013233873c2f10176a58ff">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a466db0b62e33aa0f80d0fe720c1a6213"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a466db0b62e33aa0f80d0fe720c1a6213">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a2d46c696959ebbe53b83ce0df02add8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2d46c696959ebbe53b83ce0df02add8b">New</a> ()</td></tr>
<tr class="separator:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a4f99d44049ff8e4c008ffed1ee7519ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4f99d44049ff8e4c008ffed1ee7519ba">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad3ddf18b5d025bac974476fdb10903ac" id="r_ad3ddf18b5d025bac974476fdb10903ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ddf18b5d025bac974476fdb10903ac">LoadDefaultRegionContexts</a> ()</td></tr>
<tr class="memdesc:ad3ddf18b5d025bac974476fdb10903ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load default region context dictionaries from JSON into.  <br /></td></tr>
<tr class="separator:ad3ddf18b5d025bac974476fdb10903ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd690b1b6fdaee7f9e6d95b453d35cca" id="r_afd690b1b6fdaee7f9e6d95b453d35cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd690b1b6fdaee7f9e6d95b453d35cca">LoadDefaultTerminologies</a> ()</td></tr>
<tr class="memdesc:afd690b1b6fdaee7f9e6d95b453d35cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load default terminology dictionaries from JSON into.  <br /></td></tr>
<tr class="separator:afd690b1b6fdaee7f9e6d95b453d35cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d2a0158d27f6b5bfeea63cea377be" id="r_a7b6d2a0158d27f6b5bfeea63cea377be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6d2a0158d27f6b5bfeea63cea377be">LoadUserContexts</a> ()</td></tr>
<tr class="memdesc:a7b6d2a0158d27f6b5bfeea63cea377be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load terminologies and region contexts from the user settings directory.  <br /></td></tr>
<tr class="separator:a7b6d2a0158d27f6b5bfeea63cea377be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155960ee7db47f5ec7cf42fb1b608e9" id="r_ac155960ee7db47f5ec7cf42fb1b608e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac155960ee7db47f5ec7cf42fb1b608e9">SetMRMLSceneInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene) override</td></tr>
<tr class="separator:ac155960ee7db47f5ec7cf42fb1b608e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd387c2e997e0832ca26cd7cd474aae" id="r_abcd387c2e997e0832ca26cd7cd474aae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd387c2e997e0832ca26cd7cd474aae">vtkSlicerTerminologiesModuleLogic</a> ()</td></tr>
<tr class="separator:abcd387c2e997e0832ca26cd7cd474aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dbfb6fc8f605ef0841379a0d4414be" id="r_a09dbfb6fc8f605ef0841379a0d4414be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09dbfb6fc8f605ef0841379a0d4414be">~vtkSlicerTerminologiesModuleLogic</a> () override</td></tr>
<tr class="separator:a09dbfb6fc8f605ef0841379a0d4414be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic" id="r_a43ba2967e63f5194eba13570e79c8b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a43ba2967e63f5194eba13570e79c8b4e">vtkSlicerModuleLogic</a> ()</td></tr>
<tr class="separator:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic" id="r_a06a744b1d43e4370a99462f0b9b3f30f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a06a744b1d43e4370a99462f0b9b3f30f">~vtkSlicerModuleLogic</a> () override</td></tr>
<tr class="separator:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ab5b1ee240252dfd245fc01f8eb53e8e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab5b1ee240252dfd245fc01f8eb53e8e9">EndModify</a> (bool wasModifying)</td></tr>
<tr class="separator:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a471bd7df7caef325291e5e683e42796c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a471bd7df7caef325291e5e683e42796c">EnterMRMLLogicsCallback</a> () const</td></tr>
<tr class="separator:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aeb78c60e083bcbb907f81f136e53364e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aeb78c60e083bcbb907f81f136e53364e">EnterMRMLNodesCallback</a> () const</td></tr>
<tr class="separator:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a57c1538abccd8fc920b20d7f277f9ad3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a57c1538abccd8fc920b20d7f277f9ad3">EnterMRMLSceneCallback</a> () const</td></tr>
<tr class="separator:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5d7c3aabe26766856b040937db55141d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5d7c3aabe26766856b040937db55141d">GetDisableModifiedEvent</a> () const</td></tr>
<tr class="separator:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic" id="r_add020efdf3ea303c860c06218e7bd0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#add020efdf3ea303c860c06218e7bd0ce">GetInMRMLLogicsCallbackFlag</a> () const</td></tr>
<tr class="separator:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ad43b978b6997abd9211e873107fbb99b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ad43b978b6997abd9211e873107fbb99b">GetInMRMLNodesCallbackFlag</a> () const</td></tr>
<tr class="separator:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2c912757bd1e2fb9ed18531772d9b7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2c912757bd1e2fb9ed18531772d9b7c2">GetInMRMLSceneCallbackFlag</a> () const</td></tr>
<tr class="separator:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2024ab8d24c8b78ca68aa76ee2df6d1b"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2024ab8d24c8b78ca68aa76ee2df6d1b">GetMRMLLogicsCallbackCommand</a> ()</td></tr>
<tr class="separator:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5cd3b9222aa0f9399a0d04daa857af41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5cd3b9222aa0f9399a0d04daa857af41">GetMRMLLogicsObserverManager</a> () const</td></tr>
<tr class="separator:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a31c1e7f33880b6ad9683548fbc4ccaca"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a31c1e7f33880b6ad9683548fbc4ccaca">GetMRMLNodesCallbackCommand</a> ()</td></tr>
<tr class="separator:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a858c37b78d41171d298b797d03494411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a858c37b78d41171d298b797d03494411">GetMRMLNodesObserverManager</a> () const</td></tr>
<tr class="separator:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4d9c5b9885a2d46790cb5e31a7e013dd"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4d9c5b9885a2d46790cb5e31a7e013dd">GetMRMLSceneCallbackCommand</a> ()</td></tr>
<tr class="separator:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aefad89326706f2999ff8e6e97e221061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aefad89326706f2999ff8e6e97e221061">GetMRMLSceneObserverManager</a> () const</td></tr>
<tr class="separator:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_abcbd9db7caad7038b170c95a3398d237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abcbd9db7caad7038b170c95a3398d237">GetPendingModifiedEventCount</a> () const</td></tr>
<tr class="separator:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a040a2e3a82ac8a72ea06450c78001db1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a040a2e3a82ac8a72ea06450c78001db1">GetProcessingMRMLSceneEvent</a> () const</td></tr>
<tr class="memdesc:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the event id currently processed or 0 if any.  <br /></td></tr>
<tr class="separator:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adbdafafc00fbfca72832bf573b4e53fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adbdafafc00fbfca72832bf573b4e53fd">InvokePendingModifiedEvent</a> ()</td></tr>
<tr class="separator:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a47880d57d0f4b54a2ace71ab4b071bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a47880d57d0f4b54a2ace71ab4b071bc7">Modified</a> () override</td></tr>
<tr class="separator:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_abeec5de56ddcf3ed8206ed1fa388c364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abeec5de56ddcf3ed8206ed1fa388c364">ObserveMRMLScene</a> ()</td></tr>
<tr class="separator:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a124e968e51a99e4dc16d022b3fd37e2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a124e968e51a99e4dc16d022b3fd37e2e">OnMRMLNodeModified</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac1a782799e284bd04ea5182b1e41dc93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac1a782799e284bd04ea5182b1e41dc93">OnMRMLSceneEndBatchProcess</a> ()</td></tr>
<tr class="separator:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5f8a69a47eacec0cd95857beceb8eb34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5f8a69a47eacec0cd95857beceb8eb34">OnMRMLSceneEndClose</a> ()</td></tr>
<tr class="separator:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ae826dc18ec31156f0eae3456608eb1c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ae826dc18ec31156f0eae3456608eb1c4">OnMRMLSceneEndImport</a> ()</td></tr>
<tr class="separator:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3e1d4144d47f125c71a36c88c4289e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3e1d4144d47f125c71a36c88c4289e1">OnMRMLSceneEndRestore</a> ()</td></tr>
<tr class="separator:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac9c4356c3ad53f529f948214d5ce30f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac9c4356c3ad53f529f948214d5ce30f1">OnMRMLSceneNew</a> ()</td></tr>
<tr class="separator:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0102310f18a3880f00e93b8e37210c9 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac0102310f18a3880f00e93b8e37210c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac0102310f18a3880f00e93b8e37210c9">OnMRMLSceneNodeAdded</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:ac0102310f18a3880f00e93b8e37210c9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a92b1149d08ec5099a9ec61c0636f37c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a92b1149d08ec5099a9ec61c0636f37c4">OnMRMLSceneNodeRemoved</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic" id="r_afc31c1f6a54e4dabf14f1ae3fe3c47df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#afc31c1f6a54e4dabf14f1ae3fe3c47df">OnMRMLSceneStartBatchProcess</a> ()</td></tr>
<tr class="separator:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a063cceb9c914333b8fd076ff5c0f6a30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a063cceb9c914333b8fd076ff5c0f6a30">OnMRMLSceneStartClose</a> ()</td></tr>
<tr class="separator:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a048ce8ed9409c07be134bcd03ae27184"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a048ce8ed9409c07be134bcd03ae27184">OnMRMLSceneStartImport</a> ()</td></tr>
<tr class="separator:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aebe17bd4344f7c85c653d10631d6aa30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aebe17bd4344f7c85c653d10631d6aa30">OnMRMLSceneStartRestore</a> ()</td></tr>
<tr class="separator:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adac3d2b2ec84f30d78d3a6c8d8aeb828"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adac3d2b2ec84f30d78d3a6c8d8aeb828">ProcessMRMLLogicsEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a43a759874ce32846c6dffc52e5941744"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a43a759874ce32846c6dffc52e5941744">ProcessMRMLNodesEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a51fdf00ecfc18c1a1465d4bccb789ef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7f65f53d5fbe6d056e7cf32a23058 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_acfa7f65f53d5fbe6d056e7cf32a23058"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acfa7f65f53d5fbe6d056e7cf32a23058">RegisterNodes</a> ()</td></tr>
<tr class="separator:acfa7f65f53d5fbe6d056e7cf32a23058 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac028eafed3ee93b9b3741f57139132d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac028eafed3ee93b9b3741f57139132d3">SetAndObserveMRMLSceneEventsInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene, vtkIntArray *events, vtkFloatArray *priorities=nullptr)</td></tr>
<tr class="separator:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3eb7d963472fa9fd4eb83d8a6ee33ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3eb7d963472fa9fd4eb83d8a6ee33ccd">SetDisableModifiedEvent</a> (bool onOff)</td></tr>
<tr class="separator:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac4b6e57c0562f3e41a92372cca661e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac4b6e57c0562f3e41a92372cca661e65">SetInMRMLLogicsCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4836d6eb665c483236232345eccb9833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4836d6eb665c483236232345eccb9833">SetInMRMLNodesCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_acf80dc501f04df6b0d0db5095d63e042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acf80dc501f04df6b0d0db5095d63e042">SetInMRMLSceneCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3b03cb0ee8830fc953868266b62df44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3b03cb0ee8830fc953868266b62df44">SetProcessingMRMLSceneEvent</a> (int event)</td></tr>
<tr class="separator:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aca82fcc8ec42d9976a29b0acf9ba27a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aca82fcc8ec42d9976a29b0acf9ba27a4">StartModify</a> ()</td></tr>
<tr class="separator:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a966747ac1626e911a08ce8bb9ba909eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a> ()</td></tr>
<tr class="separator:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a50caeb3a373ccd53635ae2c08bc2e63e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene</a> ()</td></tr>
<tr class="separator:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3440792dbe0d54de16de57eac139bb34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3440792dbe0d54de16de57eac139bb34">vtkMRMLAbstractLogic</a> ()</td></tr>
<tr class="separator:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a417c9d98b17e68087d1263b95d4003d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a417c9d98b17e68087d1263b95d4003d8">~vtkMRMLAbstractLogic</a> () override</td></tr>
<tr class="separator:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a113954f0eb61c73d3b84865cee602891" id="r_a113954f0eb61c73d3b84865cee602891"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113954f0eb61c73d3b84865cee602891">UserContextsPath</a> {nullptr}</td></tr>
<tr class="memdesc:a113954f0eb61c73d3b84865cee602891"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path from which the json files are automatically loaded on startup.  <br /></td></tr>
<tr class="separator:a113954f0eb61c73d3b84865cee602891"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a969cb5fb8171d059c79ae0954c80dc09" id="r_a969cb5fb8171d059c79ae0954c80dc09"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a969cb5fb8171d059c79ae0954c80dc09">vtkInternal</a></td></tr>
<tr class="separator:a969cb5fb8171d059c79ae0954c80dc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5af15efe0f8421ef6de4f3168830e3f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5af15efe0f8421ef6de4f3168830e3f7">MRMLLogicsCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLLogicCallback is a static function to relay modified events from the logics.  <br /></td></tr>
<tr class="separator:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5b796a7ccecd251cdb83874b390c4e43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5b796a7ccecd251cdb83874b390c4e43">MRMLNodesCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLNodesCallback is a static function to relay modified events from the nodes.  <br /></td></tr>
<tr class="separator:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_af4a68e64a0ca65a9efb92d717f3a7896"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af4a68e64a0ca65a9efb92d717f3a7896">MRMLSceneCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="separator:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00039">39</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a84a7563192cb1c13763cfbfb0dd12904" name="a84a7563192cb1c13763cfbfb0dd12904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a7563192cb1c13763cfbfb0dd12904">&#9670;&#160;</a></span>Superclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> <a class="el" href="#a84a7563192cb1c13763cfbfb0dd12904">vtkSlicerTerminologiesModuleLogic::Superclass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00044">44</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abcd387c2e997e0832ca26cd7cd474aae" name="abcd387c2e997e0832ca26cd7cd474aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd387c2e997e0832ca26cd7cd474aae">&#9670;&#160;</a></span>vtkSlicerTerminologiesModuleLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerTerminologiesModuleLogic::vtkSlicerTerminologiesModuleLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09dbfb6fc8f605ef0841379a0d4414be" name="a09dbfb6fc8f605ef0841379a0d4414be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dbfb6fc8f605ef0841379a0d4414be">&#9670;&#160;</a></span>~vtkSlicerTerminologiesModuleLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerTerminologiesModuleLogic::~vtkSlicerTerminologiesModuleLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae69cdc62542ddf31719779cd11e23430" name="ae69cdc62542ddf31719779cd11e23430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69cdc62542ddf31719779cd11e23430">&#9670;&#160;</a></span>AreCodedEntriesEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::AreCodedEntriesEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>codedEntry1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>codedEntry2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21216db07aab06ccb83594dd784e58b1" name="a21216db07aab06ccb83594dd784e58b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21216db07aab06ccb83594dd784e58b1">&#9670;&#160;</a></span>AreCodedEntriesExactMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTerminologiesModuleLogic::AreCodedEntriesExactMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>codedEntry1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>codedEntry2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two terminology entries for exact equality. </p><dl class="section return"><dt>Returns</dt><dd>True if the entries are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a03f23ec1414adbec6d7c91b2a98fbdb0" name="a03f23ec1414adbec6d7c91b2a98fbdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f23ec1414adbec6d7c91b2a98fbdb0">&#9670;&#160;</a></span>AreSegmentTerminologyEntriesEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::AreSegmentTerminologyEntriesEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSegment.html">vtkSegment</a> *</td>          <td class="paramname"><span class="paramname"><em>segment2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two terminology entries for equality. </p><dl class="section return"><dt>Returns</dt><dd>True if the entries are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a1d14137b778beac7b04c54aa21a3939d" name="a1d14137b778beac7b04c54aa21a3939d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d14137b778beac7b04c54aa21a3939d">&#9670;&#160;</a></span>AreTerminologyEntriesEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::AreTerminologyEntriesEqual </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyEntry1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyEntry2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79a152547360d2f56b20b4ba6a76190b" name="a79a152547360d2f56b20b4ba6a76190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a152547360d2f56b20b4ba6a76190b">&#9670;&#160;</a></span>AreTerminologyEntriesEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::AreTerminologyEntriesEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a716a18dd64b068827e7fcc93c8780560" name="a716a18dd64b068827e7fcc93c8780560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716a18dd64b068827e7fcc93c8780560">&#9670;&#160;</a></span>CodeIdentifierFromTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> vtkSlicerTerminologiesModuleLogic::CodeIdentifierFromTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000170">Deprecated</a></b></dt><dd>Use GetCodeIdentifierFromCodedEntry instead. </dd></dl>

</div>
</div>
<a id="a012007ad64d8de7c45e9139752d90338" name="a012007ad64d8de7c45e9139752d90338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012007ad64d8de7c45e9139752d90338">&#9670;&#160;</a></span>CodeIdentifierFromTerminologyType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> vtkSlicerTerminologiesModuleLogic::CodeIdentifierFromTerminologyType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000171">Deprecated</a></b></dt><dd>Use GetCodeIdentifierFromCodedEntry instead. </dd></dl>

</div>
</div>
<a id="ad678d3f12c69432452730bdd83fb4a7b" name="ad678d3f12c69432452730bdd83fb4a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad678d3f12c69432452730bdd83fb4a7b">&#9670;&#160;</a></span>DeserializeTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTerminologiesModuleLogic::DeserializeTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>serializedEntry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate terminology entry VTK object based on serialized entry Serialized terminology entry consists of the following: terminologyContextName, category (codingScheme, codeValue, codeMeaning triple), type, typeModifier, regionContextName, region, regionModifier </p><dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a598fd8b2e83f32d6fe67904a0769beb7" name="a598fd8b2e83f32d6fe67904a0769beb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598fd8b2e83f32d6fe67904a0769beb7">&#9670;&#160;</a></span>FindAnatomicContextNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vtkSlicerTerminologiesModuleLogic::FindAnatomicContextNames </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicRegionCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicRegionCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicRegionModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicRegionModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredAnatomicContextNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkCollection *</td>          <td class="paramname"><span class="paramname"><em>foundEntries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000160">Deprecated</a></b></dt><dd>Use FindRegionContextNames instead. </dd></dl>

</div>
</div>
<a id="a73f679f779b105c41b8226d0d1d83545" name="a73f679f779b105c41b8226d0d1d83545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f679f779b105c41b8226d0d1d83545">&#9670;&#160;</a></span>FindCategoriesInTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindCategoriesInTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>categories</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>search</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find category names (codeMeaning) in terminology containing a given string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">categories</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyCategory.html" title="Terminology property category object.">vtkSlicerTerminologyCategory</a> objects created from the categories found in the given terminology </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ae2bfb2bb0da06445cb0ef0a207e8805f" name="ae2bfb2bb0da06445cb0ef0a207e8805f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bfb2bb0da06445cb0ef0a207e8805f">&#9670;&#160;</a></span>FindColorNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vtkSlicerTerminologiesModuleLogic::FindColorNodes </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredColorNodeNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>foundColorIndices</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>foundPreferredColorNodeIndices</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return collection of color node IDs designated by the given codes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preferredTerminologyNames</td><td>List of terminology names in order of preference. If an empty list is provided then all terminologies are searched. </td></tr>
    <tr><td class="paramname">foundColorIndices</td><td>if specified then it will contain the indices of the found colors in the color table. </td></tr>
    <tr><td class="paramname">foundPreferredColorNodeIndices</td><td>if specified then it will contain the indices of the found color nodes in the preferredColorNodeNames list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37252c3a55f7220be2a55d8cd7363ad5" name="a37252c3a55f7220be2a55d8cd7363ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37252c3a55f7220be2a55d8cd7363ad5">&#9670;&#160;</a></span>FindFirstColorNodeOrTerminology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindFirstColorNodeOrTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredTerminologyNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>foundTerminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>foundColorNodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>foundColorIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the best fitting color node or terminology </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preferredTerminologyNames</td><td>List of terminology names in order of preference. If an empty list is provided then all terminologies are searched. </td></tr>
    <tr><td class="paramname">foundTerminologyName</td><td>found terminology name (color node name in case a color node was found) </td></tr>
    <tr><td class="paramname">foundColorNodeID</td><td>found color node ID (empty if terminology was found) </td></tr>
    <tr><td class="paramname">foundColorIndex</td><td>found color index in the color node (-1 if color was not found in the table) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a486267a08a5ca37a60b37897fa236b" name="a2a486267a08a5ca37a60b37897fa236b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a486267a08a5ca37a60b37897fa236b">&#9670;&#160;</a></span>FindFirstColorNodeOrTerminology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindFirstColorNodeOrTerminology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredTerminologyNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>foundTerminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>foundColorNodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>foundColorIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the best fitting color node or terminology </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preferredTerminologyNames</td><td>List of terminology names in order of preference. If an empty list is provided then all terminologies are searched. </td></tr>
    <tr><td class="paramname">foundTerminologyName</td><td>found terminology name (color node name in case a color node was found) </td></tr>
    <tr><td class="paramname">foundColorNodeID</td><td>found color node ID (empty if terminology was found) </td></tr>
    <tr><td class="paramname">foundColorIndex</td><td>found color index in the color node (-1 if color was not found in the table) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d1028fd8cefb80e3864592efdb80a2" name="a26d1028fd8cefb80e3864592efdb80a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d1028fd8cefb80e3864592efdb80a2">&#9670;&#160;</a></span>FindRegionContextNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vtkSlicerTerminologiesModuleLogic::FindRegionContextNames </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredRegionContextNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkCollection *</td>          <td class="paramname"><span class="paramname"><em>foundEntries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return list of region context names containing the specified region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preferredRegionContextNames</td><td>List of region context names in order of preference. If an empty list is provided then all context are searched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44750d7a3b231ca0fa876187c986cc35" name="a44750d7a3b231ca0fa876187c986cc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44750d7a3b231ca0fa876187c986cc35">&#9670;&#160;</a></span>FindRegionsInAnatomicContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindRegionsInAnatomicContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>search</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000164">Deprecated</a></b></dt><dd>Use FindRegionsInRegionContext instead. </dd></dl>

</div>
</div>
<a id="aa60522bb76d93a25ac937c71eb1eb4c3" name="aa60522bb76d93a25ac937c71eb1eb4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60522bb76d93a25ac937c71eb1eb4c3">&#9670;&#160;</a></span>FindRegionsInRegionContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindRegionsInRegionContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>search</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get all region names (codeMeaning) in an context </p><dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a8234af6231ede69fe765479f8eadd7b9" name="a8234af6231ede69fe765479f8eadd7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8234af6231ede69fe765479f8eadd7b9">&#9670;&#160;</a></span>FindTerminologyNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vtkSlicerTerminologiesModuleLogic::FindTerminologyNames </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodingSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeModifierCodeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredTerminologyNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkCollection *</td>          <td class="paramname"><span class="paramname"><em>foundEntries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIntArray *</td>          <td class="paramname"><span class="paramname"><em>foundPreferredTerminologyNameIndices</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return collection of <a class="el" href="classvtkSlicerTerminologyEntry.html" title="VTK implementation of.">vtkSlicerTerminologyEntry</a> objects designated by the given codes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preferredTerminologyNames</td><td>List of terminology names in order of preference. If an empty list is provided then all terminologies are searched. </td></tr>
    <tr><td class="paramname">foundEntries</td><td>if specified then it will contain the found terminology entries. </td></tr>
    <tr><td class="paramname">foundPreferredColorNodeIndices</td><td>if specified then it will contain the indices of the found terminologies in the in the preferredTerminologyNames list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f522842a6adf01152bd3591182fa0ca" name="a8f522842a6adf01152bd3591182fa0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f522842a6adf01152bd3591182fa0ca">&#9670;&#160;</a></span>FindTypeInTerminologyBy3dSlicerLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindTypeInTerminologyBy3dSlicerLabel </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>slicerLabel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find terminology type or type modifier based on '3dSlicerLabel' attribute </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminologyName</td><td>Terminology context in which the attribute is looked for </td></tr>
    <tr><td class="paramname">slicerLabel</td><td>Attribute to look for </td></tr>
    <tr><td class="paramname">entry</td><td>Terminology entry populated if the attribute is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag indicating whether the attribute was found </dd></dl>

</div>
</div>
<a id="a5bbcb18e32c694b29e26d7b0e6da8453" name="a5bbcb18e32c694b29e26d7b0e6da8453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbcb18e32c694b29e26d7b0e6da8453">&#9670;&#160;</a></span>FindTypesInTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::FindTypesInTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>search</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; vtkSmartPointer&lt; <a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>typeObjects</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get terminology types from a terminology category as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>type IDs in the category. from the types found in the given terminology category </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeObjects</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>type objects in the category.. This is useful if type objects need to be retrieved for a large number of types, because it avoids the need to do a costly search in the json tree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a4ddfd395ddcd0dfd132cb34d0008e52d" name="a4ddfd395ddcd0dfd132cb34d0008e52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddfd395ddcd0dfd132cb34d0008e52d">&#9670;&#160;</a></span>GetCategoriesInTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetCategoriesInTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>categories</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get terminology categories from a terminology as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyCategory.html" title="Terminology property category object.">vtkSlicerTerminologyCategory</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">categories</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyCategory.html" title="Terminology property category object.">vtkSlicerTerminologyCategory</a> objects created from the categories found in the given terminology </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a11d92564a5ee57c511ed04eae33d7073" name="a11d92564a5ee57c511ed04eae33d7073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d92564a5ee57c511ed04eae33d7073">&#9670;&#160;</a></span>GetCategoryInTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetCategoryInTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>categoryObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a category with given name from a terminology </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">category</td><td>Output argument containing the details of the found category if any (if return value is true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a6bd46d44110fc2801e743bd144fc93a3" name="a6bd46d44110fc2801e743bd144fc93a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd46d44110fc2801e743bd144fc93a3">&#9670;&#160;</a></span>GetClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * vtkSlicerTerminologiesModuleLogic::GetClassName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#a39fa467c794d06e4194f8f72814b96bd">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="ab2e710df3207bba085c3091c4a480d9a" name="ab2e710df3207bba085c3091c4a480d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e710df3207bba085c3091c4a480d9a">&#9670;&#160;</a></span>GetCodeIdentifierFromCodedEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> vtkSlicerTerminologiesModuleLogic::GetCodeIdentifierFromCodedEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkCodedEntry.html">vtkCodedEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert terminology category, type, etc. object to code identifier. </p>

</div>
</div>
<a id="a46c20aefb4e6d80697be28e3c57c3960" name="a46c20aefb4e6d80697be28e3c57c3960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c20aefb4e6d80697be28e3c57c3960">&#9670;&#160;</a></span>GetColorAutoGeneratedAttributeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerTerminologiesModuleLogic::GetColorAutoGeneratedAttributeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Node attribute name for color auto generated. </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00070">70</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<a id="a44c5f6004c18e96b4ae6c4ab4c9db178" name="a44c5f6004c18e96b4ae6c4ab4c9db178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c5f6004c18e96b4ae6c4ab4c9db178">&#9670;&#160;</a></span>GetColorIndexByTerminology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerTerminologiesModuleLogic::GetColorIndexByTerminology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLColorNode.html">vtkMRMLColorNode</a> *</td>          <td class="paramname"><span class="paramname"><em>colorNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>terminologyStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreContextName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the first color that matches the provided terminology. For matching, the category, type, type modifier, region, region modifier codes have to be equal. Coding scheme designator and code value must match, code meaning is ignored. Terminology and region context names are taken into account depending on ignoreContextName parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorNode</td><td>The color node to search for the terminology entry. </td></tr>
    <tr><td class="paramname">terminologyStr</td><td>The string representation of the searched terminology entry. </td></tr>
    <tr><td class="paramname">ignoreContextName</td><td>Only consider the category, type, etc. coded entries if true, otherwise look for exact match in the terminology context name as well. True by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the first match in the color table, -1 if no matching color entry is found. </dd></dl>

</div>
</div>
<a id="afa11d022f52943360e959338945a6df4" name="afa11d022f52943360e959338945a6df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa11d022f52943360e959338945a6df4">&#9670;&#160;</a></span>GetCompatibleColorNodeIDs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vtkSlicerTerminologiesModuleLogic::GetCompatibleColorNodeIDs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of color node IDs that contain terminology information. </p>

</div>
</div>
<a id="ab06e45ba1fa4ba0f4f9002116d1d1982" name="ab06e45ba1fa4ba0f4f9002116d1d1982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06e45ba1fa4ba0f4f9002116d1d1982">&#9670;&#160;</a></span>GetDefaultTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTerminologiesModuleLogic::GetDefaultTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab39a19658f2476764762d2a92a6b6cc" name="aab39a19658f2476764762d2a92a6b6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab39a19658f2476764762d2a92a6b6cc">&#9670;&#160;</a></span>GetDefaultTerminologyEntryAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerTerminologiesModuleLogic::GetDefaultTerminologyEntryAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4777a88db15a5784129bf7c3e7bf953" name="aa4777a88db15a5784129bf7c3e7bf953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4777a88db15a5784129bf7c3e7bf953">&#9670;&#160;</a></span>GetDefaultTerminologyEntryAttributeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerTerminologiesModuleLogic::GetDefaultTerminologyEntryAttributeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Terminology entry (serialized to string) to be used as default when specifying terminology code for the node. It can be incomplete (e.g., it is valid to specify just the context name). </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00075">75</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<a id="a48ad1c978768e90971549b435c67969a" name="a48ad1c978768e90971549b435c67969a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ad1c978768e90971549b435c67969a">&#9670;&#160;</a></span>GetFirstCompatibleColorNodeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLColorNode.html">vtkMRMLColorNode</a> * vtkSlicerTerminologiesModuleLogic::GetFirstCompatibleColorNodeByName </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first compatible color node that has a matching name. </p>

</div>
</div>
<a id="ab33d9dfdd0a9be541e4d86d48d014d02" name="ab33d9dfdd0a9be541e4d86d48d014d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33d9dfdd0a9be541e4d86d48d014d02">&#9670;&#160;</a></span>GetInfoStringFromTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerTerminologiesModuleLogic::GetInfoStringFromTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assemble human readable info string from a terminology entry, for example for tooltips. </p>

</div>
</div>
<a id="a04fe677004299d40c3c325d34df7a9d8" name="a04fe677004299d40c3c325d34df7a9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fe677004299d40c3c325d34df7a9d8">&#9670;&#160;</a></span>GetLoadedAnatomicContextNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedAnatomicContextNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>anatomicContextNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a943d252da67eeb49d6ebb4fccaaa7e40" name="a943d252da67eeb49d6ebb4fccaaa7e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943d252da67eeb49d6ebb4fccaaa7e40">&#9670;&#160;</a></span>GetLoadedAnatomicContextNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedAnatomicContextNames </td>
          <td>(</td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>anatomicContextNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000159">Deprecated</a></b></dt><dd>Use GetLoadedRegionContextNames instead. </dd></dl>

</div>
</div>
<a id="abf454873396ff82e2bf27fb25f5f4ce1" name="abf454873396ff82e2bf27fb25f5f4ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf454873396ff82e2bf27fb25f5f4ce1">&#9670;&#160;</a></span>GetLoadedRegionContextNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedRegionContextNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regionContextNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get context names of loaded region contexts. </p>

</div>
</div>
<a id="a5988e452f67a0ce1b71253966fe99da8" name="a5988e452f67a0ce1b71253966fe99da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5988e452f67a0ce1b71253966fe99da8">&#9670;&#160;</a></span>GetLoadedRegionContextNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedRegionContextNames </td>
          <td>(</td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>regionContextNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python accessor variant of. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abf454873396ff82e2bf27fb25f5f4ce1" title="Get context names of loaded region contexts.">GetLoadedRegionContextNames</a> </dd></dl>

</div>
</div>
<a id="a9a5cb0e013f5de696e19957d42baddc5" name="a9a5cb0e013f5de696e19957d42baddc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5cb0e013f5de696e19957d42baddc5">&#9670;&#160;</a></span>GetLoadedTerminologyNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedTerminologyNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>terminologyNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get context names of loaded terminologies. </p>

</div>
</div>
<a id="a164c6462a46a449459e6bdb37f553271" name="a164c6462a46a449459e6bdb37f553271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164c6462a46a449459e6bdb37f553271">&#9670;&#160;</a></span>GetLoadedTerminologyNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::GetLoadedTerminologyNames </td>
          <td>(</td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>terminologyNames</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Python accessor variant of. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9a5cb0e013f5de696e19957d42baddc5" title="Get context names of loaded terminologies.">GetLoadedTerminologyNames</a> </dd></dl>

</div>
</div>
<a id="ac738b407a83bad73bbef08c533b7a5fb" name="ac738b407a83bad73bbef08c533b7a5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac738b407a83bad73bbef08c533b7a5fb">&#9670;&#160;</a></span>GetNameAutoGeneratedAttributeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerTerminologiesModuleLogic::GetNameAutoGeneratedAttributeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Node attribute name for name auto generated. </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00068">68</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<a id="ab08babae24673d55d906d8bed9374690" name="ab08babae24673d55d906d8bed9374690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08babae24673d55d906d8bed9374690">&#9670;&#160;</a></span>GetNthCategoryInTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthCategoryInTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>categoryIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a category from a terminology by index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">categoryIndex</td><td>specifies which category to return </td></tr>
    <tr><td class="paramname">category</td><td>category is returned in this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a592ec8b896b65d55fbc378f33dbb1c09" name="a592ec8b896b65d55fbc378f33dbb1c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592ec8b896b65d55fbc378f33dbb1c09">&#9670;&#160;</a></span>GetNthRegionInAnatomicContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthRegionInAnatomicContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regionIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000163">Deprecated</a></b></dt><dd>Use GetNthRegionInRegionContext instead. </dd></dl>

</div>
</div>
<a id="aa7a4f71cc9a2cf56874703176346e55e" name="aa7a4f71cc9a2cf56874703176346e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a4f71cc9a2cf56874703176346e55e">&#9670;&#160;</a></span>GetNthRegionInRegionContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthRegionInRegionContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regionIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get region by index. Allows iterating through all regions in Python. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionContextName</td><td>region context name </td></tr>
    <tr><td class="paramname">regionIndex</td><td>index of region to return, must be between 0 and GetNumberOfRegionsInRegionContext(...)-1 </td></tr>
    <tr><td class="paramname">regionObject</td><td>found region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="af9cfccf0af4e27c9f3366a62ad148914" name="af9cfccf0af4e27c9f3366a62ad148914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cfccf0af4e27c9f3366a62ad148914">&#9670;&#160;</a></span>GetNthRegionModifierInAnatomicRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthRegionModifierInAnatomicRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regionModifierIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000169">Deprecated</a></b></dt><dd>Use GetNthRegionModifierInRegion instead. </dd></dl>

</div>
</div>
<a id="aa386ade72c8705acafda31a566f92ae2" name="aa386ade72c8705acafda31a566f92ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa386ade72c8705acafda31a566f92ae2">&#9670;&#160;</a></span>GetNthRegionModifierInRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthRegionModifierInRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regionModifierIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get region by index. Allows iterating through region modifiers in Python. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionContextName</td><td>region context name </td></tr>
    <tr><td class="paramname">regionObject</td><td>region </td></tr>
    <tr><td class="paramname">regionModifierIndex</td><td>index of region to return, must be between 0 and GetNumberOfRegionsInRegionContext(...)-1 </td></tr>
    <tr><td class="paramname">regionModifier</td><td>found region modifier object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a451c840f29203d2be96204e800ae01f9" name="a451c840f29203d2be96204e800ae01f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451c840f29203d2be96204e800ae01f9">&#9670;&#160;</a></span>GetNthTypeInTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthTypeInTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>typeIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a terminology type by index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminologyName</td><td>input terminology name </td></tr>
    <tr><td class="paramname">category</td><td>input category </td></tr>
    <tr><td class="paramname">typeIndex</td><td>index of type to return </td></tr>
    <tr><td class="paramname">typeObject</td><td>output type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ac03a320e5d6ee935c564c4cb76239e1b" name="ac03a320e5d6ee935c564c4cb76239e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03a320e5d6ee935c564c4cb76239e1b">&#9670;&#160;</a></span>GetNthTypeModifierInTerminologyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetNthTypeModifierInTerminologyType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>typeModifierIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>typeModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a terminology type by index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminologyName</td><td>input terminology name </td></tr>
    <tr><td class="paramname">category</td><td>input category </td></tr>
    <tr><td class="paramname">typeObject</td><td>input type </td></tr>
    <tr><td class="paramname">typeModifierIndex</td><td>index of type modifier to return </td></tr>
    <tr><td class="paramname">typeModifier</td><td>output type modifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a5edda2b98f56c5f106286e3cc73815ac" name="a5edda2b98f56c5f106286e3cc73815ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edda2b98f56c5f106286e3cc73815ac">&#9670;&#160;</a></span>GetNumberOfCategoriesInTerminology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfCategoriesInTerminology </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of categories in a terminology. </p>

</div>
</div>
<a id="ae4b1bea88f1323ee71bce3e46176859e" name="ae4b1bea88f1323ee71bce3e46176859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b1bea88f1323ee71bce3e46176859e">&#9670;&#160;</a></span>GetNumberOfRegionModifierInAnatomicRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfRegionModifierInAnatomicRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000168">Deprecated</a></b></dt><dd>Use GetNumberOfRegionModifierInRegion instead. </dd></dl>

</div>
</div>
<a id="ad1d4bf31e93aac8dc58759a3aff5ffb3" name="ad1d4bf31e93aac8dc58759a3aff5ffb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d4bf31e93aac8dc58759a3aff5ffb3">&#9670;&#160;</a></span>GetNumberOfRegionModifierInRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfRegionModifierInRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of regions in region context. Allows iterating through region modifiers in Python. </p>

</div>
</div>
<a id="aba91e26e9b4c014fb551965e81b961ce" name="aba91e26e9b4c014fb551965e81b961ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba91e26e9b4c014fb551965e81b961ce">&#9670;&#160;</a></span>GetNumberOfRegionsInAnatomicContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfRegionsInAnatomicContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000162">Deprecated</a></b></dt><dd>Use GetNumberOfRegionsInRegionContext instead. </dd></dl>

</div>
</div>
<a id="a2e0a36ffb370fb64ad5a53cd539d84b6" name="a2e0a36ffb370fb64ad5a53cd539d84b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0a36ffb370fb64ad5a53cd539d84b6">&#9670;&#160;</a></span>GetNumberOfRegionsInRegionContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfRegionsInRegionContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of regions in region context. Allows iterating through all regions in Python. </p>

</div>
</div>
<a id="a31e66bf00351236b335596210069bd4a" name="a31e66bf00351236b335596210069bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e66bf00351236b335596210069bd4a">&#9670;&#160;</a></span>GetNumberOfTypeModifiersInTerminologyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfTypeModifiersInTerminologyType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of type modifiers for the chosen category and type in a terminology. </p>

</div>
</div>
<a id="a6ff1f1391f26ecac197a6ffa42057eba" name="a6ff1f1391f26ecac197a6ffa42057eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff1f1391f26ecac197a6ffa42057eba">&#9670;&#160;</a></span>GetNumberOfTypesInTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTerminologiesModuleLogic::GetNumberOfTypesInTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyCategory.html">vtkSlicerTerminologyCategory</a> *</td>          <td class="paramname"><span class="paramname"><em>category</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of types in the chosen category in a terminology. </p>

</div>
</div>
<a id="a1bbc5c3d7bd133592e82960867457a6b" name="a1bbc5c3d7bd133592e82960867457a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbc5c3d7bd133592e82960867457a6b">&#9670;&#160;</a></span>GetRegionInAnatomicContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionInAnatomicContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000165">Deprecated</a></b></dt><dd>Use GetRegionInRegionContext instead. </dd></dl>

</div>
</div>
<a id="a9a3c18a9821f276b4c839e3663293b71" name="a9a3c18a9821f276b4c839e3663293b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3c18a9821f276b4c839e3663293b71">&#9670;&#160;</a></span>GetRegionInRegionContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionInRegionContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a region with given name from a region context </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>Output argument containing the details of the found region if any (if return value is true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ae8db2e17abbe7fbd02295268e813f037" name="ae8db2e17abbe7fbd02295268e813f037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8db2e17abbe7fbd02295268e813f037">&#9670;&#160;</a></span>GetRegionModifierInAnatomicRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionModifierInAnatomicRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>modifierId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000167">Deprecated</a></b></dt><dd>Use GetRegionModifierInRegion instead. </dd></dl>

</div>
</div>
<a id="ab086138f036e99a2daf1fecdeabc1dbc" name="ab086138f036e99a2daf1fecdeabc1dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab086138f036e99a2daf1fecdeabc1dbc">&#9670;&#160;</a></span>GetRegionModifierInRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionModifierInRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>modifierId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>regionModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a region modifier with given name from a region </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionModifier</td><td>Output argument containing the details of the found region modifier if any (if return value is true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a598f5632730cca80c61c8cd8938b072b" name="a598f5632730cca80c61c8cd8938b072b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598f5632730cca80c61c8cd8938b072b">&#9670;&#160;</a></span>GetRegionModifiersInAnatomicRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionModifiersInAnatomicRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regionModifiers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000166">Deprecated</a></b></dt><dd>Use GetRegionModifiersInRegion instead. </dd></dl>

</div>
</div>
<a id="a84fcd011ac31ac14c8197a0d860d4886" name="a84fcd011ac31ac14c8197a0d860d4886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fcd011ac31ac14c8197a0d860d4886">&#9670;&#160;</a></span>GetRegionModifiersInRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionModifiersInRegion </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>regionId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regionModifiers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get region modifiers from a region as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionModifierCollection</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> objects created from the region modifiers found in the given region </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ae98307e137f32dfa83859b5cbcc1054c" name="ae98307e137f32dfa83859b5cbcc1054c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98307e137f32dfa83859b5cbcc1054c">&#9670;&#160;</a></span>GetRegionsInAnatomicContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionsInAnatomicContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>anatomicContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000161">Deprecated</a></b></dt><dd>Use GetRegionsInRegionContext instead. </dd></dl>

</div>
</div>
<a id="af57e37404012bab1eabfbbb89c20c17c" name="af57e37404012bab1eabfbbb89c20c17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57e37404012bab1eabfbbb89c20c17c">&#9670;&#160;</a></span>GetRegionsInRegionContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetRegionsInRegionContext </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get regions from an region context as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionCollection</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> objects created from the regions found in the given region context </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a00947f9ec77765be49437fb820a7a8b5" name="a00947f9ec77765be49437fb820a7a8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00947f9ec77765be49437fb820a7a8b5">&#9670;&#160;</a></span>GetTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTerminologiesModuleLogic::GetTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2145fec35c22d34906f48a3836419e2" name="ab2145fec35c22d34906f48a3836419e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2145fec35c22d34906f48a3836419e2">&#9670;&#160;</a></span>GetTerminologyEntryAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerTerminologiesModuleLogic::GetTerminologyEntryAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af435612f3023a5071bf3029ee71501ab" name="af435612f3023a5071bf3029ee71501ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af435612f3023a5071bf3029ee71501ab">&#9670;&#160;</a></span>GetTerminologyEntryAttributeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * vtkSlicerTerminologiesModuleLogic::GetTerminologyEntryAttributeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminology entry (serialized to string) </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00072">72</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<a id="acfe4bc7086a87335a55f2ed6b0dfea56" name="acfe4bc7086a87335a55f2ed6b0dfea56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe4bc7086a87335a55f2ed6b0dfea56">&#9670;&#160;</a></span>GetTypeInTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetTypeInTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>typeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>typeObject</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a type with given name from a terminology category </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Output argument containing the details of the found type if any (if return value is true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ab87ff28a1ba22c1247084c65d85a8cf2" name="ab87ff28a1ba22c1247084c65d85a8cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87ff28a1ba22c1247084c65d85a8cf2">&#9670;&#160;</a></span>GetTypeModifierInTerminologyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetTypeModifierInTerminologyType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>typeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>modifierId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyType.html">vtkSlicerTerminologyType</a> *</td>          <td class="paramname"><span class="paramname"><em>typeModifier</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a type modifier with given name from a terminology type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeModifier</td><td>Output argument containing the details of the found type modifier if any (if return value is true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a0c9ea08bd5edba94e9675b7b0068bae0" name="a0c9ea08bd5edba94e9675b7b0068bae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9ea08bd5edba94e9675b7b0068bae0">&#9670;&#160;</a></span>GetTypeModifiersInTerminologyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetTypeModifiersInTerminologyType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>typeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>typeModifiers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get terminology type modifiers from a terminology type as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeModifierCollection</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> objects created from the type modifiers found in the given terminology type </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a6c6becba475d2442aa415498ec437a1a" name="a6c6becba475d2442aa415498ec437a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6becba475d2442aa415498ec437a1a">&#9670;&#160;</a></span>GetTypesInTerminologyCategory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::GetTypesInTerminologyCategory </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>categoryId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkSlicerTerminologiesModuleLogic_1_1CodeIdentifier.html">CodeIdentifier</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get terminology types from a terminology category as collection of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> container objects </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>Output argument containing all the </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTerminologyType.html" title="Terminology property type object.">vtkSlicerTerminologyType</a> objects created from the types found in the given terminology category </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ad780abe97d96cba95725f36ef01664d1" name="ad780abe97d96cba95725f36ef01664d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad780abe97d96cba95725f36ef01664d1">&#9670;&#160;</a></span>GetUserContextsPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char * vtkSlicerTerminologiesModuleLogic::GetUserContextsPath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e615ba933505f73ac0c736640da223b" name="a7e615ba933505f73ac0c736640da223b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e615ba933505f73ac0c736640da223b">&#9670;&#160;</a></span>IsA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vtkSlicerTerminologiesModuleLogic::IsA </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#afe98b30ad85954605c2b4079d5823003">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="a58d51674705f2c3f5c637cf49f4dce43" name="a58d51674705f2c3f5c637cf49f4dce43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d51674705f2c3f5c637cf49f4dce43">&#9670;&#160;</a></span>IsTerminologyContextLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::IsTerminologyContextLoaded </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the terminology name is loaded. </p>

</div>
</div>
<a id="aedcb30ec39eaee5263e2c2bdb1c9ee91" name="aedcb30ec39eaee5263e2c2bdb1c9ee91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcb30ec39eaee5263e2c2bdb1c9ee91">&#9670;&#160;</a></span>IsTypeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerTerminologiesModuleLogic::IsTypeOf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac81a7989e6c19ed1b65049611904ace7" name="ac81a7989e6c19ed1b65049611904ace7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81a7989e6c19ed1b65049611904ace7">&#9670;&#160;</a></span>LoadAnatomicContextFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerTerminologiesModuleLogic::LoadAnatomicContextFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000158">Deprecated</a></b></dt><dd>Use LoadRegionContextFromFile instead. </dd></dl>

</div>
</div>
<a id="a17605b143864e1d4f7586c056594f97a" name="a17605b143864e1d4f7586c056594f97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17605b143864e1d4f7586c056594f97a">&#9670;&#160;</a></span>LoadAnatomicContextFromSegmentDescriptorFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::LoadAnatomicContextFromSegmentDescriptorFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>contextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad176de652c343476b647f88f7dceac69" name="ad176de652c343476b647f88f7dceac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad176de652c343476b647f88f7dceac69">&#9670;&#160;</a></span>LoadContextFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::LoadContextFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load terminology or region context from JSON file. Note: Separate generic loader function was created so that the file does not need to be loaded twice in case the type of the context in the JSON file is not known </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>File containing the context to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="ad3ddf18b5d025bac974476fdb10903ac" name="ad3ddf18b5d025bac974476fdb10903ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ddf18b5d025bac974476fdb10903ac">&#9670;&#160;</a></span>LoadDefaultRegionContexts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::LoadDefaultRegionContexts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load default region context dictionaries from JSON into. </p>
<dl class="section see"><dt>See also</dt><dd>LoadedRegionContexts </dd></dl>

</div>
</div>
<a id="afd690b1b6fdaee7f9e6d95b453d35cca" name="afd690b1b6fdaee7f9e6d95b453d35cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd690b1b6fdaee7f9e6d95b453d35cca">&#9670;&#160;</a></span>LoadDefaultTerminologies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::LoadDefaultTerminologies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load default terminology dictionaries from JSON into. </p>
<dl class="section see"><dt>See also</dt><dd>LoadedTerminologies </dd></dl>

</div>
</div>
<a id="ab3a0ac96db93c3249b626ed679f2451e" name="ab3a0ac96db93c3249b626ed679f2451e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a0ac96db93c3249b626ed679f2451e">&#9670;&#160;</a></span>LoadRegionContextFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerTerminologiesModuleLogic::LoadRegionContextFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load region context dictionaries from JSON into </p><dl class="section see"><dt>See also</dt><dd>LoadedRegionContexts </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>File containing the region context to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Context name (RegionContextName) of the loaded region context. Empty string on failure. </dd></dl>

</div>
</div>
<a id="abc5db67c52718f85f7def095cdbbecc4" name="abc5db67c52718f85f7def095cdbbecc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5db67c52718f85f7def095cdbbecc4">&#9670;&#160;</a></span>LoadRegionContextFromSegmentDescriptorFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::LoadRegionContextFromSegmentDescriptorFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>contextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load region context dictionary from segmentation descriptor JSON file into </p><dl class="section see"><dt>See also</dt><dd>LoadedRegionContexts. See also </dd>
<dd>
<a class="el" href="#aea6b4c23a5b4ac7591bcd8bfe96828f0">LoadTerminologyFromSegmentDescriptorFile</a> </dd></dl>

</div>
</div>
<a id="a82a3fb7d3022cc6a95f24767b3c1f737" name="a82a3fb7d3022cc6a95f24767b3c1f737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a3fb7d3022cc6a95f24767b3c1f737">&#9670;&#160;</a></span>LoadTerminologyFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerTerminologiesModuleLogic::LoadTerminologyFromFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load terminology dictionary from JSON terminology context file into </p><dl class="section see"><dt>See also</dt><dd>LoadedTerminologies. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePath</td><td>File containing the terminology to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Context name (SegmentationCategoryTypeContextName) of the loaded terminology. Empty string on failure. </dd></dl>

</div>
</div>
<a id="aea6b4c23a5b4ac7591bcd8bfe96828f0" name="aea6b4c23a5b4ac7591bcd8bfe96828f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b4c23a5b4ac7591bcd8bfe96828f0">&#9670;&#160;</a></span>LoadTerminologyFromSegmentDescriptorFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::LoadTerminologyFromSegmentDescriptorFile </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>contextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load terminology dictionary from segmentation descriptor JSON file into </p><dl class="section see"><dt>See also</dt><dd>LoadedTerminologies. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Terminology</td><td>context name (the descriptor file does not contain information about that) </td></tr>
    <tr><td class="paramname">filePath</td><td>File containing the terminology to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success flag </dd></dl>

</div>
</div>
<a id="a7b6d2a0158d27f6b5bfeea63cea377be" name="a7b6d2a0158d27f6b5bfeea63cea377be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6d2a0158d27f6b5bfeea63cea377be">&#9670;&#160;</a></span>LoadUserContexts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::LoadUserContexts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load terminologies and region contexts from the user settings directory. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a113954f0eb61c73d3b84865cee602891" title="The path from which the json files are automatically loaded on startup.">UserContextsPath</a> </dd></dl>

</div>
</div>
<a id="a1d0433a4b9b5c8ce73ddd3796f6a57bb" name="a1d0433a4b9b5c8ce73ddd3796f6a57bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0433a4b9b5c8ce73ddd3796f6a57bb">&#9670;&#160;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic.html">vtkSlicerTerminologiesModuleLogic</a> * vtkSlicerTerminologiesModuleLogic::New </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a36ad0b1856262205283334c898b4d1" name="a1a36ad0b1856262205283334c898b4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a36ad0b1856262205283334c898b4d1">&#9670;&#160;</a></span>PrintSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::PrintSelf </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIndent</td>          <td class="paramname"><span class="paramname"><em>indent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa811066fc06ce9b8f720f3bc56767e85" name="aa811066fc06ce9b8f720f3bc56767e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa811066fc06ce9b8f720f3bc56767e85">&#9670;&#160;</a></span>SafeDownCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTerminologiesModuleLogic.html">vtkSlicerTerminologiesModuleLogic</a> * vtkSlicerTerminologiesModuleLogic::SafeDownCast </td>
          <td>(</td>
          <td class="paramtype">vtkObject *</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a220071f0dbfb814492c46df4ab63ba8e" name="a220071f0dbfb814492c46df4ab63ba8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220071f0dbfb814492c46df4ab63ba8e">&#9670;&#160;</a></span>SerializeTerminologyEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerTerminologiesModuleLogic::SerializeTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>terminologyContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categorySchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>categoryMeaning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>typeMeaning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>modifierValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>modifierSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>modifierMeaning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionContextName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionMeaning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierSchemeDesignator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>regionModifierMeaning</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assemble terminology string from terminology codes The serialized string will have the following format: "terminologyContextName~" "categorySchemeDesignator^categoryValue^categoryMeaning~" "typeSchemeDesignator^typeValue^typeMeaning~" "modifierSchemeDesignator^modifierValue^modifierMeaning~" "regionContextName~" "regionSchemeDesignator^regionValue^regionMeaning~" "regionModifierSchemeDesignator^regionModifierValue^regionModifierMeaning" Note: The order of the attributes are inconsistent with the codes used in this class for compatibility reasons (to vtkMRMLColorLogic::AddTermToTerminology) </p>

</div>
</div>
<a id="a174464662bc5b962174617f2eb572068" name="a174464662bc5b962174617f2eb572068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174464662bc5b962174617f2eb572068">&#9670;&#160;</a></span>SerializeTerminologyEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string vtkSlicerTerminologiesModuleLogic::SerializeTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert terminology entry VTK object to string containing identifiers Serialized terminology entry consists of the following: terminologyContextName, category (codingScheme, codeValue, codeMeaning triple), type, typeModifier, regionContextName, region, regionModifier </p>

</div>
</div>
<a id="a36573f2662248ab00e2a08c71c796c6f" name="a36573f2662248ab00e2a08c71c796c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36573f2662248ab00e2a08c71c796c6f">&#9670;&#160;</a></span>SetDefaultTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTerminologiesModuleLogic::SetDefaultTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4df44051d575e239445883a0439bafe" name="ad4df44051d575e239445883a0439bafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4df44051d575e239445883a0439bafe">&#9670;&#160;</a></span>SetDefaultTerminologyEntryAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTerminologiesModuleLogic::SetDefaultTerminologyEntryAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>entryStr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac155960ee7db47f5ec7cf42fb1b608e9" name="ac155960ee7db47f5ec7cf42fb1b608e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155960ee7db47f5ec7cf42fb1b608e9">&#9670;&#160;</a></span>SetMRMLSceneInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTerminologiesModuleLogic::SetMRMLSceneInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>newScene</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called each time a new scene is set. Can be reimplemented in derived classes. Doesn't observe the scene by default, that means that <a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene()</a> won't be called by default when a scene is imported, closed or restored, only when a new scene is set. </p><dl class="section see"><dt>See also</dt><dd>SetAndObserveMRMLSceneInternal() <a class="el" href="classvtkMRMLAbstractLogic.html#ac028eafed3ee93b9b3741f57139132d3">SetAndObserveMRMLSceneEventsInternal()</a> </dd>
<dd>
<a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a8a1dc1c9192488743cbb0289d3f03600">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a1f7777a50a1673123d0b492c378f998d" name="a1f7777a50a1673123d0b492c378f998d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7777a50a1673123d0b492c378f998d">&#9670;&#160;</a></span>SetTerminologyEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTerminologiesModuleLogic::SetTerminologyEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acee486e8d5331ec0904f873ce5bd1ce0" name="acee486e8d5331ec0904f873ce5bd1ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee486e8d5331ec0904f873ce5bd1ce0">&#9670;&#160;</a></span>SetTerminologyEntryAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTerminologiesModuleLogic::SetTerminologyEntryAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>entryStr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c2699af889f09d0b0df7201f3504570" name="a8c2699af889f09d0b0df7201f3504570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2699af889f09d0b0df7201f3504570">&#9670;&#160;</a></span>SetUserContextsPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vtkSlicerTerminologiesModuleLogic::SetUserContextsPath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2614ac5f7a27934259ddc09bf7d7373b" name="a2614ac5f7a27934259ddc09bf7d7373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2614ac5f7a27934259ddc09bf7d7373b">&#9670;&#160;</a></span>UpdateEntryFromLoadedTerminologies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerTerminologiesModuleLogic::UpdateEntryFromLoadedTerminologies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkSlicerTerminologyEntry.html">vtkSlicerTerminologyEntry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredTerminologyNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>preferredRegionContextNames</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get metadata (such as recommended color) from loaded terminologies. The entry will be first searched in the terminology context that is specified in the entry, if not found then it is searched in all the other loaded terminology contexts. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a969cb5fb8171d059c79ae0954c80dc09" name="a969cb5fb8171d059c79ae0954c80dc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969cb5fb8171d059c79ae0954c80dc09">&#9670;&#160;</a></span>vtkInternal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class vtkInternal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00450">450</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a113954f0eb61c73d3b84865cee602891" name="a113954f0eb61c73d3b84865cee602891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113954f0eb61c73d3b84865cee602891">&#9670;&#160;</a></span>UserContextsPath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* vtkSlicerTerminologiesModuleLogic::UserContextsPath {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The path from which the json files are automatically loaded on startup. </p>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html#l00442">442</a> of file <a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Modules/Loadable/Terminologies/Logic/<a class="el" href="vtkSlicerTerminologiesModuleLogic_8h_source.html">vtkSlicerTerminologiesModuleLogic.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 27 2025 19:45:47 for Slicer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
