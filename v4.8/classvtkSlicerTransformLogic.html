<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer: vtkSlicerTransformLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="3DSlicer-DesktopIcon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slicer
   &#160;<span id="projectnumber">4.8</span>
   </div>
   <div id="projectbrief">Slicer is a multi-platform, free and open source software package for visualization and medical image computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classvtkSlicerTransformLogic-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vtkSlicerTransformLogic Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vtkSlicerTransformLogic_8h_source.html">Modules/Loadable/Transforms/Logic/vtkSlicerTransformLogic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vtkSlicerTransformLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerTransformLogic__inherit__graph.png" border="0" usemap="#vtkSlicerTransformLogic_inherit__map" alt="Inheritance graph"/></div>
<map name="vtkSlicerTransformLogic_inherit__map" id="vtkSlicerTransformLogic_inherit__map">
<area shape="rect" id="node2" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes. " alt="" coords="9,80,174,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vtkSlicerTransformLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerTransformLogic__coll__graph.png" border="0" usemap="#vtkSlicerTransformLogic_coll__map" alt="Collaboration graph"/></div>
<map name="vtkSlicerTransformLogic_coll__map" id="vtkSlicerTransformLogic_coll__map">
<area shape="rect" id="node2" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes. " alt="" coords="9,80,174,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abd7b9cc1e7a1e420766196f630a64ccd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#abd7b9cc1e7a1e420766196f630a64ccd">Superclass</a></td></tr>
<tr class="separator:abd7b9cc1e7a1e420766196f630a64ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9165bc03d2fa12b9d5a675afcd47f88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88">TransformKind</a> { <br />
&#160;&#160;<a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88a3c887f1148610f29d5bd1fb7b486f321">TRANSFORM_OTHER</a>, 
<a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88aab27a20bf6d4ff3f00413cc2f9d72c7b">TRANSFORM_LINEAR</a>, 
<a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88acb2d87281ec50134b0a213b633870936">TRANSFORM_BSPLINE</a>, 
<a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88a6326a1027d0d9bc69609e62f1ff2f350">TRANSFORM_GRID</a>, 
<br />
&#160;&#160;<a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88a39a6ad6a355f57615a4b5757419f523e">TRANSFORM_THINPLATESPLINE</a>
<br />
 }</td></tr>
<tr class="separator:ab9165bc03d2fa12b9d5a675afcd47f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">typedef vtkObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab2fef06324d2444212855c6ed44e3ead">Superclass</a></td></tr>
<tr class="separator:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">typedef void(vtkMRMLAbstractLogic::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aaa2c5b4f57066c706fd86982299adbde">TaskFunctionPointer</a>) (void *clientdata)</td></tr>
<tr class="separator:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e8aa932026a2d779ca7d9aa17d59959"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a4e8aa932026a2d779ca7d9aa17d59959">AddTransform</a> (const char *filename, <a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene)</td></tr>
<tr class="memdesc:a4e8aa932026a2d779ca7d9aa17d59959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read transform from file.  <a href="#a4e8aa932026a2d779ca7d9aa17d59959">More...</a><br /></td></tr>
<tr class="separator:a4e8aa932026a2d779ca7d9aa17d59959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f219310170c682e12588db53f324548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a0f219310170c682e12588db53f324548">ConvertToGridTransform</a> (<a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=NULL, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *existingOutputTransformNode=NULL)</td></tr>
<tr class="separator:a0f219310170c682e12588db53f324548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0817332ae2d76f1542995e33486530ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a0817332ae2d76f1542995e33486530ca">CreateDisplacementVolumeFromTransform</a> (<a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *referenceVolumeNode=NULL, bool magnitude=true, <a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *existingOutputVolumeNode=NULL)</td></tr>
<tr class="separator:a0817332ae2d76f1542995e33486530ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dfc6ffaafb45e27c1969e290ea1cb9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a55dfc6ffaafb45e27c1969e290ea1cb9">GetClassName</a> ()</td></tr>
<tr class="separator:a55dfc6ffaafb45e27c1969e290ea1cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2033b5d1b11bb17453f431074320e3d2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a2033b5d1b11bb17453f431074320e3d2">IsA</a> (const char *type)</td></tr>
<tr class="separator:a2033b5d1b11bb17453f431074320e3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682ee887baafeceed4dbb924809a3945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a682ee887baafeceed4dbb924809a3945">PrintSelf</a> (ostream &amp;os, vtkIndent indent) VTK_OVERRIDE</td></tr>
<tr class="separator:a682ee887baafeceed4dbb924809a3945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5995eee748b0be599aead29dedc9d987"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a5995eee748b0be599aead29dedc9d987">SaveTransform</a> (const char *filename, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *transformNode)</td></tr>
<tr class="memdesc:a5995eee748b0be599aead29dedc9d987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write transform's data to a specified file.  <a href="#a5995eee748b0be599aead29dedc9d987">More...</a><br /></td></tr>
<tr class="separator:a5995eee748b0be599aead29dedc9d987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab3d98bd9070b6f3eb3cc9aba0c5f35e5 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab3d98bd9070b6f3eb3cc9aba0c5f35e5">GetMRMLApplicationLogic</a> () const</td></tr>
<tr class="memdesc:ab3d98bd9070b6f3eb3cc9aba0c5f35e5 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <a href="classvtkMRMLAbstractLogic.html#ab3d98bd9070b6f3eb3cc9aba0c5f35e5">More...</a><br /></td></tr>
<tr class="separator:ab3d98bd9070b6f3eb3cc9aba0c5f35e5 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa26c7a75a5cd67b1849315793c34d1 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acfa26c7a75a5cd67b1849315793c34d1">GetMRMLScene</a> () const</td></tr>
<tr class="memdesc:acfa26c7a75a5cd67b1849315793c34d1 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the current MRML scene.  <a href="classvtkMRMLAbstractLogic.html#acfa26c7a75a5cd67b1849315793c34d1">More...</a><br /></td></tr>
<tr class="separator:acfa26c7a75a5cd67b1849315793c34d1 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54eb26da0a3a863be025333c66e76f2 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab54eb26da0a3a863be025333c66e76f2">PrintSelf</a> (ostream &amp;os, vtkIndent indent) VTK_OVERRIDE</td></tr>
<tr class="separator:ab54eb26da0a3a863be025333c66e76f2 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a95af27a03775e432e2e9a4ffa0681a8c">SetMRMLApplicationLogic</a> (<a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *logic)</td></tr>
<tr class="separator:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51f4149e574bb15f5d082dc93c07543e">SetMRMLScene</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene)</td></tr>
<tr class="memdesc:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and observe the MRMLScene.  <a href="classvtkMRMLAbstractLogic.html#a51f4149e574bb15f5d082dc93c07543e">More...</a><br /></td></tr>
<tr class="separator:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2d970b8097a3f845c420b78977e8973"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ad2d970b8097a3f845c420b78977e8973">GetNodesBounds</a> (const std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;nodes, double bounds[6])</td></tr>
<tr class="separator:ad2d970b8097a3f845c420b78977e8973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b3ca9b7861df345b269d25490edb9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a24b3ca9b7861df345b269d25490edb9b">GetNodesRASBounds</a> (const std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;nodes, double bounds[6])</td></tr>
<tr class="separator:a24b3ca9b7861df345b269d25490edb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c17f765a2d09123d64f0e7e9ade7a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a30c17f765a2d09123d64f0e7e9ade7a1">GetTransformedNodes</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *transformNode, std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;transformedNodes, bool recursive=true)</td></tr>
<tr class="separator:a30c17f765a2d09123d64f0e7e9ade7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e3c74f7107cfac5317e20f01896e8e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a18e3c74f7107cfac5317e20f01896e8e">GetTransformedPointSamplesAsMagnitudeImage</a> (vtkImageData *outputMagnitudeImage, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkMatrix4x4 *ijkToRAS, bool transformToWorld=true)</td></tr>
<tr class="separator:a18e3c74f7107cfac5317e20f01896e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c78620ecacbd945d6104f7f0e0dbb1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ad1c78620ecacbd945d6104f7f0e0dbb1">GetTransformedPointSamplesAsVectorImage</a> (vtkImageData *outputVectorImage, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkMatrix4x4 *ijkToRAS, bool transformToWorld=true)</td></tr>
<tr class="separator:ad1c78620ecacbd945d6104f7f0e0dbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846e5f8f894c1083d9c37cc256fd2063"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88">TransformKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a846e5f8f894c1083d9c37cc256fd2063">GetTransformKind</a> (<a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *transformNode)</td></tr>
<tr class="separator:a846e5f8f894c1083d9c37cc256fd2063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3600532db537b99fc394e453e0e57d15"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a3600532db537b99fc394e453e0e57d15">GetVisualization2d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, <a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *sliceNode, <a class="el" href="classvtkMRMLMarkupsFiducialNode.html">vtkMRMLMarkupsFiducialNode</a> *glyphPointsNode=NULL)</td></tr>
<tr class="separator:a3600532db537b99fc394e453e0e57d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd58eb3c45ba5123a88c37736640b64"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a8cd58eb3c45ba5123a88c37736640b64">GetVisualization2d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *sliceToRAS, double *fieldOfViewOrigin, double *fieldOfViewSize, vtkPoints *samplePositions_RAS=NULL)</td></tr>
<tr class="separator:a8cd58eb3c45ba5123a88c37736640b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6b92a9cca3ab3988667001ef3ebca"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a29f6b92a9cca3ab3988667001ef3ebca">GetVisualization3d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *roiToRAS, int *roiSize, vtkPoints *samplePositions_RAS=NULL)</td></tr>
<tr class="separator:a29f6b92a9cca3ab3988667001ef3ebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f175531c9033ee3503f79639abc27f4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a4f175531c9033ee3503f79639abc27f4">GetVisualization3d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, <a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *regionNode)</td></tr>
<tr class="separator:a4f175531c9033ee3503f79639abc27f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b00f0a7c9ece9fa4e186e8e10a1dc4"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ad3b00f0a7c9ece9fa4e186e8e10a1dc4">GetVisualizationDisplacementMagnitudeScalarName</a> ()</td></tr>
<tr class="separator:ad3b00f0a7c9ece9fa4e186e8e10a1dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79efff7832998f4a1633561ddcfbd960"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a79efff7832998f4a1633561ddcfbd960">hardenTransform</a> (<a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *node)</td></tr>
<tr class="separator:a79efff7832998f4a1633561ddcfbd960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d23eb07984980df08b6c9ad7683317c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a2d23eb07984980df08b6c9ad7683317c">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a2d23eb07984980df08b6c9ad7683317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064d4feac94f50ede575c543e06f97cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a064d4feac94f50ede575c543e06f97cd">New</a> ()</td></tr>
<tr class="memdesc:a064d4feac94f50ede575c543e06f97cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Usual vtk class functions.  <a href="#a064d4feac94f50ede575c543e06f97cd">More...</a><br /></td></tr>
<tr class="separator:a064d4feac94f50ede575c543e06f97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7dcc5ff02605c5bdded7b1c31347b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a9b7dcc5ff02605c5bdded7b1c31347b2">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a9b7dcc5ff02605c5bdded7b1c31347b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a466db0b62e33aa0f80d0fe720c1a6213">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4217bfdd6c56505ef1d45e31b5d1e0c inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aa4217bfdd6c56505ef1d45e31b5d1e0c">New</a> ()</td></tr>
<tr class="separator:aa4217bfdd6c56505ef1d45e31b5d1e0c inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ee20fe6e4fc2931471d8e7d7d29fe2 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aa2ee20fe6e4fc2931471d8e7d7d29fe2">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:aa2ee20fe6e4fc2931471d8e7d7d29fe2 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae833c166757079f08a526db14fbcb34a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ae833c166757079f08a526db14fbcb34a">operator=</a> (const <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> &amp;)</td></tr>
<tr class="separator:ae833c166757079f08a526db14fbcb34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99fd4a59ca1a92dfdc898765cc5e183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ab99fd4a59ca1a92dfdc898765cc5e183">vtkSlicerTransformLogic</a> ()</td></tr>
<tr class="separator:ab99fd4a59ca1a92dfdc898765cc5e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331db8e33f572e2e46715325495ef0d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a331db8e33f572e2e46715325495ef0d9">vtkSlicerTransformLogic</a> (const <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> &amp;)</td></tr>
<tr class="separator:a331db8e33f572e2e46715325495ef0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaac3b5bae59342787bbbb190c53b76"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#aaaaac3b5bae59342787bbbb190c53b76">~vtkSlicerTransformLogic</a> ()</td></tr>
<tr class="separator:aaaaac3b5bae59342787bbbb190c53b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab5b1ee240252dfd245fc01f8eb53e8e9">EndModify</a> (bool wasModifying)</td></tr>
<tr class="separator:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a471bd7df7caef325291e5e683e42796c">EnterMRMLLogicsCallback</a> () const</td></tr>
<tr class="separator:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aeb78c60e083bcbb907f81f136e53364e">EnterMRMLNodesCallback</a> () const</td></tr>
<tr class="separator:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a57c1538abccd8fc920b20d7f277f9ad3">EnterMRMLSceneCallback</a> () const</td></tr>
<tr class="separator:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5d7c3aabe26766856b040937db55141d">GetDisableModifiedEvent</a> () const</td></tr>
<tr class="separator:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#add020efdf3ea303c860c06218e7bd0ce">GetInMRMLLogicsCallbackFlag</a> () const</td></tr>
<tr class="separator:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ad43b978b6997abd9211e873107fbb99b">GetInMRMLNodesCallbackFlag</a> () const</td></tr>
<tr class="separator:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2c912757bd1e2fb9ed18531772d9b7c2">GetInMRMLSceneCallbackFlag</a> () const</td></tr>
<tr class="separator:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4af5555574859232fb620ea61437e9c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac4af5555574859232fb620ea61437e9c">GetMRMLLogicsCallbackCommand</a> ()</td></tr>
<tr class="separator:ac4af5555574859232fb620ea61437e9c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb7edac12d17844ddaddd840e71f153 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a9cb7edac12d17844ddaddd840e71f153">GetMRMLLogicsObserverManager</a> () const</td></tr>
<tr class="separator:a9cb7edac12d17844ddaddd840e71f153 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d317321e65adef502ca443ef22235dc inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a9d317321e65adef502ca443ef22235dc">GetMRMLNodesCallbackCommand</a> ()</td></tr>
<tr class="separator:a9d317321e65adef502ca443ef22235dc inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da47bbf91e13da036f9c62087621837 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3da47bbf91e13da036f9c62087621837">GetMRMLNodesObserverManager</a> () const</td></tr>
<tr class="separator:a3da47bbf91e13da036f9c62087621837 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c40ce4e4bd3861a4437d0109bc3152e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a6c40ce4e4bd3861a4437d0109bc3152e">GetMRMLSceneCallbackCommand</a> ()</td></tr>
<tr class="separator:a6c40ce4e4bd3861a4437d0109bc3152e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8c94bb7283130fc8541eaa2e9c7338 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a0c8c94bb7283130fc8541eaa2e9c7338">GetMRMLSceneObserverManager</a> () const</td></tr>
<tr class="separator:a0c8c94bb7283130fc8541eaa2e9c7338 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abcbd9db7caad7038b170c95a3398d237">GetPendingModifiedEventCount</a> () const</td></tr>
<tr class="separator:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a040a2e3a82ac8a72ea06450c78001db1">GetProcessingMRMLSceneEvent</a> () const</td></tr>
<tr class="memdesc:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the event id currently processed or 0 if any.  <a href="classvtkMRMLAbstractLogic.html#a040a2e3a82ac8a72ea06450c78001db1">More...</a><br /></td></tr>
<tr class="separator:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adbdafafc00fbfca72832bf573b4e53fd">InvokePendingModifiedEvent</a> ()</td></tr>
<tr class="separator:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af683dde980b980c4480f109a9e4fa8d2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af683dde980b980c4480f109a9e4fa8d2">Modified</a> () VTK_OVERRIDE</td></tr>
<tr class="separator:af683dde980b980c4480f109a9e4fa8d2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abeec5de56ddcf3ed8206ed1fa388c364">ObserveMRMLScene</a> ()</td></tr>
<tr class="separator:abeec5de56ddcf3ed8206ed1fa388c364 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a124e968e51a99e4dc16d022b3fd37e2e">OnMRMLNodeModified</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac1a782799e284bd04ea5182b1e41dc93">OnMRMLSceneEndBatchProcess</a> ()</td></tr>
<tr class="separator:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5f8a69a47eacec0cd95857beceb8eb34">OnMRMLSceneEndClose</a> ()</td></tr>
<tr class="separator:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ae826dc18ec31156f0eae3456608eb1c4">OnMRMLSceneEndImport</a> ()</td></tr>
<tr class="separator:ae826dc18ec31156f0eae3456608eb1c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3e1d4144d47f125c71a36c88c4289e1">OnMRMLSceneEndRestore</a> ()</td></tr>
<tr class="separator:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac9c4356c3ad53f529f948214d5ce30f1">OnMRMLSceneNew</a> ()</td></tr>
<tr class="separator:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0102310f18a3880f00e93b8e37210c9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac0102310f18a3880f00e93b8e37210c9">OnMRMLSceneNodeAdded</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:ac0102310f18a3880f00e93b8e37210c9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a92b1149d08ec5099a9ec61c0636f37c4">OnMRMLSceneNodeRemoved</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a92b1149d08ec5099a9ec61c0636f37c4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#afc31c1f6a54e4dabf14f1ae3fe3c47df">OnMRMLSceneStartBatchProcess</a> ()</td></tr>
<tr class="separator:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a063cceb9c914333b8fd076ff5c0f6a30">OnMRMLSceneStartClose</a> ()</td></tr>
<tr class="separator:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a048ce8ed9409c07be134bcd03ae27184">OnMRMLSceneStartImport</a> ()</td></tr>
<tr class="separator:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aebe17bd4344f7c85c653d10631d6aa30">OnMRMLSceneStartRestore</a> ()</td></tr>
<tr class="separator:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adac3d2b2ec84f30d78d3a6c8d8aeb828">ProcessMRMLLogicsEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a43a759874ce32846c6dffc52e5941744">ProcessMRMLNodesEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a43a759874ce32846c6dffc52e5941744 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7f65f53d5fbe6d056e7cf32a23058 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acfa7f65f53d5fbe6d056e7cf32a23058">RegisterNodes</a> ()</td></tr>
<tr class="separator:acfa7f65f53d5fbe6d056e7cf32a23058 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca59112f803abd13733f86bf605ea83 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3ca59112f803abd13733f86bf605ea83">SetAndObserveMRMLSceneEventsInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene, vtkIntArray *events, vtkFloatArray *priorities=0)</td></tr>
<tr class="separator:a3ca59112f803abd13733f86bf605ea83 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3eb7d963472fa9fd4eb83d8a6ee33ccd">SetDisableModifiedEvent</a> (bool onOff)</td></tr>
<tr class="separator:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac4b6e57c0562f3e41a92372cca661e65">SetInMRMLLogicsCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4836d6eb665c483236232345eccb9833">SetInMRMLNodesCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acf80dc501f04df6b0d0db5095d63e042">SetInMRMLSceneCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1dc1c9192488743cbb0289d3f03600 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a8a1dc1c9192488743cbb0289d3f03600">SetMRMLSceneInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene)</td></tr>
<tr class="separator:a8a1dc1c9192488743cbb0289d3f03600 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3b03cb0ee8830fc953868266b62df44">SetProcessingMRMLSceneEvent</a> (int event)</td></tr>
<tr class="separator:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aca82fcc8ec42d9976a29b0acf9ba27a4">StartModify</a> ()</td></tr>
<tr class="separator:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a> ()</td></tr>
<tr class="separator:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">UpdateFromMRMLScene</a> ()</td></tr>
<tr class="separator:a50caeb3a373ccd53635ae2c08bc2e63e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3440792dbe0d54de16de57eac139bb34">vtkMRMLAbstractLogic</a> ()</td></tr>
<tr class="separator:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e35c6110dc0156b5827948b45ee08 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a9d9e35c6110dc0156b5827948b45ee08">~vtkMRMLAbstractLogic</a> ()</td></tr>
<tr class="separator:a9d9e35c6110dc0156b5827948b45ee08 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a0178941df6ac0faee006bcbdb63d65e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a0178941df6ac0faee006bcbdb63d65e2">CreateGrid</a> (vtkPolyData *outputGrid_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, int numGridPoints[3], vtkPolyData *outputWarpedGrid_RAS=NULL)</td></tr>
<tr class="memdesc:a0178941df6ac0faee006bcbdb63d65e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add lines to the gridPolyData to make it a grid. If warpedGrid is specified then a warped grid is generated, too.  <a href="#a0178941df6ac0faee006bcbdb63d65e2">More...</a><br /></td></tr>
<tr class="separator:a0178941df6ac0faee006bcbdb63d65e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f87dc49a8c68933097b363f3cc91c0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a4f87dc49a8c68933097b363f3cc91c0f">GetContourVisualization2d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *sliceToRAS, double *fieldOfViewOrigin, double *fieldOfViewSize)</td></tr>
<tr class="separator:a4f87dc49a8c68933097b363f3cc91c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef263f0a93c9a47559506d1437e8aaf4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#aef263f0a93c9a47559506d1437e8aaf4">GetContourVisualization3d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *roiToRAS, int *roiSize)</td></tr>
<tr class="separator:aef263f0a93c9a47559506d1437e8aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d8bf832899608a491e2dc0b0fb0057"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ab5d8bf832899608a491e2dc0b0fb0057">GetGlyphVisualization2d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *sliceToRAS, double *fieldOfViewOrigin, double *fieldOfViewSize, vtkPoints *samplePositions_RAS=NULL)</td></tr>
<tr class="separator:ab5d8bf832899608a491e2dc0b0fb0057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b9d003ba3c2317ee9a85252ce30b47"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a42b9d003ba3c2317ee9a85252ce30b47">GetGlyphVisualization3d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *roiToRAS, int *roiSize, vtkPoints *samplePositions_RAS=NULL)</td></tr>
<tr class="separator:a42b9d003ba3c2317ee9a85252ce30b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded530e510f49f194bde88be53c8238"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a2ded530e510f49f194bde88be53c8238">GetGridSubdivision</a> (<a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode)</td></tr>
<tr class="memdesc:a2ded530e510f49f194bde88be53c8238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of samples in each grid.  <a href="#a2ded530e510f49f194bde88be53c8238">More...</a><br /></td></tr>
<tr class="separator:a2ded530e510f49f194bde88be53c8238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8212972491bc2d2cec80e8494f48800"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#ac8212972491bc2d2cec80e8494f48800">GetGridVisualization2d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *sliceToRAS, double *fieldOfViewOrigin, double *fieldOfViewSize)</td></tr>
<tr class="separator:ac8212972491bc2d2cec80e8494f48800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110afcfc1ba922159637bc30d9f0989c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a110afcfc1ba922159637bc30d9f0989c">GetGridVisualization3d</a> (vtkPolyData *output_RAS, <a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *displayNode, vtkMatrix4x4 *roiToRAS, int *roiSize)</td></tr>
<tr class="separator:a110afcfc1ba922159637bc30d9f0989c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe051cf8ce8b5ea3d1d2d8261f332d26"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#afe051cf8ce8b5ea3d1d2d8261f332d26">GetMarkupsAsPoints</a> (<a class="el" href="classvtkMRMLMarkupsFiducialNode.html">vtkMRMLMarkupsFiducialNode</a> *markupsNode, vtkPoints *samplePoints_RAS)</td></tr>
<tr class="memdesc:afe051cf8ce8b5ea3d1d2d8261f332d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get markup points as vtkPoints in RAS coordinate system.  <a href="#afe051cf8ce8b5ea3d1d2d8261f332d26">More...</a><br /></td></tr>
<tr class="separator:afe051cf8ce8b5ea3d1d2d8261f332d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2615798366e66701ddad3c0895a881d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#aa2615798366e66701ddad3c0895a881d">GetTransformedPointSamples</a> (vtkPointSet *outputPointSet, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkPoints *samplePositions_RAS, bool transformToWorld=true)</td></tr>
<tr class="separator:aa2615798366e66701ddad3c0895a881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bd74f3a57b18b2bd31010e2b7d1939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a12bd74f3a57b18b2bd31010e2b7d1939">GetTransformedPointSamples</a> (vtkPointSet *outputPointSet_RAS, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkMatrix4x4 *gridToRAS, int *gridSize, bool transformToWorld=true)</td></tr>
<tr class="separator:a12bd74f3a57b18b2bd31010e2b7d1939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4dbb9c623c819f1248d45797269f88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#a4f4dbb9c623c819f1248d45797269f88">GetTransformedPointSamplesOnRoi</a> (vtkPointSet *outputPointSet_RAS, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkMatrix4x4 *roiToRAS, int *roiSize, double pointSpacingMm, int pointGroupSize=1, int *numGridPoints=0)</td></tr>
<tr class="separator:a4f4dbb9c623c819f1248d45797269f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1cd327e218d822676310515f3bef2a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerTransformLogic.html#aad1cd327e218d822676310515f3bef2a">GetTransformedPointSamplesOnSlice</a> (vtkPointSet *outputPointSet_RAS, <a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *inputTransformNode, vtkMatrix4x4 *sliceToRAS, double *fieldOfViewOrigin, double *fieldOfViewSize, double pointSpacing, int pointGroupSize=1, int *numGridPoints=0, vtkPoints *samplePositions_RAS=NULL)</td></tr>
<tr class="separator:aad1cd327e218d822676310515f3bef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5af15efe0f8421ef6de4f3168830e3f7">MRMLLogicsCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLLogicCallback is a static function to relay modified events from the logics.  <a href="classvtkMRMLAbstractLogic.html#a5af15efe0f8421ef6de4f3168830e3f7">More...</a><br /></td></tr>
<tr class="separator:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5b796a7ccecd251cdb83874b390c4e43">MRMLNodesCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLNodesCallback is a static function to relay modified events from the nodes.  <a href="classvtkMRMLAbstractLogic.html#a5b796a7ccecd251cdb83874b390c4e43">More...</a><br /></td></tr>
<tr class="separator:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af4a68e64a0ca65a9efb92d717f3a7896">MRMLSceneCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="separator:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="vtkSlicerTransformLogic_8h_source.html#l00052">52</a> of file <a class="el" href="vtkSlicerTransformLogic_8h_source.html">vtkSlicerTransformLogic.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abd7b9cc1e7a1e420766196f630a64ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b9cc1e7a1e420766196f630a64ccd">&#9670;&nbsp;</a></span>Superclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> <a class="el" href="classvtkSlicerTransformLogic.html#abd7b9cc1e7a1e420766196f630a64ccd">vtkSlicerTransformLogic::Superclass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerTransformLogic_8h_source.html#l00058">58</a> of file <a class="el" href="vtkSlicerTransformLogic_8h_source.html">vtkSlicerTransformLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab9165bc03d2fa12b9d5a675afcd47f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9165bc03d2fa12b9d5a675afcd47f88">&#9670;&nbsp;</a></span>TransformKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88">vtkSlicerTransformLogic::TransformKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9165bc03d2fa12b9d5a675afcd47f88a3c887f1148610f29d5bd1fb7b486f321"></a>TRANSFORM_OTHER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab9165bc03d2fa12b9d5a675afcd47f88aab27a20bf6d4ff3f00413cc2f9d72c7b"></a>TRANSFORM_LINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab9165bc03d2fa12b9d5a675afcd47f88acb2d87281ec50134b0a213b633870936"></a>TRANSFORM_BSPLINE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab9165bc03d2fa12b9d5a675afcd47f88a6326a1027d0d9bc69609e62f1ff2f350"></a>TRANSFORM_GRID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab9165bc03d2fa12b9d5a675afcd47f88a39a6ad6a355f57615a4b5757419f523e"></a>TRANSFORM_THINPLATESPLINE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vtkSlicerTransformLogic_8h_source.html#l00158">158</a> of file <a class="el" href="vtkSlicerTransformLogic_8h_source.html">vtkSlicerTransformLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab99fd4a59ca1a92dfdc898765cc5e183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99fd4a59ca1a92dfdc898765cc5e183">&#9670;&nbsp;</a></span>vtkSlicerTransformLogic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerTransformLogic::vtkSlicerTransformLogic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaaac3b5bae59342787bbbb190c53b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaac3b5bae59342787bbbb190c53b76">&#9670;&nbsp;</a></span>~vtkSlicerTransformLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual vtkSlicerTransformLogic::~vtkSlicerTransformLogic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a331db8e33f572e2e46715325495ef0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331db8e33f572e2e46715325495ef0d9">&#9670;&nbsp;</a></span>vtkSlicerTransformLogic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerTransformLogic::vtkSlicerTransformLogic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4e8aa932026a2d779ca7d9aa17d59959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8aa932026a2d779ca7d9aa17d59959">&#9670;&nbsp;</a></span>AddTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a>* vtkSlicerTransformLogic::AddTransform </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td>
          <td class="paramname"><em>scene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read transform from file. </p>

</div>
</div>
<a id="a0f219310170c682e12588db53f324548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f219310170c682e12588db53f324548">&#9670;&nbsp;</a></span>ConvertToGridTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a>* vtkSlicerTransformLogic::ConvertToGridTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *&#160;</td>
          <td class="paramname"><em>referenceVolumeNode</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>existingOutputTransformNode</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the input transform to a grid transform. If referenceVolumeNode is specified then it will determine the origin, spacing, extent, and orientation of the displacement field. If existingOutputTransformNode is specified then instead of creating a new transform node, that existing node will be updated. </p>

</div>
</div>
<a id="a0817332ae2d76f1542995e33486530ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0817332ae2d76f1542995e33486530ca">&#9670;&nbsp;</a></span>CreateDisplacementVolumeFromTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a>* vtkSlicerTransformLogic::CreateDisplacementVolumeFromTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *&#160;</td>
          <td class="paramname"><em>referenceVolumeNode</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>magnitude</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLVolumeNode.html">vtkMRMLVolumeNode</a> *&#160;</td>
          <td class="paramname"><em>existingOutputVolumeNode</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a volume node that contains the transform displacement in each voxel. If magnitude is true then a scalar volume is created, each voxel containing the magnitude of the displacement. If magnitude is false then a 3-component scalar volume is created, each voxel containing the displacement vector. referenceVolumeNode specifies the volume origin, spacing, extent, and orientation. If existingOutputVolumeNode is specified then instead of creating a new volume node, that existing node will be updated. </p>

</div>
</div>
<a id="a0178941df6ac0faee006bcbdb63d65e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0178941df6ac0faee006bcbdb63d65e2">&#9670;&nbsp;</a></span>CreateGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::CreateGrid </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>outputGrid_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numGridPoints</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>outputWarpedGrid_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add lines to the gridPolyData to make it a grid. If warpedGrid is specified then a warped grid is generated, too. </p>

</div>
</div>
<a id="a55dfc6ffaafb45e27c1969e290ea1cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dfc6ffaafb45e27c1969e290ea1cb9">&#9670;&nbsp;</a></span>GetClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* vtkSlicerTransformLogic::GetClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a162f2a1e4a98bbdc470b31145190c4da">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a4f87dc49a8c68933097b363f3cc91c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87dc49a8c68933097b363f3cc91c0f">&#9670;&nbsp;</a></span>GetContourVisualization2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetContourVisualization2d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>sliceToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate contours for 2D transform visualization </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a3600532db537b99fc394e453e0e57d15">GetVisualization2d</a> </dd></dl>

</div>
</div>
<a id="aef263f0a93c9a47559506d1437e8aaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef263f0a93c9a47559506d1437e8aaf4">&#9670;&nbsp;</a></span>GetContourVisualization3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetContourVisualization3d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>roiToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>roiSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate contours for 3D transform visualization </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a29f6b92a9cca3ab3988667001ef3ebca">GetVisualization3d</a> </dd></dl>

</div>
</div>
<a id="ab5d8bf832899608a491e2dc0b0fb0057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d8bf832899608a491e2dc0b0fb0057">&#9670;&nbsp;</a></span>GetGlyphVisualization2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetGlyphVisualization2d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>sliceToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate glyph for 2D transform visualization If samplePositions_RAS is specified then those samples will be used as glyph starting points instead of a regular grid. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a3600532db537b99fc394e453e0e57d15">GetVisualization2d</a> </dd></dl>

</div>
</div>
<a id="a42b9d003ba3c2317ee9a85252ce30b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b9d003ba3c2317ee9a85252ce30b47">&#9670;&nbsp;</a></span>GetGlyphVisualization3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetGlyphVisualization3d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>roiToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>roiSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate glyph for 3D transform visualization If samplePositions_RAS is specified then those samples will be used as glyph starting points instead of a regular grid. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a29f6b92a9cca3ab3988667001ef3ebca">GetVisualization3d</a> </dd></dl>

</div>
</div>
<a id="a2ded530e510f49f194bde88be53c8238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ded530e510f49f194bde88be53c8238">&#9670;&nbsp;</a></span>GetGridSubdivision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerTransformLogic::GetGridSubdivision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of samples in each grid. </p>

</div>
</div>
<a id="ac8212972491bc2d2cec80e8494f48800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8212972491bc2d2cec80e8494f48800">&#9670;&nbsp;</a></span>GetGridVisualization2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetGridVisualization2d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>sliceToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate grid for 2D transform visualization </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a3600532db537b99fc394e453e0e57d15">GetVisualization2d</a> </dd></dl>

</div>
</div>
<a id="a110afcfc1ba922159637bc30d9f0989c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110afcfc1ba922159637bc30d9f0989c">&#9670;&nbsp;</a></span>GetGridVisualization3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetGridVisualization3d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>roiToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>roiSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate grid for 3D transform visualization </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a29f6b92a9cca3ab3988667001ef3ebca">GetVisualization3d</a> </dd></dl>

</div>
</div>
<a id="afe051cf8ce8b5ea3d1d2d8261f332d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe051cf8ce8b5ea3d1d2d8261f332d26">&#9670;&nbsp;</a></span>GetMarkupsAsPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetMarkupsAsPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsFiducialNode.html">vtkMRMLMarkupsFiducialNode</a> *&#160;</td>
          <td class="paramname"><em>markupsNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePoints_RAS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get markup points as vtkPoints in RAS coordinate system. </p>

</div>
</div>
<a id="ad2d970b8097a3f845c420b78977e8973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d970b8097a3f845c420b78977e8973">&#9670;&nbsp;</a></span>GetNodesBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetNodesBounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bounds</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the bounding box around the list of given nodes using GetBounds. Only the nodes with a valid bounding box are taken into account. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#a24b3ca9b7861df345b269d25490edb9b">GetNodesRASBounds()</a> </dd></dl>

</div>
</div>
<a id="a24b3ca9b7861df345b269d25490edb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b3ca9b7861df345b269d25490edb9b">&#9670;&nbsp;</a></span>GetNodesRASBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetNodesRASBounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bounds</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the RAS bounding box around the list of given nodes using GetRASBounds. Only the nodes with a valid bounding box are taken into account. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkSlicerTransformLogic.html#ad2d970b8097a3f845c420b78977e8973">GetNodesBounds()</a> </dd></dl>

</div>
</div>
<a id="a30c17f765a2d09123d64f0e7e9ade7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c17f765a2d09123d64f0e7e9ade7a1">&#9670;&nbsp;</a></span>GetTransformedNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetTransformedNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>transformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvtkMRMLDisplayableNode.html">vtkMRMLDisplayableNode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>transformedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the list of nodes that are transformed by the given node. If recursive is True, this be recursively called on any transform node that might be transformed by the given node. Otherwise, only the nodes immediately transformed by the given transform are returned. </p>

</div>
</div>
<a id="aa2615798366e66701ddad3c0895a881d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2615798366e66701ddad3c0895a881d">&#9670;&nbsp;</a></span>GetTransformedPointSamples() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetTransformedPointSamples </td>
          <td>(</td>
          <td class="paramtype">vtkPointSet *&#160;</td>
          <td class="paramname"><em>outputPointSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transformToWorld</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes samples from the displacement field specified by a point set and stores it in an unstructured grid. If transformToWorld is true then transform to world is returned, otherwise transform from world is returned. </p>

</div>
</div>
<a id="a12bd74f3a57b18b2bd31010e2b7d1939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bd74f3a57b18b2bd31010e2b7d1939">&#9670;&nbsp;</a></span>GetTransformedPointSamples() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetTransformedPointSamples </td>
          <td>(</td>
          <td class="paramtype">vtkPointSet *&#160;</td>
          <td class="paramname"><em>outputPointSet_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>gridToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transformToWorld</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes samples from the displacement field specified by the transformation on a uniform grid and stores it in an unstructured grid. gridToRAS specifies the grid origin, direction, and spacing gridSize is a 3-component int array specifying the dimension of the grid If transformToWorld is true then transform to world is returned, otherwise transform from world is returned. </p>

</div>
</div>
<a id="a18e3c74f7107cfac5317e20f01896e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e3c74f7107cfac5317e20f01896e8e">&#9670;&nbsp;</a></span>GetTransformedPointSamplesAsMagnitudeImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetTransformedPointSamplesAsMagnitudeImage </td>
          <td>(</td>
          <td class="paramtype">vtkImageData *&#160;</td>
          <td class="paramname"><em>outputMagnitudeImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>ijkToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transformToWorld</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take samples from the displacement field and store the magnitude in an image volume The extents of the output image must be set before calling this method. The origin and spacing attributes of the output image are ignored (origin, spacing, and axis directions are all specified by ijkToRAS). If transformToWorld is true then transform to world is returned, otherwise transform from world is returned. Returns true on success. </p>

</div>
</div>
<a id="ad1c78620ecacbd945d6104f7f0e0dbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c78620ecacbd945d6104f7f0e0dbb1">&#9670;&nbsp;</a></span>GetTransformedPointSamplesAsVectorImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetTransformedPointSamplesAsVectorImage </td>
          <td>(</td>
          <td class="paramtype">vtkImageData *&#160;</td>
          <td class="paramname"><em>outputVectorImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>ijkToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transformToWorld</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take samples from the displacement field and store the vector components in an image volume The extents of the output image must be set before calling this method. The origin and spacing attributes of the output image are ignored (origin, spacing, and axis directions are all specified by ijkToRAS). If transformToWorld is true then transform to world is returned, otherwise transform from world is returned. Returns true on success. </p>

</div>
</div>
<a id="a4f4dbb9c623c819f1248d45797269f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4dbb9c623c819f1248d45797269f88">&#9670;&nbsp;</a></span>GetTransformedPointSamplesOnRoi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetTransformedPointSamplesOnRoi </td>
          <td>(</td>
          <td class="paramtype">vtkPointSet *&#160;</td>
          <td class="paramname"><em>outputPointSet_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>roiToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>roiSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pointSpacingMm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointGroupSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numGridPoints</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes samples from the displacement field specified by the transformation on a 3D ROI and stores it in an unstructured grid. pointGroupSize: the number of points will be N*pointGroupSize (the actual number will be returned in numGridPoints[3]) </p>

</div>
</div>
<a id="aad1cd327e218d822676310515f3bef2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1cd327e218d822676310515f3bef2a">&#9670;&nbsp;</a></span>GetTransformedPointSamplesOnSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vtkSlicerTransformLogic::GetTransformedPointSamplesOnSlice </td>
          <td>(</td>
          <td class="paramtype">vtkPointSet *&#160;</td>
          <td class="paramname"><em>outputPointSet_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>inputTransformNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>sliceToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pointSpacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointGroupSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numGridPoints</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes samples from the displacement field specified by the transformation on a slice and stores it in an unstructured grid. pointGroupSize: the number of points will be N*pointGroupSize (the actual number will be returned in numGridPoints[3]) samplePositions_RAS: if specified then instead of a regular grid, sample points on the slice will be used </p>

</div>
</div>
<a id="a846e5f8f894c1083d9c37cc256fd2063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846e5f8f894c1083d9c37cc256fd2063">&#9670;&nbsp;</a></span>GetTransformKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTransformLogic.html#ab9165bc03d2fa12b9d5a675afcd47f88">TransformKind</a> vtkSlicerTransformLogic::GetTransformKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>transformNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns TRANSFORM_LINEAR if the node contains a simple linear transform. Returns TRANSFORM_BSPLINE if the node contains a bspline transform with an optional additive or composite bulk component. Returns TRANSFORM_GRID if the node contains a simple grid transform. Returns TRANSFORM_THINPLATESPLINE if the node contains a simple thin plate spline transform. Returns TRANSFORM_OTHER in all other cases. </p>

</div>
</div>
<a id="a3600532db537b99fc394e453e0e57d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3600532db537b99fc394e453e0e57d15">&#9670;&nbsp;</a></span>GetVisualization2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetVisualization2d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *&#160;</td>
          <td class="paramname"><em>sliceNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsFiducialNode.html">vtkMRMLMarkupsFiducialNode</a> *&#160;</td>
          <td class="paramname"><em>glyphPointsNode</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate polydata for 2D transform visualization Return true on success. </p>

</div>
</div>
<a id="a8cd58eb3c45ba5123a88c37736640b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd58eb3c45ba5123a88c37736640b64">&#9670;&nbsp;</a></span>GetVisualization2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetVisualization2d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>sliceToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fieldOfViewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate polydata for 2D transform visualization Return true on success. </p>

</div>
</div>
<a id="a29f6b92a9cca3ab3988667001ef3ebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f6b92a9cca3ab3988667001ef3ebca">&#9670;&nbsp;</a></span>GetVisualization3d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetVisualization3d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkMatrix4x4 *&#160;</td>
          <td class="paramname"><em>roiToRAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>roiSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPoints *&#160;</td>
          <td class="paramname"><em>samplePositions_RAS</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate polydata for 3D transform visualization roiToRAS defines the ROI origin and direction. roiSize defines the ROI size (in the ROI coordinate system spacing) . Return true on success. </p>

</div>
</div>
<a id="a4f175531c9033ee3503f79639abc27f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f175531c9033ee3503f79639abc27f4">&#9670;&nbsp;</a></span>GetVisualization3d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::GetVisualization3d </td>
          <td>(</td>
          <td class="paramtype">vtkPolyData *&#160;</td>
          <td class="paramname"><em>output_RAS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformDisplayNode.html">vtkMRMLTransformDisplayNode</a> *&#160;</td>
          <td class="paramname"><em>displayNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *&#160;</td>
          <td class="paramname"><em>regionNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate polydata for 3D transform visualization Region node can be slice (<a class="el" href="classvtkMRMLSliceNode.html" title="MRML node for storing a slice through RAS space. ">vtkMRMLSliceNode</a>), volume (<a class="el" href="classvtkMRMLVolumeNode.html" title="MRML node for representing a volume (image stack). ">vtkMRMLVolumeNode</a>), region of interest (<a class="el" href="classvtkMRMLAnnotationROINode.html">vtkMRMLAnnotationROINode</a>), or model (<a class="el" href="classvtkMRMLModelNode.html" title="MRML node to represent a 3D surface model. ">vtkMRMLModelNode</a>). Return true on success. </p>

</div>
</div>
<a id="ad3b00f0a7c9ece9fa4e186e8e10a1dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b00f0a7c9ece9fa4e186e8e10a1dc4">&#9670;&nbsp;</a></span>GetVisualizationDisplacementMagnitudeScalarName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* vtkSlicerTransformLogic::GetVisualizationDisplacementMagnitudeScalarName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Name of the scalar array that stores the displacement magnitude values in polydata returned by GetVisualization2d and GetVisualization3d. </p>

</div>
</div>
<a id="a79efff7832998f4a1633561ddcfbd960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79efff7832998f4a1633561ddcfbd960">&#9670;&nbsp;</a></span>hardenTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerTransformLogic::hardenTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformableNode.html">vtkMRMLTransformableNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the associated transform to the transformable node. Return true on success, false otherwise. This method is kept for backward compatibility only, it is recommended to use <a class="el" href="classvtkMRMLTransformableNode.html#a1e1b5b0059e2eea22224b243492bdc5c">vtkMRMLTransformableNode::HardenTransform()</a> method instead. </p>

</div>
</div>
<a id="a2033b5d1b11bb17453f431074320e3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2033b5d1b11bb17453f431074320e3d2">&#9670;&nbsp;</a></span>IsA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vtkSlicerTransformLogic::IsA </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a0375e81924831645641a9e80ab6860a9">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a2d23eb07984980df08b6c9ad7683317c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d23eb07984980df08b6c9ad7683317c">&#9670;&nbsp;</a></span>IsTypeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerTransformLogic::IsTypeOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a064d4feac94f50ede575c543e06f97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064d4feac94f50ede575c543e06f97cd">&#9670;&nbsp;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a>* vtkSlicerTransformLogic::New </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Usual vtk class functions. </p>

</div>
</div>
<a id="ae833c166757079f08a526db14fbcb34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae833c166757079f08a526db14fbcb34a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTransformLogic::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a682ee887baafeceed4dbb924809a3945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682ee887baafeceed4dbb924809a3945">&#9670;&nbsp;</a></span>PrintSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerTransformLogic::PrintSelf </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIndent&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerTransformLogic_8h_source.html#l00059">59</a> of file <a class="el" href="vtkSlicerTransformLogic_8h_source.html">vtkSlicerTransformLogic.h</a>.</p>

</div>
</div>
<a id="a9b7dcc5ff02605c5bdded7b1c31347b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7dcc5ff02605c5bdded7b1c31347b2">&#9670;&nbsp;</a></span>SafeDownCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerTransformLogic.html">vtkSlicerTransformLogic</a>* vtkSlicerTransformLogic::SafeDownCast </td>
          <td>(</td>
          <td class="paramtype">vtkObject *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5995eee748b0be599aead29dedc9d987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5995eee748b0be599aead29dedc9d987">&#9670;&nbsp;</a></span>SaveTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerTransformLogic::SaveTransform </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTransformNode.html">vtkMRMLTransformNode</a> *&#160;</td>
          <td class="paramname"><em>transformNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write transform's data to a specified file. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Modules/Loadable/Transforms/Logic/<a class="el" href="vtkSlicerTransformLogic_8h_source.html">vtkSlicerTransformLogic.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 20 2017 04:49:17 for Slicer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
