<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer: vtkSlicerMarkupsLogic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="3DSlicer-DesktopIcon.png"/></td>
  <td id="projectalign">
   <div id="projectname">Slicer<span id="projectnumber">&#160;5.6</span>
   </div>
   <div id="projectbrief">Slicer is a multi-platform, free and open source software package for visualization and medical image computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classvtkSlicerMarkupsLogic-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">vtkSlicerMarkupsLogic Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">Modules/Loadable/Markups/Logic/vtkSlicerMarkupsLogic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vtkSlicerMarkupsLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerMarkupsLogic__inherit__graph.png" border="0" usemap="#avtkSlicerMarkupsLogic_inherit__map" alt="Inheritance graph"/></div>
<map name="avtkSlicerMarkupsLogic_inherit__map" id="avtkSlicerMarkupsLogic_inherit__map">
<area shape="rect" title=" " alt="" coords="7,225,175,251"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="11,152,172,177"/>
<area shape="poly" title=" " alt="" coords="94,191,94,225,89,225,89,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="5,79,177,104"/>
<area shape="poly" title=" " alt="" coords="94,118,94,152,89,152,89,118"/>
<area shape="rect" title=" " alt="" coords="49,5,134,31"/>
<area shape="poly" title=" " alt="" coords="94,44,94,79,89,79,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for vtkSlicerMarkupsLogic:</div>
<div class="dyncontent">
<div class="center"><img src="classvtkSlicerMarkupsLogic__coll__graph.png" border="0" usemap="#avtkSlicerMarkupsLogic_coll__map" alt="Collaboration graph"/></div>
<map name="avtkSlicerMarkupsLogic_coll__map" id="avtkSlicerMarkupsLogic_coll__map">
<area shape="rect" title=" " alt="" coords="7,225,175,251"/>
<area shape="rect" href="classvtkSlicerModuleLogic.html" title=" " alt="" coords="11,152,172,177"/>
<area shape="poly" title=" " alt="" coords="94,191,94,225,89,225,89,191"/>
<area shape="rect" href="classvtkMRMLAbstractLogic.html" title="Superclass for MRML logic classes." alt="" coords="5,79,177,104"/>
<area shape="poly" title=" " alt="" coords="94,118,94,152,89,152,89,118"/>
<area shape="rect" title=" " alt="" coords="49,5,134,31"/>
<area shape="poly" title=" " alt="" coords="94,44,94,79,89,79,89,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a3174a5ef78ddafe4d0378f561e6fa1" id="r_a2a3174a5ef78ddafe4d0378f561e6fa1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#a2a3174a5ef78ddafe4d0378f561e6fa1a9a214c9035c53b40cbdc82f32e29a57d">AnnotationNone</a> = 0
, <a class="el" href="#a2a3174a5ef78ddafe4d0378f561e6fa1a962fed1bc18da4a328a6a9958807e574">AnnotationFiducial</a>
, <a class="el" href="#a2a3174a5ef78ddafe4d0378f561e6fa1aa3491bf4ff90c9966499417ff2885122">AnnotationRuler</a>
, <a class="el" href="#a2a3174a5ef78ddafe4d0378f561e6fa1a249b695efa71d4059ecabe890225cf23">AnnotationROI</a>
 }</td></tr>
<tr class="memdesc:a2a3174a5ef78ddafe4d0378f561e6fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration listing valid annotation file types to load using LoadAnnotation.  <a href="#a2a3174a5ef78ddafe4d0378f561e6fa1">More...</a><br /></td></tr>
<tr class="separator:a2a3174a5ef78ddafe4d0378f561e6fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e18b1e6c786f797118aa763fb02183" id="r_ad1e18b1e6c786f797118aa763fb02183"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e18b1e6c786f797118aa763fb02183">Events</a> { <a class="el" href="#ad1e18b1e6c786f797118aa763fb02183a99a4987366c42a19f6904accf8c0d6b9">MarkupRegistered</a> = vtkCommand::UserEvent + 1
, <a class="el" href="#ad1e18b1e6c786f797118aa763fb02183a2b0dab5b25a58235ffbdd4078f020059">MarkupUnregistered</a>
 }</td></tr>
<tr class="separator:ad1e18b1e6c786f797118aa763fb02183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce008dac54eba491106254caef64a8" id="r_a24ce008dac54eba491106254caef64a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ce008dac54eba491106254caef64a8">Superclass</a></td></tr>
<tr class="separator:a24ce008dac54eba491106254caef64a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic" id="r_a85b117de65a91398ccf70ccfc2edc275"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a85b117de65a91398ccf70ccfc2edc275">Superclass</a></td></tr>
<tr class="separator:a85b117de65a91398ccf70ccfc2edc275 inherit pub_types_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic" id="r_ab2fef06324d2444212855c6ed44e3ead"><td class="memItemLeft" align="right" valign="top">typedef vtkObject&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab2fef06324d2444212855c6ed44e3ead">Superclass</a></td></tr>
<tr class="separator:ab2fef06324d2444212855c6ed44e3ead inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic" id="r_aaa2c5b4f57066c706fd86982299adbde"><td class="memItemLeft" align="right" valign="top">typedef void(vtkMRMLAbstractLogic::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aaa2c5b4f57066c706fd86982299adbde">TaskFunctionPointer</a>) (void *clientdata)</td></tr>
<tr class="separator:aaa2c5b4f57066c706fd86982299adbde inherit pub_types_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac095cc6c3c798e686acd2240663779a1" id="r_ac095cc6c3c798e686acd2240663779a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac095cc6c3c798e686acd2240663779a1">AddControlPoint</a> (double r=0.0, double a=0.0, double s=0.0)</td></tr>
<tr class="separator:ac095cc6c3c798e686acd2240663779a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8811cfed179d6a8ad26007792e970d9e" id="r_a8811cfed179d6a8ad26007792e970d9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8811cfed179d6a8ad26007792e970d9e">AddFiducial</a> (double r=0.0, double a=0.0, double s=0.0)</td></tr>
<tr class="separator:a8811cfed179d6a8ad26007792e970d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0448556b30d403f2446cde597d4534d9" id="r_a0448556b30d403f2446cde597d4534d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0448556b30d403f2446cde597d4534d9">AddNewDisplayNodeForMarkupsNode</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *mrmlNode)</td></tr>
<tr class="separator:a0448556b30d403f2446cde597d4534d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5593a4290d58f1e3cb35a58246e320d0" id="r_a5593a4290d58f1e3cb35a58246e320d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5593a4290d58f1e3cb35a58246e320d0">AddNewFiducialNode</a> (const char *name=&quot;F&quot;, <a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene=nullptr)</td></tr>
<tr class="separator:a5593a4290d58f1e3cb35a58246e320d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa1d9aca55f3353ac3136c35e00501" id="r_a8cfa1d9aca55f3353ac3136c35e00501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLMarkupsJsonStorageNode.html">vtkMRMLMarkupsJsonStorageNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cfa1d9aca55f3353ac3136c35e00501">AddNewJsonStorageNodeForMarkupsType</a> (std::string markupsType)</td></tr>
<tr class="separator:a8cfa1d9aca55f3353ac3136c35e00501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7101431f676e6de543311cd2e8dd130" id="r_aa7101431f676e6de543311cd2e8dd130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7101431f676e6de543311cd2e8dd130">AddNewMarkupsNode</a> (std::string className, std::string nodeName=std::string(), <a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene=nullptr)</td></tr>
<tr class="separator:aa7101431f676e6de543311cd2e8dd130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7269312c53d06d64d9ff141bee2e6579" id="r_a7269312c53d06d64d9ff141bee2e6579"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7269312c53d06d64d9ff141bee2e6579">AutoCreateDisplayNodesOff</a> ()</td></tr>
<tr class="separator:a7269312c53d06d64d9ff141bee2e6579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dfe658b0df5b5174dddecef02a8b1f" id="r_a50dfe658b0df5b5174dddecef02a8b1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50dfe658b0df5b5174dddecef02a8b1f">AutoCreateDisplayNodesOn</a> ()</td></tr>
<tr class="separator:a50dfe658b0df5b5174dddecef02a8b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92e60c09368971921101445e221441b" id="r_af92e60c09368971921101445e221441b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92e60c09368971921101445e221441b">ConvertAnnotationFiducialsToMarkups</a> (vtkStringArray *addedNodeIds=nullptr, vtkStringArray *removedNodeIds=nullptr)</td></tr>
<tr class="separator:af92e60c09368971921101445e221441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0084607aaf3288f2f6f59a75a06995" id="r_adc0084607aaf3288f2f6f59a75a06995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc0084607aaf3288f2f6f59a75a06995">ConvertAnnotationHierarchyToSubjectHierarchy</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *scene)</td></tr>
<tr class="separator:adc0084607aaf3288f2f6f59a75a06995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4f2f60d18585c0c6ffe536c5de7f5b" id="r_a4d4f2f60d18585c0c6ffe536c5de7f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d4f2f60d18585c0c6ffe536c5de7f5b">ConvertAnnotationLinesROIsToMarkups</a> (vtkStringArray *addedNodeIds=nullptr, vtkStringArray *removedNodeIds=nullptr)</td></tr>
<tr class="separator:a4d4f2f60d18585c0c6ffe536c5de7f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf584e9ec0fc85285035db04d05259b4" id="r_abf584e9ec0fc85285035db04d05259b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf584e9ec0fc85285035db04d05259b4">CopyBasicDisplayProperties</a> (<a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *sourceDisplayNode, <a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *targetDisplayNode)</td></tr>
<tr class="separator:abf584e9ec0fc85285035db04d05259b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a1e419cb84efc4fb25408ab5afc1a" id="r_afa8a1e419cb84efc4fb25408ab5afc1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8a1e419cb84efc4fb25408ab5afc1a">CopyNthControlPointToNewList</a> (int n, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *newMarkupsNode)</td></tr>
<tr class="separator:afa8a1e419cb84efc4fb25408ab5afc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac34364b28afcbc90e9ee5167612cc4" id="r_a0ac34364b28afcbc90e9ee5167612cc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ac34364b28afcbc90e9ee5167612cc4">CopyNthMarkupToNewList</a> (int n, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *newMarkupsNode)</td></tr>
<tr class="separator:a0ac34364b28afcbc90e9ee5167612cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec532fe4585cf2e9d1ed5249865bbe" id="r_a04ec532fe4585cf2e9d1ed5249865bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04ec532fe4585cf2e9d1ed5249865bbe">FocusCameraOnNthPointInMarkup</a> (const char *cameraNodeID, const char *markupNodeID, int n)</td></tr>
<tr class="separator:a04ec532fe4585cf2e9d1ed5249865bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6ce5efb61834acdd6a7225f09b2630" id="r_a2a6ce5efb61834acdd6a7225f09b2630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6ce5efb61834acdd6a7225f09b2630">FocusCamerasOnNthPointInMarkup</a> (const char *id, int n)</td></tr>
<tr class="separator:a2a6ce5efb61834acdd6a7225f09b2630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab146c7f6a950d64a0e0b21797497bd" id="r_a1ab146c7f6a950d64a0e0b21797497bd"><td class="memItemLeft" align="right" valign="top">vtkVector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ab146c7f6a950d64a0e0b21797497bd">GenerateUniqueColor</a> ()</td></tr>
<tr class="separator:a1ab146c7f6a950d64a0e0b21797497bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d6334c8700514bca3ecfea9ab9024d" id="r_aa8d6334c8700514bca3ecfea9ab9024d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8d6334c8700514bca3ecfea9ab9024d">GenerateUniqueColor</a> (double color[3])</td></tr>
<tr class="separator:aa8d6334c8700514bca3ecfea9ab9024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b4aef2d9033de20078fd411d0bddc6" id="r_a16b4aef2d9033de20078fd411d0bddc6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16b4aef2d9033de20078fd411d0bddc6">GetActiveListID</a> ()</td></tr>
<tr class="separator:a16b4aef2d9033de20078fd411d0bddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaf67b5884b36fab6de306a902b7e00" id="r_a7aaf67b5884b36fab6de306a902b7e00"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aaf67b5884b36fab6de306a902b7e00">GetAutoCreateDisplayNodes</a> ()</td></tr>
<tr class="separator:a7aaf67b5884b36fab6de306a902b7e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824279b9f4a9994cd4c9c298ae851828" id="r_a824279b9f4a9994cd4c9c298ae851828"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a824279b9f4a9994cd4c9c298ae851828">GetClassName</a> ()</td></tr>
<tr class="separator:a824279b9f4a9994cd4c9c298ae851828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8e1d840b63dc7399ee9768ee0408c0" id="r_adc8e1d840b63dc7399ee9768ee0408c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc8e1d840b63dc7399ee9768ee0408c0">GetCreateMarkupsPushButton</a> (const char *markupName) const</td></tr>
<tr class="memdesc:adc8e1d840b63dc7399ee9768ee0408c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the flags that indicates whether the GUI push button should be created.  <br /></td></tr>
<tr class="separator:adc8e1d840b63dc7399ee9768ee0408c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc6aa463c8cdac37210baa708fda97" id="r_a4ecc6aa463c8cdac37210baa708fda97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ecc6aa463c8cdac37210baa708fda97">GetDefaultMarkupsDisplayNode</a> ()</td></tr>
<tr class="separator:a4ecc6aa463c8cdac37210baa708fda97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36728dbc0ca3ef932a0684cc6dfba23b" id="r_a36728dbc0ca3ef932a0684cc6dfba23b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36728dbc0ca3ef932a0684cc6dfba23b">GetJsonStorageNodeClassNameForMarkupsType</a> (std::string markupsType)</td></tr>
<tr class="separator:a36728dbc0ca3ef932a0684cc6dfba23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2414374a924b963ce03c56753d0450" id="r_a9b2414374a924b963ce03c56753d0450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2414374a924b963ce03c56753d0450">GetNodeByMarkupsType</a> (const char *markupsType) const</td></tr>
<tr class="separator:a9b2414374a924b963ce03c56753d0450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae759f47605030c3389e4444821427382" id="r_ae759f47605030c3389e4444821427382"><td class="memItemLeft" align="right" valign="top">const std::list&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae759f47605030c3389e4444821427382">GetRegisteredMarkupsTypes</a> () const</td></tr>
<tr class="memdesc:ae759f47605030c3389e4444821427382"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the list of the markups registered in the logic.  <br /></td></tr>
<tr class="separator:ae759f47605030c3389e4444821427382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6464fe068112a3b9e2edea051f4ee0e3" id="r_a6464fe068112a3b9e2edea051f4ee0e3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6464fe068112a3b9e2edea051f4ee0e3">GetSelectionNodeID</a> ()</td></tr>
<tr class="separator:a6464fe068112a3b9e2edea051f4ee0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c557417ac21c7500202e418b09cd4" id="r_aa86c557417ac21c7500202e418b09cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkSlicerMarkupsWidget.html">vtkSlicerMarkupsWidget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa86c557417ac21c7500202e418b09cd4">GetWidgetByMarkupsType</a> (const char *markupsType) const</td></tr>
<tr class="separator:aa86c557417ac21c7500202e418b09cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af967f6cfe6caed926fde6a24ee6a3a71" id="r_af967f6cfe6caed926fde6a24ee6a3a71"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af967f6cfe6caed926fde6a24ee6a3a71">IsA</a> (const char *type)</td></tr>
<tr class="separator:af967f6cfe6caed926fde6a24ee6a3a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9f73a6d39a63106964c6b5df3e9cbb" id="r_a8e9f73a6d39a63106964c6b5df3e9cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e9f73a6d39a63106964c6b5df3e9cbb">IsMarkupsNodeRegistered</a> (const char *nodeType) const</td></tr>
<tr class="separator:a8e9f73a6d39a63106964c6b5df3e9cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856997f13f6a12f60c2c9e730e2a9fce" id="r_a856997f13f6a12f60c2c9e730e2a9fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a856997f13f6a12f60c2c9e730e2a9fce">JumpSlicesToLocation</a> (double x, double y, double z, bool centered, int viewGroup=-1, <a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *exclude=nullptr)</td></tr>
<tr class="separator:a856997f13f6a12f60c2c9e730e2a9fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41df76ffe605b8d05e254d8a6de0debc" id="r_a41df76ffe605b8d05e254d8a6de0debc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41df76ffe605b8d05e254d8a6de0debc">JumpSlicesToNthPointInMarkup</a> (const char *id, int n, bool centered=false, int viewGroup=-1, <a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *exclude=nullptr)</td></tr>
<tr class="separator:a41df76ffe605b8d05e254d8a6de0debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d22fc821fe3d5e0ccc2a7fcaaa505d" id="r_a88d22fc821fe3d5e0ccc2a7fcaaa505d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88d22fc821fe3d5e0ccc2a7fcaaa505d">LoadAnnotation</a> (const char *filename, const char *name, int annotationFileType)</td></tr>
<tr class="separator:a88d22fc821fe3d5e0ccc2a7fcaaa505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9792d6d7b5687cc7955ba1e176262f9c" id="r_a9792d6d7b5687cc7955ba1e176262f9c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9792d6d7b5687cc7955ba1e176262f9c">LoadMarkups</a> (const char *fileName, const char *fidsName=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:a9792d6d7b5687cc7955ba1e176262f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7292c875559c2a6b4057875191dab6c" id="r_ac7292c875559c2a6b4057875191dab6c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7292c875559c2a6b4057875191dab6c">LoadMarkupsFiducials</a> (const char *fileName, const char *fidsName=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="memdesc:ac7292c875559c2a6b4057875191dab6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is deprecated. It is kept for backward compatibility only, it does the same as LoadMarkups method.  <br /></td></tr>
<tr class="separator:ac7292c875559c2a6b4057875191dab6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be9ac5ff60eb4553677d2b393b0f80" id="r_ad0be9ac5ff60eb4553677d2b393b0f80"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0be9ac5ff60eb4553677d2b393b0f80">LoadMarkupsFromFcsv</a> (const char *fileName, const char *nodeName=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:ad0be9ac5ff60eb4553677d2b393b0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb74bbb0bace9e3138c50eed9363f11f" id="r_aeb74bbb0bace9e3138c50eed9363f11f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb74bbb0bace9e3138c50eed9363f11f">LoadMarkupsFromJson</a> (const char *fileName, const char *nodeName=nullptr, <a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *userMessages=nullptr)</td></tr>
<tr class="separator:aeb74bbb0bace9e3138c50eed9363f11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36a4d4afd693d07419da5247f6c01d2" id="r_aa36a4d4afd693d07419da5247f6c01d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa36a4d4afd693d07419da5247f6c01d2">MoveNthControlPointToNewListAtIndex</a> (int n, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *newMarkupsNode, int newIndex)</td></tr>
<tr class="separator:aa36a4d4afd693d07419da5247f6c01d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e4f6c7ed2097b0bea3f35e3104267d" id="r_ae2e4f6c7ed2097b0bea3f35e3104267d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e4f6c7ed2097b0bea3f35e3104267d">MoveNthMarkupToNewList</a> (int n, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *newMarkupsNode, int newIndex)</td></tr>
<tr class="separator:ae2e4f6c7ed2097b0bea3f35e3104267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb319530d0fa790b5d40ed3c807695e6" id="r_adb319530d0fa790b5d40ed3c807695e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb319530d0fa790b5d40ed3c807695e6">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:adb319530d0fa790b5d40ed3c807695e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60807c5ea42cd4b4471db833a03f96d" id="r_af60807c5ea42cd4b4471db833a03f96d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af60807c5ea42cd4b4471db833a03f96d">ProcessMRMLNodesEvents</a> (vtkObject *caller, unsigned long event, void *callData) override</td></tr>
<tr class="separator:af60807c5ea42cd4b4471db833a03f96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f2bc3c2eb6d7c2ff83886deea15158" id="r_ab5f2bc3c2eb6d7c2ff83886deea15158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f2bc3c2eb6d7c2ff83886deea15158">RegisterJsonStorageNodeForMarkupsType</a> (std::string markupsType, std::string storageNodeClassName)</td></tr>
<tr class="separator:ab5f2bc3c2eb6d7c2ff83886deea15158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fa523d3ee840c447d4e6dd14cd125b" id="r_a58fa523d3ee840c447d4e6dd14cd125b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58fa523d3ee840c447d4e6dd14cd125b">RegisterMarkupsNode</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkSlicerMarkupsWidget.html">vtkSlicerMarkupsWidget</a> *markupsWidget, bool createPushButton=true)</td></tr>
<tr class="separator:a58fa523d3ee840c447d4e6dd14cd125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db11d2a95abec0db33f63c8d5156341" id="r_a1db11d2a95abec0db33f63c8d5156341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db11d2a95abec0db33f63c8d5156341">RenameAllControlPointsFromCurrentFormat</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode)</td></tr>
<tr class="separator:a1db11d2a95abec0db33f63c8d5156341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceceecc99edeabe7f5a3eaac55e842b2" id="r_aceceecc99edeabe7f5a3eaac55e842b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceceecc99edeabe7f5a3eaac55e842b2">RenameAllMarkupsFromCurrentFormat</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode)</td></tr>
<tr class="separator:aceceecc99edeabe7f5a3eaac55e842b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af483e63ff07ecdffd44d53b232e329" id="r_a4af483e63ff07ecdffd44d53b232e329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4af483e63ff07ecdffd44d53b232e329">SetActiveList</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode)</td></tr>
<tr class="separator:a4af483e63ff07ecdffd44d53b232e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee8a00ad7b15f2ba49dc8f4617eb99e" id="r_adee8a00ad7b15f2ba49dc8f4617eb99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adee8a00ad7b15f2ba49dc8f4617eb99e">SetActiveListID</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode)</td></tr>
<tr class="separator:adee8a00ad7b15f2ba49dc8f4617eb99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4624cefcd91eb8990930b9eed233972" id="r_aa4624cefcd91eb8990930b9eed233972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4624cefcd91eb8990930b9eed233972">SetAllMarkupsLocked</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:aa4624cefcd91eb8990930b9eed233972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24870583ce859b982d1480fe12f69c44" id="r_a24870583ce859b982d1480fe12f69c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24870583ce859b982d1480fe12f69c44">SetAllMarkupsSelected</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:a24870583ce859b982d1480fe12f69c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c07142e9ff9004e5909515a9d374adc" id="r_a9c07142e9ff9004e5909515a9d374adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c07142e9ff9004e5909515a9d374adc">SetAllMarkupsVisibility</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:a9c07142e9ff9004e5909515a9d374adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be093fee550bfd80e88c2fa49e39ef8" id="r_a8be093fee550bfd80e88c2fa49e39ef8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be093fee550bfd80e88c2fa49e39ef8">SetAutoCreateDisplayNodes</a> (bool)</td></tr>
<tr class="separator:a8be093fee550bfd80e88c2fa49e39ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9254bd4d83d45b1ab02d291103e1ff" id="r_abe9254bd4d83d45b1ab02d291103e1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe9254bd4d83d45b1ab02d291103e1ff">SetDisplayDefaultsFromNode</a> (<a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *displayNode)</td></tr>
<tr class="memdesc:abe9254bd4d83d45b1ab02d291103e1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility method to set defaults from display node  <br /></td></tr>
<tr class="separator:abe9254bd4d83d45b1ab02d291103e1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead1f2f4cede0c3bf0fa775270c3f945" id="r_aead1f2f4cede0c3bf0fa775270c3f945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead1f2f4cede0c3bf0fa775270c3f945">SetDisplayNodeToDefaults</a> (<a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *displayNode)</td></tr>
<tr class="separator:aead1f2f4cede0c3bf0fa775270c3f945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89001af895634a5c3455b68a5eb0657" id="r_aa89001af895634a5c3455b68a5eb0657"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa89001af895634a5c3455b68a5eb0657">StartPlaceMode</a> (bool persistent, <a class="el" href="classvtkMRMLInteractionNode.html">vtkMRMLInteractionNode</a> *interactionNode=nullptr)</td></tr>
<tr class="separator:aa89001af895634a5c3455b68a5eb0657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0206e9a0cdae35b08065873c3bfd6e8b" id="r_a0206e9a0cdae35b08065873c3bfd6e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0206e9a0cdae35b08065873c3bfd6e8b">ToggleAllMarkupsLocked</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:a0206e9a0cdae35b08065873c3bfd6e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff6be4a295b21cbbeb03f8bc3121ad2" id="r_acff6be4a295b21cbbeb03f8bc3121ad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff6be4a295b21cbbeb03f8bc3121ad2">ToggleAllMarkupsSelected</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:acff6be4a295b21cbbeb03f8bc3121ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd0d897b8d3911298fcdecafa12ffe2" id="r_a5cd0d897b8d3911298fcdecafa12ffe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cd0d897b8d3911298fcdecafa12ffe2">ToggleAllMarkupsVisibility</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:a5cd0d897b8d3911298fcdecafa12ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed31808522f99d422c886fd5cf4d18e" id="r_aaed31808522f99d422c886fd5cf4d18e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaed31808522f99d422c886fd5cf4d18e">UnregisterMarkupsNode</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode)</td></tr>
<tr class="separator:aaed31808522f99d422c886fd5cf4d18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73fc114879f0c23c567dbd115c458668" id="r_a73fc114879f0c23c567dbd115c458668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73fc114879f0c23c567dbd115c458668">SetAllControlPointsVisibility</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:a73fc114879f0c23c567dbd115c458668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8798fc8eab0938e56e5936a002cab943" id="r_a8798fc8eab0938e56e5936a002cab943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8798fc8eab0938e56e5936a002cab943">ToggleAllControlPointsVisibility</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:a8798fc8eab0938e56e5936a002cab943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ee444e47f2e105b9dbf67a1b3c537" id="r_a3b1ee444e47f2e105b9dbf67a1b3c537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1ee444e47f2e105b9dbf67a1b3c537">SetAllControlPointsLocked</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:a3b1ee444e47f2e105b9dbf67a1b3c537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03406c7c3d457a7fe0a9f9388d81c62" id="r_ae03406c7c3d457a7fe0a9f9388d81c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae03406c7c3d457a7fe0a9f9388d81c62">ToggleAllControlPointsLocked</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:ae03406c7c3d457a7fe0a9f9388d81c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c195efc8b0f44d4f57303111088fb4" id="r_a35c195efc8b0f44d4f57303111088fb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35c195efc8b0f44d4f57303111088fb4">SetAllControlPointsSelected</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node, bool flag)</td></tr>
<tr class="separator:a35c195efc8b0f44d4f57303111088fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fa209056e6457d13c66564046998fb" id="r_ae7fa209056e6457d13c66564046998fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7fa209056e6457d13c66564046998fb">ToggleAllControlPointsSelected</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *node)</td></tr>
<tr class="separator:ae7fa209056e6457d13c66564046998fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a8931a0176e046fa530d68105ceecef66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkSlicerApplicationLogic.html">vtkSlicerApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a8931a0176e046fa530d68105ceecef66">GetApplicationLogic</a> ()</td></tr>
<tr class="memdesc:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a8931a0176e046fa530d68105ceecef66 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0da4557f1f4335d1e4b5f08be2d282e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0da4557f1f4335d1e4b5f08be2d282e7">GetModuleLogic</a> (const char *moduleName)</td></tr>
<tr class="memdesc:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for getting another module's logic from the application logic.  <br /></td></tr>
<tr class="separator:a0da4557f1f4335d1e4b5f08be2d282e7 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic" id="r_aef42603c86610d6a6e93f3d48323f7ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#aef42603c86610d6a6e93f3d48323f7ef">GetModuleShareDirectory</a> () const</td></tr>
<tr class="separator:aef42603c86610d6a6e93f3d48323f7ef inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a0e3bbf7759001cc13890f41d1a79c598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a0e3bbf7759001cc13890f41d1a79c598">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a0e3bbf7759001cc13890f41d1a79c598 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic" id="r_a2918ff2ca1a047594ab5f21d7fa93997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a2918ff2ca1a047594ab5f21d7fa93997">SetModuleShareDirectory</a> (const std::string &amp;shareDirectory)</td></tr>
<tr class="separator:a2918ff2ca1a047594ab5f21d7fa93997 inherit pub_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a530bc426ed6f5725f82b67bc7383ef51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a530bc426ed6f5725f82b67bc7383ef51">GetMRMLApplicationLogic</a> () const</td></tr>
<tr class="memdesc:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to overall application state.  <br /></td></tr>
<tr class="separator:a530bc426ed6f5725f82b67bc7383ef51 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a147f82b5aaaf465ccdb5cabbfef8e6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a147f82b5aaaf465ccdb5cabbfef8e6e8">GetMRMLScene</a> () const</td></tr>
<tr class="memdesc:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the current MRML scene.  <br /></td></tr>
<tr class="separator:a147f82b5aaaf465ccdb5cabbfef8e6e8 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a30dc8aa28d58ca3f9a52ee9923fb13a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a30dc8aa28d58ca3f9a52ee9923fb13a9">PrintSelf</a> (ostream &amp;os, vtkIndent indent) override</td></tr>
<tr class="separator:a30dc8aa28d58ca3f9a52ee9923fb13a9 inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a95af27a03775e432e2e9a4ffa0681a8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a95af27a03775e432e2e9a4ffa0681a8c">SetMRMLApplicationLogic</a> (<a class="el" href="classvtkMRMLApplicationLogic.html">vtkMRMLApplicationLogic</a> *logic)</td></tr>
<tr class="separator:a95af27a03775e432e2e9a4ffa0681a8c inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic" id="r_a51f4149e574bb15f5d082dc93c07543e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51f4149e574bb15f5d082dc93c07543e">SetMRMLScene</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene)</td></tr>
<tr class="memdesc:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and observe the MRMLScene.  <br /></td></tr>
<tr class="separator:a51f4149e574bb15f5d082dc93c07543e inherit pub_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa1030033db98525324560755c25256b4" id="r_aa1030033db98525324560755c25256b4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1030033db98525324560755c25256b4">ExportControlPointsToCSV</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, const std::string filename, bool lps=true)</td></tr>
<tr class="separator:aa1030033db98525324560755c25256b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edb26eef3d48b95ef21f47fb55fabf6" id="r_a4edb26eef3d48b95ef21f47fb55fabf6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4edb26eef3d48b95ef21f47fb55fabf6">ExportControlPointsToTable</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLTableNode.html">vtkMRMLTableNode</a> *tableNode, int coordinateSystem=<a class="el" href="classvtkMRMLStorageNode.html#a3d12af2e335acfdd689e502aa773881ca1a2a07e297f83f4c1d793d5cd8b8cebd">vtkMRMLStorageNode::CoordinateSystemRAS</a>)</td></tr>
<tr class="separator:a4edb26eef3d48b95ef21f47fb55fabf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12014150bc5881f17f8da6f24e72e135" id="r_a12014150bc5881f17f8da6f24e72e135"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12014150bc5881f17f8da6f24e72e135">FitSurfaceDiskWarp</a> (vtkPoints *curvePoints, vtkPolyData *surface, double radiusScalingFactor=1.0)</td></tr>
<tr class="separator:a12014150bc5881f17f8da6f24e72e135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2060176b416ebb6ef8a77754f3d914aa" id="r_a2060176b416ebb6ef8a77754f3d914aa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2060176b416ebb6ef8a77754f3d914aa">FitSurfaceProjectWarp</a> (vtkPoints *curvePoints, vtkPolyData *surface, double radiusScalingFactor=1.0, vtkIdType numberOfInternalGridPoints=225)</td></tr>
<tr class="separator:a2060176b416ebb6ef8a77754f3d914aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b1f62a6d1d7befed2fc4677929d69f" id="r_ab8b1f62a6d1d7befed2fc4677929d69f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b1f62a6d1d7befed2fc4677929d69f">GetBestFitPlane</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *curveNode, vtkPlane *plane)</td></tr>
<tr class="memdesc:ab8b1f62a6d1d7befed2fc4677929d69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get best fit plane for a markup.  <br /></td></tr>
<tr class="separator:ab8b1f62a6d1d7befed2fc4677929d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8ea3aa668be47db76712b724bf57b" id="r_a21f8ea3aa668be47db76712b724bf57b"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f8ea3aa668be47db76712b724bf57b">GetClosedCurveSurfaceArea</a> (<a class="el" href="classvtkMRMLMarkupsClosedCurveNode.html">vtkMRMLMarkupsClosedCurveNode</a> *curveNode, vtkPolyData *surface=nullptr, bool projectWarp=true)</td></tr>
<tr class="separator:a21f8ea3aa668be47db76712b724bf57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596c3cd169164004ba1260e72fde4669" id="r_a596c3cd169164004ba1260e72fde4669"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596c3cd169164004ba1260e72fde4669">ImportControlPointsFromCSV</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, const std::string filename)</td></tr>
<tr class="separator:a596c3cd169164004ba1260e72fde4669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d3b0c1770bcb15c0ef940dd3f9cd20" id="r_af7d3b0c1770bcb15c0ef940dd3f9cd20"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7d3b0c1770bcb15c0ef940dd3f9cd20">ImportControlPointsFromTable</a> (<a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *markupsNode, <a class="el" href="classvtkMRMLTableNode.html">vtkMRMLTableNode</a> *tableNode, int startRow=0, int numberOfRows=-1)</td></tr>
<tr class="separator:af7d3b0c1770bcb15c0ef940dd3f9cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5241d3e56ea8111684b6d18b90e132f0" id="r_a5241d3e56ea8111684b6d18b90e132f0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5241d3e56ea8111684b6d18b90e132f0">IsPolygonClockwise</a> (vtkPoints *points, vtkIdList *pointIds=nullptr)</td></tr>
<tr class="separator:a5241d3e56ea8111684b6d18b90e132f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471a759a3de4ae3f8e1f478ae90b53f" id="r_a7471a759a3de4ae3f8e1f478ae90b53f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7471a759a3de4ae3f8e1f478ae90b53f">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a7471a759a3de4ae3f8e1f478ae90b53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ead326a2b7f15e93e4082ec8f3ac28" id="r_a10ead326a2b7f15e93e4082ec8f3ac28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerMarkupsLogic.html">vtkSlicerMarkupsLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10ead326a2b7f15e93e4082ec8f3ac28">New</a> ()</td></tr>
<tr class="separator:a10ead326a2b7f15e93e4082ec8f3ac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773a595fb1169dd9952f8a281039295e" id="r_a773a595fb1169dd9952f8a281039295e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerMarkupsLogic.html">vtkSlicerMarkupsLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a773a595fb1169dd9952f8a281039295e">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a773a595fb1169dd9952f8a281039295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ae51eba75b9c5e714584ad139110613ad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ae51eba75b9c5e714584ad139110613ad">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:ae51eba75b9c5e714584ad139110613ad inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_ac55ca7008a3d25c56ef115d346c1f228"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#ac55ca7008a3d25c56ef115d346c1f228">New</a> ()</td></tr>
<tr class="memdesc:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Usual vtk class functions.  <br /></td></tr>
<tr class="separator:ac55ca7008a3d25c56ef115d346c1f228 inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic" id="r_a4f7462e217013233873c2f10176a58ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a4f7462e217013233873c2f10176a58ff">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f7462e217013233873c2f10176a58ff inherit pub_static_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a466db0b62e33aa0f80d0fe720c1a6213"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a466db0b62e33aa0f80d0fe720c1a6213">IsTypeOf</a> (const char *type)</td></tr>
<tr class="separator:a466db0b62e33aa0f80d0fe720c1a6213 inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a2d46c696959ebbe53b83ce0df02add8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2d46c696959ebbe53b83ce0df02add8b">New</a> ()</td></tr>
<tr class="separator:a2d46c696959ebbe53b83ce0df02add8b inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic" id="r_a4f99d44049ff8e4c008ffed1ee7519ba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4f99d44049ff8e4c008ffed1ee7519ba">SafeDownCast</a> (vtkObject *o)</td></tr>
<tr class="separator:a4f99d44049ff8e4c008ffed1ee7519ba inherit pub_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5a2349dd2aa90c6fa2b6dd8a22588a78" id="r_a5a2349dd2aa90c6fa2b6dd8a22588a78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a2349dd2aa90c6fa2b6dd8a22588a78">ObserveMRMLScene</a> () override</td></tr>
<tr class="separator:a5a2349dd2aa90c6fa2b6dd8a22588a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a47d3ed8414fb523abb2204a8bcc65" id="r_a03a47d3ed8414fb523abb2204a8bcc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a47d3ed8414fb523abb2204a8bcc65">OnMRMLSceneEndImport</a> () override</td></tr>
<tr class="separator:a03a47d3ed8414fb523abb2204a8bcc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c0a71539ab517250e85775c7db5944" id="r_a24c0a71539ab517250e85775c7db5944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24c0a71539ab517250e85775c7db5944">OnMRMLSceneNodeAdded</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node) override</td></tr>
<tr class="separator:a24c0a71539ab517250e85775c7db5944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5f837c6a4f65e40e7b2e9302bdcf25" id="r_abe5f837c6a4f65e40e7b2e9302bdcf25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5f837c6a4f65e40e7b2e9302bdcf25">OnMRMLSceneNodeRemoved</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *node) override</td></tr>
<tr class="separator:abe5f837c6a4f65e40e7b2e9302bdcf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea7e2730adfe2f96a326f8180454991" id="r_afea7e2730adfe2f96a326f8180454991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea7e2730adfe2f96a326f8180454991">RegisterNodes</a> () override</td></tr>
<tr class="memdesc:afea7e2730adfe2f96a326f8180454991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this logic class.  <br /></td></tr>
<tr class="separator:afea7e2730adfe2f96a326f8180454991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f79addb66a08c4c7b54d51d871e1c7" id="r_a93f79addb66a08c4c7b54d51d871e1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f79addb66a08c4c7b54d51d871e1c7">SetAndObserveSelectionNode</a> (<a class="el" href="classvtkMRMLSelectionNode.html">vtkMRMLSelectionNode</a> *selectionNode)</td></tr>
<tr class="separator:a93f79addb66a08c4c7b54d51d871e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f222b5020a80f90c4a7bd1073b0193f" id="r_a9f222b5020a80f90c4a7bd1073b0193f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f">SetMRMLSceneInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene) override</td></tr>
<tr class="memdesc:a9f222b5020a80f90c4a7bd1073b0193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize listening to MRML events.  <br /></td></tr>
<tr class="separator:a9f222b5020a80f90c4a7bd1073b0193f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094488fadee2d55b7ac6e8ed36f058b6" id="r_a094488fadee2d55b7ac6e8ed36f058b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a094488fadee2d55b7ac6e8ed36f058b6">UpdateFromMRMLScene</a> () override</td></tr>
<tr class="separator:a094488fadee2d55b7ac6e8ed36f058b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a338606882716385079199819d9e08" id="r_a22a338606882716385079199819d9e08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22a338606882716385079199819d9e08">UpdatePlaceNodeClassNamesInSelectionNode</a> ()</td></tr>
<tr class="memdesc:a22a338606882716385079199819d9e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update list of place node class names in selection node based on currently registered markups.  <br /></td></tr>
<tr class="separator:a22a338606882716385079199819d9e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671003c63f5dc093e90e102e6c09809c" id="r_a671003c63f5dc093e90e102e6c09809c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a671003c63f5dc093e90e102e6c09809c">vtkSlicerMarkupsLogic</a> ()</td></tr>
<tr class="separator:a671003c63f5dc093e90e102e6c09809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba263ccf0b1a2a9cca243839c3df63" id="r_af8ba263ccf0b1a2a9cca243839c3df63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ba263ccf0b1a2a9cca243839c3df63">~vtkSlicerMarkupsLogic</a> () override</td></tr>
<tr class="separator:af8ba263ccf0b1a2a9cca243839c3df63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkSlicerModuleLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkSlicerModuleLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a></td></tr>
<tr class="memitem:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic" id="r_a43ba2967e63f5194eba13570e79c8b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a43ba2967e63f5194eba13570e79c8b4e">vtkSlicerModuleLogic</a> ()</td></tr>
<tr class="separator:a43ba2967e63f5194eba13570e79c8b4e inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic" id="r_a06a744b1d43e4370a99462f0b9b3f30f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkSlicerModuleLogic.html#a06a744b1d43e4370a99462f0b9b3f30f">~vtkSlicerModuleLogic</a> () override</td></tr>
<tr class="separator:a06a744b1d43e4370a99462f0b9b3f30f inherit pro_methods_classvtkSlicerModuleLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ab5b1ee240252dfd245fc01f8eb53e8e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ab5b1ee240252dfd245fc01f8eb53e8e9">EndModify</a> (bool wasModifying)</td></tr>
<tr class="separator:ab5b1ee240252dfd245fc01f8eb53e8e9 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a471bd7df7caef325291e5e683e42796c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a471bd7df7caef325291e5e683e42796c">EnterMRMLLogicsCallback</a> () const</td></tr>
<tr class="separator:a471bd7df7caef325291e5e683e42796c inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aeb78c60e083bcbb907f81f136e53364e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aeb78c60e083bcbb907f81f136e53364e">EnterMRMLNodesCallback</a> () const</td></tr>
<tr class="separator:aeb78c60e083bcbb907f81f136e53364e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a57c1538abccd8fc920b20d7f277f9ad3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a57c1538abccd8fc920b20d7f277f9ad3">EnterMRMLSceneCallback</a> () const</td></tr>
<tr class="separator:a57c1538abccd8fc920b20d7f277f9ad3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5d7c3aabe26766856b040937db55141d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5d7c3aabe26766856b040937db55141d">GetDisableModifiedEvent</a> () const</td></tr>
<tr class="separator:a5d7c3aabe26766856b040937db55141d inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic" id="r_add020efdf3ea303c860c06218e7bd0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#add020efdf3ea303c860c06218e7bd0ce">GetInMRMLLogicsCallbackFlag</a> () const</td></tr>
<tr class="separator:add020efdf3ea303c860c06218e7bd0ce inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ad43b978b6997abd9211e873107fbb99b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ad43b978b6997abd9211e873107fbb99b">GetInMRMLNodesCallbackFlag</a> () const</td></tr>
<tr class="separator:ad43b978b6997abd9211e873107fbb99b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2c912757bd1e2fb9ed18531772d9b7c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2c912757bd1e2fb9ed18531772d9b7c2">GetInMRMLSceneCallbackFlag</a> () const</td></tr>
<tr class="separator:a2c912757bd1e2fb9ed18531772d9b7c2 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a2024ab8d24c8b78ca68aa76ee2df6d1b"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a2024ab8d24c8b78ca68aa76ee2df6d1b">GetMRMLLogicsCallbackCommand</a> ()</td></tr>
<tr class="separator:a2024ab8d24c8b78ca68aa76ee2df6d1b inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5cd3b9222aa0f9399a0d04daa857af41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5cd3b9222aa0f9399a0d04daa857af41">GetMRMLLogicsObserverManager</a> () const</td></tr>
<tr class="separator:a5cd3b9222aa0f9399a0d04daa857af41 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a31c1e7f33880b6ad9683548fbc4ccaca"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a31c1e7f33880b6ad9683548fbc4ccaca">GetMRMLNodesCallbackCommand</a> ()</td></tr>
<tr class="separator:a31c1e7f33880b6ad9683548fbc4ccaca inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a858c37b78d41171d298b797d03494411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a858c37b78d41171d298b797d03494411">GetMRMLNodesObserverManager</a> () const</td></tr>
<tr class="separator:a858c37b78d41171d298b797d03494411 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4d9c5b9885a2d46790cb5e31a7e013dd"><td class="memItemLeft" align="right" valign="top">vtkCallbackCommand *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4d9c5b9885a2d46790cb5e31a7e013dd">GetMRMLSceneCallbackCommand</a> ()</td></tr>
<tr class="separator:a4d9c5b9885a2d46790cb5e31a7e013dd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aefad89326706f2999ff8e6e97e221061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvtkObserverManager.html">vtkObserverManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aefad89326706f2999ff8e6e97e221061">GetMRMLSceneObserverManager</a> () const</td></tr>
<tr class="separator:aefad89326706f2999ff8e6e97e221061 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_abcbd9db7caad7038b170c95a3398d237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#abcbd9db7caad7038b170c95a3398d237">GetPendingModifiedEventCount</a> () const</td></tr>
<tr class="separator:abcbd9db7caad7038b170c95a3398d237 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a040a2e3a82ac8a72ea06450c78001db1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a040a2e3a82ac8a72ea06450c78001db1">GetProcessingMRMLSceneEvent</a> () const</td></tr>
<tr class="memdesc:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the event id currently processed or 0 if any.  <br /></td></tr>
<tr class="separator:a040a2e3a82ac8a72ea06450c78001db1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adbdafafc00fbfca72832bf573b4e53fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adbdafafc00fbfca72832bf573b4e53fd">InvokePendingModifiedEvent</a> ()</td></tr>
<tr class="separator:adbdafafc00fbfca72832bf573b4e53fd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a47880d57d0f4b54a2ace71ab4b071bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a47880d57d0f4b54a2ace71ab4b071bc7">Modified</a> () override</td></tr>
<tr class="separator:a47880d57d0f4b54a2ace71ab4b071bc7 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a124e968e51a99e4dc16d022b3fd37e2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a124e968e51a99e4dc16d022b3fd37e2e">OnMRMLNodeModified</a> (<a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *)</td></tr>
<tr class="separator:a124e968e51a99e4dc16d022b3fd37e2e inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac1a782799e284bd04ea5182b1e41dc93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac1a782799e284bd04ea5182b1e41dc93">OnMRMLSceneEndBatchProcess</a> ()</td></tr>
<tr class="separator:ac1a782799e284bd04ea5182b1e41dc93 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a5f8a69a47eacec0cd95857beceb8eb34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5f8a69a47eacec0cd95857beceb8eb34">OnMRMLSceneEndClose</a> ()</td></tr>
<tr class="separator:a5f8a69a47eacec0cd95857beceb8eb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3e1d4144d47f125c71a36c88c4289e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3e1d4144d47f125c71a36c88c4289e1">OnMRMLSceneEndRestore</a> ()</td></tr>
<tr class="separator:af3e1d4144d47f125c71a36c88c4289e1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac9c4356c3ad53f529f948214d5ce30f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac9c4356c3ad53f529f948214d5ce30f1">OnMRMLSceneNew</a> ()</td></tr>
<tr class="separator:ac9c4356c3ad53f529f948214d5ce30f1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic" id="r_afc31c1f6a54e4dabf14f1ae3fe3c47df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#afc31c1f6a54e4dabf14f1ae3fe3c47df">OnMRMLSceneStartBatchProcess</a> ()</td></tr>
<tr class="separator:afc31c1f6a54e4dabf14f1ae3fe3c47df inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a063cceb9c914333b8fd076ff5c0f6a30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a063cceb9c914333b8fd076ff5c0f6a30">OnMRMLSceneStartClose</a> ()</td></tr>
<tr class="separator:a063cceb9c914333b8fd076ff5c0f6a30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a048ce8ed9409c07be134bcd03ae27184"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a048ce8ed9409c07be134bcd03ae27184">OnMRMLSceneStartImport</a> ()</td></tr>
<tr class="separator:a048ce8ed9409c07be134bcd03ae27184 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aebe17bd4344f7c85c653d10631d6aa30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aebe17bd4344f7c85c653d10631d6aa30">OnMRMLSceneStartRestore</a> ()</td></tr>
<tr class="separator:aebe17bd4344f7c85c653d10631d6aa30 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_adac3d2b2ec84f30d78d3a6c8d8aeb828"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#adac3d2b2ec84f30d78d3a6c8d8aeb828">ProcessMRMLLogicsEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:adac3d2b2ec84f30d78d3a6c8d8aeb828 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a51fdf00ecfc18c1a1465d4bccb789ef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a> (vtkObject *caller, unsigned long event, void *callData)</td></tr>
<tr class="separator:a51fdf00ecfc18c1a1465d4bccb789ef1 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac028eafed3ee93b9b3741f57139132d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac028eafed3ee93b9b3741f57139132d3">SetAndObserveMRMLSceneEventsInternal</a> (<a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *newScene, vtkIntArray *events, vtkFloatArray *priorities=nullptr)</td></tr>
<tr class="separator:ac028eafed3ee93b9b3741f57139132d3 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3eb7d963472fa9fd4eb83d8a6ee33ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3eb7d963472fa9fd4eb83d8a6ee33ccd">SetDisableModifiedEvent</a> (bool onOff)</td></tr>
<tr class="separator:a3eb7d963472fa9fd4eb83d8a6ee33ccd inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_ac4b6e57c0562f3e41a92372cca661e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#ac4b6e57c0562f3e41a92372cca661e65">SetInMRMLLogicsCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:ac4b6e57c0562f3e41a92372cca661e65 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a4836d6eb665c483236232345eccb9833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a4836d6eb665c483236232345eccb9833">SetInMRMLNodesCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:a4836d6eb665c483236232345eccb9833 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_acf80dc501f04df6b0d0db5095d63e042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#acf80dc501f04df6b0d0db5095d63e042">SetInMRMLSceneCallbackFlag</a> (int flag)</td></tr>
<tr class="separator:acf80dc501f04df6b0d0db5095d63e042 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_af3b03cb0ee8830fc953868266b62df44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af3b03cb0ee8830fc953868266b62df44">SetProcessingMRMLSceneEvent</a> (int event)</td></tr>
<tr class="separator:af3b03cb0ee8830fc953868266b62df44 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_aca82fcc8ec42d9976a29b0acf9ba27a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#aca82fcc8ec42d9976a29b0acf9ba27a4">StartModify</a> ()</td></tr>
<tr class="separator:aca82fcc8ec42d9976a29b0acf9ba27a4 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a966747ac1626e911a08ce8bb9ba909eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a> ()</td></tr>
<tr class="separator:a966747ac1626e911a08ce8bb9ba909eb inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a3440792dbe0d54de16de57eac139bb34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a3440792dbe0d54de16de57eac139bb34">vtkMRMLAbstractLogic</a> ()</td></tr>
<tr class="separator:a3440792dbe0d54de16de57eac139bb34 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic" id="r_a417c9d98b17e68087d1263b95d4003d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a417c9d98b17e68087d1263b95d4003d8">~vtkMRMLAbstractLogic</a> () override</td></tr>
<tr class="separator:a417c9d98b17e68087d1263b95d4003d8 inherit pro_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classvtkMRMLAbstractLogic"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classvtkMRMLAbstractLogic')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classvtkMRMLAbstractLogic.html">vtkMRMLAbstractLogic</a></td></tr>
<tr class="memitem:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5af15efe0f8421ef6de4f3168830e3f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5af15efe0f8421ef6de4f3168830e3f7">MRMLLogicsCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLLogicCallback is a static function to relay modified events from the logics.  <br /></td></tr>
<tr class="separator:a5af15efe0f8421ef6de4f3168830e3f7 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_a5b796a7ccecd251cdb83874b390c4e43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#a5b796a7ccecd251cdb83874b390c4e43">MRMLNodesCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="memdesc:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="mdescLeft">&#160;</td><td class="mdescRight">MRMLNodesCallback is a static function to relay modified events from the nodes.  <br /></td></tr>
<tr class="separator:a5b796a7ccecd251cdb83874b390c4e43 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic" id="r_af4a68e64a0ca65a9efb92d717f3a7896"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvtkMRMLAbstractLogic.html#af4a68e64a0ca65a9efb92d717f3a7896">MRMLSceneCallback</a> (vtkObject *caller, unsigned long eid, void *clientData, void *callData)</td></tr>
<tr class="separator:af4a68e64a0ca65a9efb92d717f3a7896 inherit pro_static_methods_classvtkMRMLAbstractLogic"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00056">56</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a24ce008dac54eba491106254caef64a8" name="a24ce008dac54eba491106254caef64a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ce008dac54eba491106254caef64a8">&#9670;&#160;</a></span>Superclass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvtkSlicerModuleLogic.html">vtkSlicerModuleLogic</a> <a class="el" href="#a24ce008dac54eba491106254caef64a8">vtkSlicerMarkupsLogic::Superclass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00068">68</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2a3174a5ef78ddafe4d0378f561e6fa1" name="a2a3174a5ef78ddafe4d0378f561e6fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3174a5ef78ddafe4d0378f561e6fa1">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration listing valid annotation file types to load using LoadAnnotation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a3174a5ef78ddafe4d0378f561e6fa1a9a214c9035c53b40cbdc82f32e29a57d" name="a2a3174a5ef78ddafe4d0378f561e6fa1a9a214c9035c53b40cbdc82f32e29a57d"></a>AnnotationNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a3174a5ef78ddafe4d0378f561e6fa1a962fed1bc18da4a328a6a9958807e574" name="a2a3174a5ef78ddafe4d0378f561e6fa1a962fed1bc18da4a328a6a9958807e574"></a>AnnotationFiducial&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a3174a5ef78ddafe4d0378f561e6fa1aa3491bf4ff90c9966499417ff2885122" name="a2a3174a5ef78ddafe4d0378f561e6fa1aa3491bf4ff90c9966499417ff2885122"></a>AnnotationRuler&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a3174a5ef78ddafe4d0378f561e6fa1a249b695efa71d4059ecabe890225cf23" name="a2a3174a5ef78ddafe4d0378f561e6fa1a249b695efa71d4059ecabe890225cf23"></a>AnnotationROI&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00152">152</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="ad1e18b1e6c786f797118aa763fb02183" name="ad1e18b1e6c786f797118aa763fb02183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e18b1e6c786f797118aa763fb02183">&#9670;&#160;</a></span>Events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad1e18b1e6c786f797118aa763fb02183">vtkSlicerMarkupsLogic::Events</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1e18b1e6c786f797118aa763fb02183a99a4987366c42a19f6904accf8c0d6b9" name="ad1e18b1e6c786f797118aa763fb02183a99a4987366c42a19f6904accf8c0d6b9"></a>MarkupRegistered&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1e18b1e6c786f797118aa763fb02183a2b0dab5b25a58235ffbdd4078f020059" name="ad1e18b1e6c786f797118aa763fb02183a2b0dab5b25a58235ffbdd4078f020059"></a>MarkupUnregistered&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00061">61</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a671003c63f5dc093e90e102e6c09809c" name="a671003c63f5dc093e90e102e6c09809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671003c63f5dc093e90e102e6c09809c">&#9670;&#160;</a></span>vtkSlicerMarkupsLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerMarkupsLogic::vtkSlicerMarkupsLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8ba263ccf0b1a2a9cca243839c3df63" name="af8ba263ccf0b1a2a9cca243839c3df63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba263ccf0b1a2a9cca243839c3df63">&#9670;&#160;</a></span>~vtkSlicerMarkupsLogic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vtkSlicerMarkupsLogic::~vtkSlicerMarkupsLogic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac095cc6c3c798e686acd2240663779a1" name="ac095cc6c3c798e686acd2240663779a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac095cc6c3c798e686acd2240663779a1">&#9670;&#160;</a></span>AddControlPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerMarkupsLogic::AddControlPoint </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new control point to the currently active markups fiducial node at the given RAS coordinates (default 0,0,0). Will create a markups fiducial node if one is not active. Returns -1 on failure, index of the added control point on success. </p>

</div>
</div>
<a id="a8811cfed179d6a8ad26007792e970d9e" name="a8811cfed179d6a8ad26007792e970d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8811cfed179d6a8ad26007792e970d9e">&#9670;&#160;</a></span>AddFiducial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int vtkSlicerMarkupsLogic::AddFiducial </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>r</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>s</em><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated</a></b></dt><dd>Use AddControlPoint instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00359">359</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a0448556b30d403f2446cde597d4534d9" name="a0448556b30d403f2446cde597d4534d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0448556b30d403f2446cde597d4534d9">&#9670;&#160;</a></span>AddNewDisplayNodeForMarkupsNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerMarkupsLogic::AddNewDisplayNodeForMarkupsNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"><em>mrmlNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new display node and observe it on the markups node. On success, return the id, on failure return an empty string. If a display node already exists for this node, return the id of that node. </p>

</div>
</div>
<a id="a5593a4290d58f1e3cb35a58246e320d0" name="a5593a4290d58f1e3cb35a58246e320d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5593a4290d58f1e3cb35a58246e320d0">&#9670;&#160;</a></span>AddNewFiducialNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerMarkupsLogic::AddNewFiducialNode </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;F&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new markups fiducial node and associated display node, adding both to the scene. If the scene argument is null use the scene set on the logic class, and also make it the active on on the selection node, otherwise add to the passed scene. On success, return the id, on failure return an empty string. </p>

</div>
</div>
<a id="a8cfa1d9aca55f3353ac3136c35e00501" name="a8cfa1d9aca55f3353ac3136c35e00501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfa1d9aca55f3353ac3136c35e00501">&#9670;&#160;</a></span>AddNewJsonStorageNodeForMarkupsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLMarkupsJsonStorageNode.html">vtkMRMLMarkupsJsonStorageNode</a> * vtkSlicerMarkupsLogic::AddNewJsonStorageNodeForMarkupsType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>markupsType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7101431f676e6de543311cd2e8dd130" name="aa7101431f676e6de543311cd2e8dd130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7101431f676e6de543311cd2e8dd130">&#9670;&#160;</a></span>AddNewMarkupsNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> * vtkSlicerMarkupsLogic::AddNewMarkupsNode </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>className</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>nodeName</em><span class="paramdefsep"> = </span><span class="paramdefval">std::string()</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new markups node and associated display node, adding both to the scene. For ROI nodes, each new node will have a unique color. </p>

</div>
</div>
<a id="a7269312c53d06d64d9ff141bee2e6579" name="a7269312c53d06d64d9ff141bee2e6579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7269312c53d06d64d9ff141bee2e6579">&#9670;&#160;</a></span>AutoCreateDisplayNodesOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vtkSlicerMarkupsLogic::AutoCreateDisplayNodesOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50dfe658b0df5b5174dddecef02a8b1f" name="a50dfe658b0df5b5174dddecef02a8b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dfe658b0df5b5174dddecef02a8b1f">&#9670;&#160;</a></span>AutoCreateDisplayNodesOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vtkSlicerMarkupsLogic::AutoCreateDisplayNodesOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af92e60c09368971921101445e221441b" name="af92e60c09368971921101445e221441b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92e60c09368971921101445e221441b">&#9670;&#160;</a></span>ConvertAnnotationFiducialsToMarkups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ConvertAnnotationFiducialsToMarkups </td>
          <td>(</td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>addedNodeIds</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>removedNodeIds</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the scene for annotation fiducial nodes, collecting a list of annotation hierarchy nodes. Then iterates through those hierarchy nodes and moves the fiducials that are under them into new markups nodes. Leaves the top level hierarchy nodes intact as they may be parents to ruler or ROIs but deletes the 1:1 hierarchy nodes. If addedNodeIds or removedNodeIds are specified then IDs of data and hierarchy nodes added or removed during conversion in the main scene are added to these arrays. </p>

</div>
</div>
<a id="adc0084607aaf3288f2f6f59a75a06995" name="adc0084607aaf3288f2f6f59a75a06995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0084607aaf3288f2f6f59a75a06995">&#9670;&#160;</a></span>ConvertAnnotationHierarchyToSubjectHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ConvertAnnotationHierarchyToSubjectHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>scene</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d4f2f60d18585c0c6ffe536c5de7f5b" name="a4d4f2f60d18585c0c6ffe536c5de7f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4f2f60d18585c0c6ffe536c5de7f5b">&#9670;&#160;</a></span>ConvertAnnotationLinesROIsToMarkups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ConvertAnnotationLinesROIsToMarkups </td>
          <td>(</td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>addedNodeIds</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkStringArray *</td>          <td class="paramname"><span class="paramname"><em>removedNodeIds</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the scene for annotation ruler and ROI nodes and converts each to markup line or ROI node. If addedNodeIds or removedNodeIds are specified then IDs of data and hierarchy nodes added or removed during conversion in the main scene are added to these arrays. </p>

</div>
</div>
<a id="abf584e9ec0fc85285035db04d05259b4" name="abf584e9ec0fc85285035db04d05259b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf584e9ec0fc85285035db04d05259b4">&#9670;&#160;</a></span>CopyBasicDisplayProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::CopyBasicDisplayProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *</td>          <td class="paramname"><span class="paramname"><em>sourceDisplayNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *</td>          <td class="paramname"><span class="paramname"><em>targetDisplayNode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies basic display properties between markups display nodes. This is used for updating a display node to defaults. </p>

</div>
</div>
<a id="afa8a1e419cb84efc4fb25408ab5afc1a" name="afa8a1e419cb84efc4fb25408ab5afc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8a1e419cb84efc4fb25408ab5afc1a">&#9670;&#160;</a></span>CopyNthControlPointToNewList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::CopyNthControlPointToNewList </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>newMarkupsNode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>utility method to copy a control point from one list to another, adding it to the end of the new list </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLMarkupsNode.html#aea2170213ae13bc341dfded7de8a0d6b">vtkMRMLMarkupsNode::AddControlPoint</a> Returns true on success, false on failure </dd></dl>

</div>
</div>
<a id="a0ac34364b28afcbc90e9ee5167612cc4" name="a0ac34364b28afcbc90e9ee5167612cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac34364b28afcbc90e9ee5167612cc4">&#9670;&#160;</a></span>CopyNthMarkupToNewList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::CopyNthMarkupToNewList </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>newMarkupsNode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated</a></b></dt><dd>Use CopyNthControlPointToNewList instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00345">345</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="aa1030033db98525324560755c25256b4" name="aa1030033db98525324560755c25256b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1030033db98525324560755c25256b4">&#9670;&#160;</a></span>ExportControlPointsToCSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::ExportControlPointsToCSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lps</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export markups node control points to CSV file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsNode</td><td>Node that the control points are exported to. </td></tr>
    <tr><td class="paramname">filename</td><td>Output filename. </td></tr>
    <tr><td class="paramname">lps</td><td>Save files in LPS coordinate system. If set to false then RAS coordinate system is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edb26eef3d48b95ef21f47fb55fabf6" name="a4edb26eef3d48b95ef21f47fb55fabf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edb26eef3d48b95ef21f47fb55fabf6">&#9670;&#160;</a></span>ExportControlPointsToTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::ExportControlPointsToTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTableNode.html">vtkMRMLTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>tableNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>coordinateSystem</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classvtkMRMLStorageNode.html#a3d12af2e335acfdd689e502aa773881ca1a2a07e297f83f4c1d793d5cd8b8cebd">vtkMRMLStorageNode::CoordinateSystemRAS</a></span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12014150bc5881f17f8da6f24e72e135" name="a12014150bc5881f17f8da6f24e72e135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12014150bc5881f17f8da6f24e72e135">&#9670;&#160;</a></span>FitSurfaceDiskWarp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::FitSurfaceDiskWarp </td>
          <td>(</td>
          <td class="paramtype">vtkPoints *</td>          <td class="paramname"><span class="paramname"><em>curvePoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *</td>          <td class="paramname"><span class="paramname"><em>surface</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radiusScalingFactor</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a "soap bubble" surface that fits on the provided point list. Compared to FitSurfaceProjectWarp, this method can tolerate more if points are not on a plane but it may not be able to fill complicated shapes (with sharp edges or many indentations). A triangulated disk is warped so that its boundary matches the provided curve points using thin-plate spline transform. The generated surface may go beyond the boundary of the input points if the boundary is highly concave or curved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curvePoints</td><td>points to fit the surface to </td></tr>
    <tr><td class="paramname">radiusScalingFactor</td><td>size of the surface.Value of 1.0 (default) means the surface edge fits on the points. Larger values increase the generated soap bubble outer radius, which may be useful to avoid coincident points when using this surface for cutting another surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2060176b416ebb6ef8a77754f3d914aa" name="a2060176b416ebb6ef8a77754f3d914aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2060176b416ebb6ef8a77754f3d914aa">&#9670;&#160;</a></span>FitSurfaceProjectWarp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::FitSurfaceProjectWarp </td>
          <td>(</td>
          <td class="paramtype">vtkPoints *</td>          <td class="paramname"><span class="paramname"><em>curvePoints</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *</td>          <td class="paramname"><span class="paramname"><em>surface</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radiusScalingFactor</em><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdType</td>          <td class="paramname"><span class="paramname"><em>numberOfInternalGridPoints</em><span class="paramdefsep"> = </span><span class="paramdefval">225</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a "soap bubble" surface that fits on the provided point list. It can fill arbitrarily complex (non-self-intersecting) polygons in a plane or in a slightly curved plane. First the contour points projected to best fit plane, triangulated in 2D, and warped to the non-planar shape. Convex surfaces are triangulated correctly. If the contour is self-intersecting after projected to best fit plane then the surface will be invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curvePoints</td><td>points to fit the surface to </td></tr>
    <tr><td class="paramname">radiusScalingFactor</td><td>size of the surface. Value of 1.0 (default) means the surface edge fits on the points. Larger values increase the generated soap bubble outer radius, which may be useful to avoid coincident points when using this surface for cutting another surface. </td></tr>
    <tr><td class="paramname">numberOfInternalGridPoints</td><td>specifies the number of additional grid points that are added to get a more evenly triangulated surface. Default is 225, which corresponds to 15x15 subdivisions for a square shaped region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Specifying radiusScalingFactor has no effect. Associated feature is not yet implemented. </dd></dl>

</div>
</div>
<a id="a04ec532fe4585cf2e9d1ed5249865bbe" name="a04ec532fe4585cf2e9d1ed5249865bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ec532fe4585cf2e9d1ed5249865bbe">&#9670;&#160;</a></span>FocusCameraOnNthPointInMarkup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::FocusCameraOnNthPointInMarkup </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cameraNodeID</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>markupNodeID</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>refocus the camera with the given cameraNodeID on the nth markup in the markups node with id markupNodeID </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2a6ce5efb61834acdd6a7225f09b2630">FocusCamerasOnNthPointInMarkup</a> </dd></dl>

</div>
</div>
<a id="a2a6ce5efb61834acdd6a7225f09b2630" name="a2a6ce5efb61834acdd6a7225f09b2630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6ce5efb61834acdd6a7225f09b2630">&#9670;&#160;</a></span>FocusCamerasOnNthPointInMarkup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::FocusCamerasOnNthPointInMarkup </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>refocus all of the 3D cameras to the nth markup with the mrml id id </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a04ec532fe4585cf2e9d1ed5249865bbe">FocusCameraOnNthPointInMarkup</a> </dd></dl>

</div>
</div>
<a id="a1ab146c7f6a950d64a0e0b21797497bd" name="a1ab146c7f6a950d64a0e0b21797497bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab146c7f6a950d64a0e0b21797497bd">&#9670;&#160;</a></span>GenerateUniqueColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vtkVector3d vtkSlicerMarkupsLogic::GenerateUniqueColor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a unique color for a markup node. In the current implementation, the color is not globally unique, but colors are generated by iterating through the items in "MediumChart" color table. </p>

</div>
</div>
<a id="aa8d6334c8700514bca3ecfea9ab9024d" name="aa8d6334c8700514bca3ecfea9ab9024d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d6334c8700514bca3ecfea9ab9024d">&#9670;&#160;</a></span>GenerateUniqueColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::GenerateUniqueColor </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>color</em>[3]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16b4aef2d9033de20078fd411d0bddc6" name="a16b4aef2d9033de20078fd411d0bddc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b4aef2d9033de20078fd411d0bddc6">&#9670;&#160;</a></span>GetActiveListID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerMarkupsLogic::GetActiveListID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility method to return the id of the active place node. Returns an empty string on failure. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#adee8a00ad7b15f2ba49dc8f4617eb99e">SetActiveListID</a> </dd></dl>

</div>
</div>
<a id="a7aaf67b5884b36fab6de306a902b7e00" name="a7aaf67b5884b36fab6de306a902b7e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aaf67b5884b36fab6de306a902b7e00">&#9670;&#160;</a></span>GetAutoCreateDisplayNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool vtkSlicerMarkupsLogic::GetAutoCreateDisplayNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b1f62a6d1d7befed2fc4677929d69f" name="ab8b1f62a6d1d7befed2fc4677929d69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b1f62a6d1d7befed2fc4677929d69f">&#9670;&#160;</a></span>GetBestFitPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::GetBestFitPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>curveNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPlane *</td>          <td class="paramname"><span class="paramname"><em>plane</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get best fit plane for a markup. </p>

</div>
</div>
<a id="a824279b9f4a9994cd4c9c298ae851828" name="a824279b9f4a9994cd4c9c298ae851828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824279b9f4a9994cd4c9c298ae851828">&#9670;&#160;</a></span>GetClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * vtkSlicerMarkupsLogic::GetClassName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#a39fa467c794d06e4194f8f72814b96bd">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="a21f8ea3aa668be47db76712b724bf57b" name="a21f8ea3aa668be47db76712b724bf57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f8ea3aa668be47db76712b724bf57b">&#9670;&#160;</a></span>GetClosedCurveSurfaceArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vtkSlicerMarkupsLogic::GetClosedCurveSurfaceArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsClosedCurveNode.html">vtkMRMLMarkupsClosedCurveNode</a> *</td>          <td class="paramname"><span class="paramname"><em>curveNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkPolyData *</td>          <td class="paramname"><span class="paramname"><em>surface</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>projectWarp</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Measure surface area of the smooth surface that fits on the closed curve in world coordinate system. If projectWarp option is enabled then FitSurfaceProjectWarp method is used otherwise FitSurfaceDiskWarp is used. FitSurfaceProjectWarp produces accurate results for all quasi-planar curves (while FitSurfaceDiskWarp may significantly overestimate surface area for planar convex curves). FitSurfaceDiskWarp is kept for comparison only and may be removed in the future. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curveNode</td><td>points to fit the surface to </td></tr>
    <tr><td class="paramname">surface</td><td>if not nullptr then the generated surface is saved into that </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc8e1d840b63dc7399ee9768ee0408c0" name="adc8e1d840b63dc7399ee9768ee0408c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8e1d840b63dc7399ee9768ee0408c0">&#9670;&#160;</a></span>GetCreateMarkupsPushButton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::GetCreateMarkupsPushButton </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>markupName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns the flags that indicates whether the GUI push button should be created. </p>

</div>
</div>
<a id="a4ecc6aa463c8cdac37210baa708fda97" name="a4ecc6aa463c8cdac37210baa708fda97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecc6aa463c8cdac37210baa708fda97">&#9670;&#160;</a></span>GetDefaultMarkupsDisplayNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> * vtkSlicerMarkupsLogic::GetDefaultMarkupsDisplayNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36728dbc0ca3ef932a0684cc6dfba23b" name="a36728dbc0ca3ef932a0684cc6dfba23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36728dbc0ca3ef932a0684cc6dfba23b">&#9670;&#160;</a></span>GetJsonStorageNodeClassNameForMarkupsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerMarkupsLogic::GetJsonStorageNodeClassNameForMarkupsType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>markupsType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b2414374a924b963ce03c56753d0450" name="a9b2414374a924b963ce03c56753d0450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2414374a924b963ce03c56753d0450">&#9670;&#160;</a></span>GetNodeByMarkupsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> * vtkSlicerMarkupsLogic::GetNodeByMarkupsType </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>markupsType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns an instance to a corresponding <a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> associated to the indicated markups name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsType</td><td>registered class to retrieve the associated widget. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to associated <a class="el" href="classvtkSlicerMarkupsWidget.html" title="Process interaction events to update state of markup widget nodes.">vtkSlicerMarkupsWidget</a> or nullptr if the MRML node class is not registered. </dd></dl>

</div>
</div>
<a id="ae759f47605030c3389e4444821427382" name="ae759f47605030c3389e4444821427382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae759f47605030c3389e4444821427382">&#9670;&#160;</a></span>GetRegisteredMarkupsTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; std::string &gt; &amp; vtkSlicerMarkupsLogic::GetRegisteredMarkupsTypes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns the list of the markups registered in the logic. </p>

</div>
</div>
<a id="a6464fe068112a3b9e2edea051f4ee0e3" name="a6464fe068112a3b9e2edea051f4ee0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6464fe068112a3b9e2edea051f4ee0e3">&#9670;&#160;</a></span>GetSelectionNodeID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vtkSlicerMarkupsLogic::GetSelectionNodeID </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility method to return the id of the selection node. Checks the mrml application logic if set, otherwise checks the scene for a singleton selection node. Returns an empty string on failure. </p>

</div>
</div>
<a id="aa86c557417ac21c7500202e418b09cd4" name="aa86c557417ac21c7500202e418b09cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86c557417ac21c7500202e418b09cd4">&#9670;&#160;</a></span>GetWidgetByMarkupsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvtkSlicerMarkupsWidget.html">vtkSlicerMarkupsWidget</a> * vtkSlicerMarkupsLogic::GetWidgetByMarkupsType </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>markupsType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns an instance to a corresponding <a class="el" href="classvtkSlicerMarkupsWidget.html" title="Process interaction events to update state of markup widget nodes.">vtkSlicerMarkupsWidget</a> associated to the indicated markups name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsType</td><td>registered class to retrieve the associated widget. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to associated <a class="el" href="classvtkSlicerMarkupsWidget.html" title="Process interaction events to update state of markup widget nodes.">vtkSlicerMarkupsWidget</a> or nullptr if the MRML node class is not registered. </dd></dl>

</div>
</div>
<a id="a596c3cd169164004ba1260e72fde4669" name="a596c3cd169164004ba1260e72fde4669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596c3cd169164004ba1260e72fde4669">&#9670;&#160;</a></span>ImportControlPointsFromCSV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::ImportControlPointsFromCSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import markups node control points from CSV file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsNode</td><td>Node that the control points are imported from. </td></tr>
    <tr><td class="paramname">filename</td><td>Input filename. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d3b0c1770bcb15c0ef940dd3f9cd20" name="af7d3b0c1770bcb15c0ef940dd3f9cd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d3b0c1770bcb15c0ef940dd3f9cd20">&#9670;&#160;</a></span>ImportControlPointsFromTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::ImportControlPointsFromTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLTableNode.html">vtkMRMLTableNode</a> *</td>          <td class="paramname"><span class="paramname"><em>tableNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startRow</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numberOfRows</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import markups control points from table node Column names: label, r, a, s, (or l, p, s), defined, selected, visible, locked, description. </p>

</div>
</div>
<a id="af967f6cfe6caed926fde6a24ee6a3a71" name="af967f6cfe6caed926fde6a24ee6a3a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af967f6cfe6caed926fde6a24ee6a3a71">&#9670;&#160;</a></span>IsA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int vtkSlicerMarkupsLogic::IsA </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classvtkSlicerModuleLogic.html#afe98b30ad85954605c2b4079d5823003">vtkSlicerModuleLogic</a>.</p>

</div>
</div>
<a id="a8e9f73a6d39a63106964c6b5df3e9cbb" name="a8e9f73a6d39a63106964c6b5df3e9cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9f73a6d39a63106964c6b5df3e9cbb">&#9670;&#160;</a></span>IsMarkupsNodeRegistered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::IsMarkupsNodeRegistered </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nodeType</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the provided class name is a known markups class (it has been registered in the logic using RegisterMarkupsNode). </p>

</div>
</div>
<a id="a5241d3e56ea8111684b6d18b90e132f0" name="a5241d3e56ea8111684b6d18b90e132f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5241d3e56ea8111684b6d18b90e132f0">&#9670;&#160;</a></span>IsPolygonClockwise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool vtkSlicerMarkupsLogic::IsPolygonClockwise </td>
          <td>(</td>
          <td class="paramtype">vtkPoints *</td>          <td class="paramname"><span class="paramname"><em>points</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIdList *</td>          <td class="paramname"><span class="paramname"><em>pointIds</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the polygon points are oriented clockwise. If pointIds is null then point IDs will be 0, 1, 2, ... n-1. </p>

</div>
</div>
<a id="a7471a759a3de4ae3f8e1f478ae90b53f" name="a7471a759a3de4ae3f8e1f478ae90b53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7471a759a3de4ae3f8e1f478ae90b53f">&#9670;&#160;</a></span>IsTypeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int vtkSlicerMarkupsLogic::IsTypeOf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a856997f13f6a12f60c2c9e730e2a9fce" name="a856997f13f6a12f60c2c9e730e2a9fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856997f13f6a12f60c2c9e730e2a9fce">&#9670;&#160;</a></span>JumpSlicesToLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::JumpSlicesToLocation </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>z</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>centered</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>viewGroup</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *</td>          <td class="paramname"><span class="paramname"><em>exclude</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>jump the slice windows to the given coordinate If viewGroup is -1 then all all slice views are updated, otherwise only those views that are in the specified group. </p>

</div>
</div>
<a id="a41df76ffe605b8d05e254d8a6de0debc" name="a41df76ffe605b8d05e254d8a6de0debc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41df76ffe605b8d05e254d8a6de0debc">&#9670;&#160;</a></span>JumpSlicesToNthPointInMarkup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::JumpSlicesToNthPointInMarkup </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>centered</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>viewGroup</em><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSliceNode.html">vtkMRMLSliceNode</a> *</td>          <td class="paramname"><span class="paramname"><em>exclude</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>jump the slice windows to the nth markup with the mrml id id </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a856997f13f6a12f60c2c9e730e2a9fce">JumpSlicesToLocation</a> </dd></dl>

</div>
</div>
<a id="a88d22fc821fe3d5e0ccc2a7fcaaa505d" name="a88d22fc821fe3d5e0ccc2a7fcaaa505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d22fc821fe3d5e0ccc2a7fcaaa505d">&#9670;&#160;</a></span>LoadAnnotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * vtkSlicerMarkupsLogic::LoadAnnotation </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>annotationFileType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a legacy annotation file, return nullptr on error, node ID string otherwise. Adds the appropriate storage and display nodes to the scene as well. fileType is from this class's enum </p>

</div>
</div>
<a id="a9792d6d7b5687cc7955ba1e176262f9c" name="a9792d6d7b5687cc7955ba1e176262f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9792d6d7b5687cc7955ba1e176262f9c">&#9670;&#160;</a></span>LoadMarkups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * vtkSlicerMarkupsLogic::LoadMarkups </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fidsName</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a markups node from fileName, return nullptr on error, node ID string otherwise. Adds the appropriate storage and display nodes to the scene as well. </p>

</div>
</div>
<a id="ac7292c875559c2a6b4057875191dab6c" name="ac7292c875559c2a6b4057875191dab6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7292c875559c2a6b4057875191dab6c">&#9670;&#160;</a></span>LoadMarkupsFiducials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * vtkSlicerMarkupsLogic::LoadMarkupsFiducials </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fidsName</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is deprecated. It is kept for backward compatibility only, it does the same as LoadMarkups method. </p>

</div>
</div>
<a id="ad0be9ac5ff60eb4553677d2b393b0f80" name="ad0be9ac5ff60eb4553677d2b393b0f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be9ac5ff60eb4553677d2b393b0f80">&#9670;&#160;</a></span>LoadMarkupsFromFcsv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * vtkSlicerMarkupsLogic::LoadMarkupsFromFcsv </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nodeName</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb74bbb0bace9e3138c50eed9363f11f" name="aeb74bbb0bace9e3138c50eed9363f11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb74bbb0bace9e3138c50eed9363f11f">&#9670;&#160;</a></span>LoadMarkupsFromJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * vtkSlicerMarkupsLogic::LoadMarkupsFromJson </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fileName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nodeName</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMessageCollection.html">vtkMRMLMessageCollection</a> *</td>          <td class="paramname"><span class="paramname"><em>userMessages</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa36a4d4afd693d07419da5247f6c01d2" name="aa36a4d4afd693d07419da5247f6c01d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36a4d4afd693d07419da5247f6c01d2">&#9670;&#160;</a></span>MoveNthControlPointToNewListAtIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::MoveNthControlPointToNewListAtIndex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>newMarkupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>utility method to move a control point from one list to another, trying to insert it at the given new index. If the new index is larger than the number of control points in the list, adds it to the end. If new index is smaller than 0, adds it at the beginning. Otherwise inserts at that index. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLMarkupsNode.html#a797d2b4746481047f1451f179cd82c3f">vtkMRMLMarkupsNode::InsertControlPoint</a> Returns true on success, false on failure </dd></dl>

</div>
</div>
<a id="ae2e4f6c7ed2097b0bea3f35e3104267d" name="ae2e4f6c7ed2097b0bea3f35e3104267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e4f6c7ed2097b0bea3f35e3104267d">&#9670;&#160;</a></span>MoveNthMarkupToNewList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::MoveNthMarkupToNewList </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>newMarkupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated</a></b></dt><dd>Use MoveNthControlPointToNewList instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00352">352</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a10ead326a2b7f15e93e4082ec8f3ac28" name="a10ead326a2b7f15e93e4082ec8f3ac28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ead326a2b7f15e93e4082ec8f3ac28">&#9670;&#160;</a></span>New()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerMarkupsLogic.html">vtkSlicerMarkupsLogic</a> * vtkSlicerMarkupsLogic::New </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a2349dd2aa90c6fa2b6dd8a22588a78" name="a5a2349dd2aa90c6fa2b6dd8a22588a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2349dd2aa90c6fa2b6dd8a22588a78">&#9670;&#160;</a></span>ObserveMRMLScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ObserveMRMLScene </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a scene is set to the logic and nodes are registered (<a class="el" href="#afea7e2730adfe2f96a326f8180454991" title="Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this...">RegisterNodes()</a>). The scene events to observe are already set in <a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal()</a>. By default, <a class="el" href="#a5a2349dd2aa90c6fa2b6dd8a22588a78">ObserveMRMLScene()</a> calls <a class="el" href="#a094488fadee2d55b7ac6e8ed36f058b6">UpdateFromMRMLScene()</a>. Override for a custom behavior. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal</a>, <a class="el" href="#afea7e2730adfe2f96a326f8180454991" title="Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this...">RegisterNodes</a>, <a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a> </dd>
<dd>
<a class="el" href="#a094488fadee2d55b7ac6e8ed36f058b6">UpdateFromMRMLScene</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#abeec5de56ddcf3ed8206ed1fa388c364">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a03a47d3ed8414fb523abb2204a8bcc65" name="a03a47d3ed8414fb523abb2204a8bcc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a47d3ed8414fb523abb2204a8bcc65">&#9670;&#160;</a></span>OnMRMLSceneEndImport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::OnMRMLSceneEndImport </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classvtkMRMLScene.html#a8ccb4e378bdb987a4e95ac6cc1067c94a3c8da384b75d5f60f2f496df6977a904">vtkMRMLScene::EndImportEvent</a> has been set to be observed in SetMRMLSceneInternal, it is called when the scene fires the event </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a>, <a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal</a> </dd>
<dd>
<a class="el" href="classvtkMRMLAbstractLogic.html#a048ce8ed9409c07be134bcd03ae27184">OnMRMLSceneStartImport</a>, <a class="el" href="classvtkMRMLAbstractLogic.html#ac9c4356c3ad53f529f948214d5ce30f1">OnMRMLSceneNew</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#ae826dc18ec31156f0eae3456608eb1c4">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a24c0a71539ab517250e85775c7db5944" name="a24c0a71539ab517250e85775c7db5944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c0a71539ab517250e85775c7db5944">&#9670;&#160;</a></span>OnMRMLSceneNodeAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::OnMRMLSceneNodeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classvtkMRMLScene.html#a8ccb4e378bdb987a4e95ac6cc1067c94a883501afca47bd5809645023742ddcd3">vtkMRMLScene::NodeAddedEvent</a> has been set to be observed in SetMRMLSceneInternal, it is called when the scene fires the event </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a>, <a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal</a> </dd>
<dd>
<a class="el" href="#abe5f837c6a4f65e40e7b2e9302bdcf25">OnMRMLSceneNodeRemoved</a>, vtkMRMLScene::NodeAboutToBeAdded </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#ac0102310f18a3880f00e93b8e37210c9">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="abe5f837c6a4f65e40e7b2e9302bdcf25" name="abe5f837c6a4f65e40e7b2e9302bdcf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5f837c6a4f65e40e7b2e9302bdcf25">&#9670;&#160;</a></span>OnMRMLSceneNodeRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::OnMRMLSceneNodeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLNode.html">vtkMRMLNode</a> *</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If <a class="el" href="classvtkMRMLScene.html#a8ccb4e378bdb987a4e95ac6cc1067c94accb3b014a26a4bc5c4c2a6a5e325a710">vtkMRMLScene::NodeRemovedEvent</a> has been set to be observed in SetMRMLSceneInternal, it is called when the scene fires the event </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a>, <a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal</a> </dd>
<dd>
<a class="el" href="#a24c0a71539ab517250e85775c7db5944">OnMRMLSceneNodeAdded</a>, vtkMRMLScene::NodeAboutToBeRemoved </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a92b1149d08ec5099a9ec61c0636f37c4">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="adb319530d0fa790b5d40ed3c807695e6" name="adb319530d0fa790b5d40ed3c807695e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb319530d0fa790b5d40ed3c807695e6">&#9670;&#160;</a></span>PrintSelf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::PrintSelf </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vtkIndent</td>          <td class="paramname"><span class="paramname"><em>indent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af60807c5ea42cd4b4471db833a03f96d" name="af60807c5ea42cd4b4471db833a03f96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60807c5ea42cd4b4471db833a03f96d">&#9670;&#160;</a></span>ProcessMRMLNodesEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ProcessMRMLNodesEvents </td>
          <td>(</td>
          <td class="paramtype">vtkObject *</td>          <td class="paramname"><span class="paramname"><em>caller</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>event</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callData</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives all the events fired by the nodes. To listen to a node, you can add an observer using <a class="el" href="classvtkMRMLAbstractLogic.html#a31c1e7f33880b6ad9683548fbc4ccaca">GetMRMLNodesCallbackCommand()</a> or use the utility macros vtk[SetAndObserve|Observe]MRMLNode[Event]Macro ProcessMRMLNodesEvents calls OnMRMLNodeModified when event is vtkCommand::ModifiedEvent. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvtkMRMLAbstractLogic.html#a51fdf00ecfc18c1a1465d4bccb789ef1">ProcessMRMLSceneEvents</a>, <a class="el" href="classvtkMRMLAbstractLogic.html#adac3d2b2ec84f30d78d3a6c8d8aeb828">ProcessMRMLLogicsEvents</a>, <a class="el" href="classvtkMRMLAbstractLogic.html#a124e968e51a99e4dc16d022b3fd37e2e">OnMRMLNodeModified()</a>, <a class="el" href="vtkMRMLAbstractLogic_8h.html#a57aad1825928272ed298a01dcbf6b4a7" title="Set and observe a MRML node. Replace the existing value of node with value. Unobserve the old node an...">vtkSetAndObserveMRMLNodeMacro</a>, <a class="el" href="vtkMRMLAbstractLogic_8h.html#a943af5891e5b3c345c8cc4906845139f">vtkObserveMRMLNodeMacro</a>, vtkSetAndObserveMRMLNodeEventMacro </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a43a759874ce32846c6dffc52e5941744">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="ab5f2bc3c2eb6d7c2ff83886deea15158" name="ab5f2bc3c2eb6d7c2ff83886deea15158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f2bc3c2eb6d7c2ff83886deea15158">&#9670;&#160;</a></span>RegisterJsonStorageNodeForMarkupsType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::RegisterJsonStorageNodeForMarkupsType </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>markupsType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>storageNodeClassName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58fa523d3ee840c447d4e6dd14cd125b" name="a58fa523d3ee840c447d4e6dd14cd125b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fa523d3ee840c447d4e6dd14cd125b">&#9670;&#160;</a></span>RegisterMarkupsNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::RegisterMarkupsNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkSlicerMarkupsWidget.html">vtkSlicerMarkupsWidget</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsWidget</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>createPushButton</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a markup and its corresponding widget to be handled by the Markups module. For a markup to be handled by this module (processed by the displayable manager, UI and subject hierarchy) it needs to be registered using this method. The method also registers the markupsNode class in the scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsNode</td><td>MRMLMarkups node to be registered. </td></tr>
    <tr><td class="paramname">markupsWidget</td><td>vtkSlicerWidget associated to the MRMLMarkups node registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea7e2730adfe2f96a326f8180454991" name="afea7e2730adfe2f96a326f8180454991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea7e2730adfe2f96a326f8180454991">&#9670;&#160;</a></span>RegisterNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::RegisterNodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register MRML Node classes to Scene. Gets called automatically when the MRMLScene is attached to this logic class. </p>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#acfa7f65f53d5fbe6d056e7cf32a23058">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a1db11d2a95abec0db33f63c8d5156341" name="a1db11d2a95abec0db33f63c8d5156341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db11d2a95abec0db33f63c8d5156341">&#9670;&#160;</a></span>RenameAllControlPointsFromCurrentFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::RenameAllControlPointsFromCurrentFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the control points in the list and reset the control point labels using the current ControlPointLabelFormat setting. Try to keep current numbering. Will work if there's a d, g or f in the format string, but precision is not handled. </p>

</div>
</div>
<a id="aceceecc99edeabe7f5a3eaac55e842b2" name="aceceecc99edeabe7f5a3eaac55e842b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceceecc99edeabe7f5a3eaac55e842b2">&#9670;&#160;</a></span>RenameAllMarkupsFromCurrentFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::RenameAllMarkupsFromCurrentFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated</a></b></dt><dd>Use RenameAllControlPointsFromCurrentFormat instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00401">401</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a773a595fb1169dd9952f8a281039295e" name="a773a595fb1169dd9952f8a281039295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773a595fb1169dd9952f8a281039295e">&#9670;&#160;</a></span>SafeDownCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvtkSlicerMarkupsLogic.html">vtkSlicerMarkupsLogic</a> * vtkSlicerMarkupsLogic::SafeDownCast </td>
          <td>(</td>
          <td class="paramtype">vtkObject *</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af483e63ff07ecdffd44d53b232e329" name="a4af483e63ff07ecdffd44d53b232e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af483e63ff07ecdffd44d53b232e329">&#9670;&#160;</a></span>SetActiveList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetActiveList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility method to set the active place node from the passed markups node. Does not set the interaction mode to place. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a16b4aef2d9033de20078fd411d0bddc6">GetActiveListID</a>, <a class="el" href="#aa89001af895634a5c3455b68a5eb0657">StartPlaceMode</a> </dd>
<dd>
<a class="el" href="classvtkMRMLSelectionNode.html#a8aef56b59f4d54bcb527a5c7bcc62566">vtkMRMLSelectionNode::SetReferenceActivePlaceNodeClassName</a> </dd>
<dd>
<a class="el" href="classvtkMRMLSelectionNode.html#a5e284490a06c5b4aa632d08783b80c77">vtkMRMLSelectionNode::SetActivePlaceNodeID</a> </dd></dl>

</div>
</div>
<a id="adee8a00ad7b15f2ba49dc8f4617eb99e" name="adee8a00ad7b15f2ba49dc8f4617eb99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee8a00ad7b15f2ba49dc8f4617eb99e">&#9670;&#160;</a></span>SetActiveListID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetActiveListID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is deprecated due to its confusing name. It is kept for backward compatibility only, SetActiveList method should be used instead. </p>

</div>
</div>
<a id="a3b1ee444e47f2e105b9dbf67a1b3c537" name="a3b1ee444e47f2e105b9dbf67a1b3c537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ee444e47f2e105b9dbf67a1b3c537">&#9670;&#160;</a></span>SetAllControlPointsLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllControlPointsLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35c195efc8b0f44d4f57303111088fb4" name="a35c195efc8b0f44d4f57303111088fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c195efc8b0f44d4f57303111088fb4">&#9670;&#160;</a></span>SetAllControlPointsSelected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllControlPointsSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73fc114879f0c23c567dbd115c458668" name="a73fc114879f0c23c567dbd115c458668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fc114879f0c23c567dbd115c458668">&#9670;&#160;</a></span>SetAllControlPointsVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllControlPointsVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility methods to operate on all control points in a markups node </p>

</div>
</div>
<a id="aa4624cefcd91eb8990930b9eed233972" name="aa4624cefcd91eb8990930b9eed233972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4624cefcd91eb8990930b9eed233972">&#9670;&#160;</a></span>SetAllMarkupsLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllMarkupsLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated</a></b></dt><dd>Use SetAllControlPointsLocked instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00377">377</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a24870583ce859b982d1480fe12f69c44" name="a24870583ce859b982d1480fe12f69c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24870583ce859b982d1480fe12f69c44">&#9670;&#160;</a></span>SetAllMarkupsSelected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllMarkupsSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated</a></b></dt><dd>Use SetAllControlPointsSelected instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00389">389</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a9c07142e9ff9004e5909515a9d374adc" name="a9c07142e9ff9004e5909515a9d374adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c07142e9ff9004e5909515a9d374adc">&#9670;&#160;</a></span>SetAllMarkupsVisibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAllMarkupsVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated</a></b></dt><dd>Use SetAllControlPointsVisibility instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00365">365</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a93f79addb66a08c4c7b54d51d871e1c7" name="a93f79addb66a08c4c7b54d51d871e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f79addb66a08c4c7b54d51d871e1c7">&#9670;&#160;</a></span>SetAndObserveSelectionNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetAndObserveSelectionNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLSelectionNode.html">vtkMRMLSelectionNode</a> *</td>          <td class="paramname"><span class="paramname"><em>selectionNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be093fee550bfd80e88c2fa49e39ef8" name="a8be093fee550bfd80e88c2fa49e39ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be093fee550bfd80e88c2fa49e39ef8">&#9670;&#160;</a></span>SetAutoCreateDisplayNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vtkSlicerMarkupsLogic::SetAutoCreateDisplayNodes </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe9254bd4d83d45b1ab02d291103e1ff" name="abe9254bd4d83d45b1ab02d291103e1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9254bd4d83d45b1ab02d291103e1ff">&#9670;&#160;</a></span>SetDisplayDefaultsFromNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetDisplayDefaultsFromNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *</td>          <td class="paramname"><span class="paramname"><em>displayNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility method to set defaults from display node </p>

</div>
</div>
<a id="aead1f2f4cede0c3bf0fa775270c3f945" name="aead1f2f4cede0c3bf0fa775270c3f945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead1f2f4cede0c3bf0fa775270c3f945">&#9670;&#160;</a></span>SetDisplayNodeToDefaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetDisplayNodeToDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsDisplayNode.html">vtkMRMLMarkupsDisplayNode</a> *</td>          <td class="paramname"><span class="paramname"><em>displayNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility method to set up a display node from the defaults. Point labels visibility and properties label visibility setting is not saved to defaults, as typically it is better to initialize these based on the node type (point labels are more useful for fiducials, while properties label is more useful for other markups). </p>

</div>
</div>
<a id="a9f222b5020a80f90c4a7bd1073b0193f" name="a9f222b5020a80f90c4a7bd1073b0193f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f222b5020a80f90c4a7bd1073b0193f">&#9670;&#160;</a></span>SetMRMLSceneInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::SetMRMLSceneInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLScene.html">vtkMRMLScene</a> *</td>          <td class="paramname"><span class="paramname"><em>newScene</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize listening to MRML events. </p>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a8a1dc1c9192488743cbb0289d3f03600">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="aa89001af895634a5c3455b68a5eb0657" name="aa89001af895634a5c3455b68a5eb0657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89001af895634a5c3455b68a5eb0657">&#9670;&#160;</a></span>StartPlaceMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vtkSlicerMarkupsLogic::StartPlaceMode </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>persistent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvtkMRMLInteractionNode.html">vtkMRMLInteractionNode</a> *</td>          <td class="paramname"><span class="paramname"><em>interactionNode</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put the interaction node into place mode, and set the persistence of place mode according to the persistent flag. Return true on successfully going into place mode, false otherwise. By default, the default interaction node is updated. </p><dl class="section see"><dt>See also</dt><dd>SetActiveIDList </dd></dl>

</div>
</div>
<a id="ae03406c7c3d457a7fe0a9f9388d81c62" name="ae03406c7c3d457a7fe0a9f9388d81c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03406c7c3d457a7fe0a9f9388d81c62">&#9670;&#160;</a></span>ToggleAllControlPointsLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllControlPointsLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7fa209056e6457d13c66564046998fb" name="ae7fa209056e6457d13c66564046998fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fa209056e6457d13c66564046998fb">&#9670;&#160;</a></span>ToggleAllControlPointsSelected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllControlPointsSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8798fc8eab0938e56e5936a002cab943" name="a8798fc8eab0938e56e5936a002cab943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8798fc8eab0938e56e5936a002cab943">&#9670;&#160;</a></span>ToggleAllControlPointsVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllControlPointsVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0206e9a0cdae35b08065873c3bfd6e8b" name="a0206e9a0cdae35b08065873c3bfd6e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0206e9a0cdae35b08065873c3bfd6e8b">&#9670;&#160;</a></span>ToggleAllMarkupsLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllMarkupsLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated</a></b></dt><dd>Use ToggleAllControlPointsLocked instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00383">383</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="acff6be4a295b21cbbeb03f8bc3121ad2" name="acff6be4a295b21cbbeb03f8bc3121ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff6be4a295b21cbbeb03f8bc3121ad2">&#9670;&#160;</a></span>ToggleAllMarkupsSelected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllMarkupsSelected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated</a></b></dt><dd>Use ToggleAllControlPointsSelected instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00395">395</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="a5cd0d897b8d3911298fcdecafa12ffe2" name="a5cd0d897b8d3911298fcdecafa12ffe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd0d897b8d3911298fcdecafa12ffe2">&#9670;&#160;</a></span>ToggleAllMarkupsVisibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::ToggleAllMarkupsVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated</a></b></dt><dd>Use ToggleAllControlPointsVisibility instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html#l00371">371</a> of file <a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a>.</p>

</div>
</div>
<a id="aaed31808522f99d422c886fd5cf4d18e" name="aaed31808522f99d422c886fd5cf4d18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed31808522f99d422c886fd5cf4d18e">&#9670;&#160;</a></span>UnregisterMarkupsNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::UnregisterMarkupsNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvtkMRMLMarkupsNode.html">vtkMRMLMarkupsNode</a> *</td>          <td class="paramname"><span class="paramname"><em>markupsNode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a markup and its corresponding widget. This will trigger the <a class="el" href="#ad1e18b1e6c786f797118aa763fb02183a2b0dab5b25a58235ffbdd4078f020059">vtkSlicerMarkupsLogic::MarkupUnregistered</a> event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markupsNode</td><td>MRMLMarkups node to be unregistered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a094488fadee2d55b7ac6e8ed36f058b6" name="a094488fadee2d55b7ac6e8ed36f058b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094488fadee2d55b7ac6e8ed36f058b6">&#9670;&#160;</a></span>UpdateFromMRMLScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::UpdateFromMRMLScene </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called every time the scene has been significantly changed. If the scene BatchProcessState events are observed (in <a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal()</a> ), UpdateFromMRMLScene is called after each batch process (Close, Import, Restore...). It is also being called by default when a new scene is set (SetMRMLScene). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9f222b5020a80f90c4a7bd1073b0193f" title="Initialize listening to MRML events.">SetMRMLSceneInternal</a>, <a class="el" href="classvtkMRMLAbstractLogic.html#a966747ac1626e911a08ce8bb9ba909eb">UnobserveMRMLScene</a>, <a class="el" href="#a5a2349dd2aa90c6fa2b6dd8a22588a78">ObserveMRMLScene</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classvtkMRMLAbstractLogic.html#a50caeb3a373ccd53635ae2c08bc2e63e">vtkMRMLAbstractLogic</a>.</p>

</div>
</div>
<a id="a22a338606882716385079199819d9e08" name="a22a338606882716385079199819d9e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a338606882716385079199819d9e08">&#9670;&#160;</a></span>UpdatePlaceNodeClassNamesInSelectionNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vtkSlicerMarkupsLogic::UpdatePlaceNodeClassNamesInSelectionNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update list of place node class names in selection node based on currently registered markups. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Modules/Loadable/Markups/Logic/<a class="el" href="vtkSlicerMarkupsLogic_8h_source.html">vtkSlicerMarkupsLogic.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 20 2025 03:54:27 for Slicer by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
